unit unit_boxes;interfaceuses{$IFC UNDEFINED THINK_Pascal}Types, Quickdraw,{$ENDC}unit_atoms;const  MAXBOXES = 1024;type  AnimalBoxHandle = ^AnimalBoxPtr;  AnimalBoxPtr = ^AnimalBox;  AnimalBox = record    box: Rect;    centre: Point;    breedersChoice: AtomHdl;    AnimalPicture: PicHandle;    hasPicture: boolean;    Next: AnimalBoxHandle;  end;  BoxesHandle = ^BoxesPtr;  BoxesPtr = ^Boxes;  Boxes = record    nRows: integer;    nCols: integer;    pRect: Rect;    NBoxes: integer;    MidBox: AnimalBoxHandle;    firstAnimalBox: AnimalBoxHandle;    engineeringAnimalBox: AnimalBoxHandle;  end;function NewBoxes(nRows, nCols: integer): BoxesHandle;procedure DisposeBoxes(theBoxes: BoxesHandle);procedure SetUpBoxes(theBoxes: BoxesHandle; pRect: Rect);procedure DrawBoxes(theBoxes: BoxesHandle);procedure RedimensionBoxes(theBoxes: BoxesHandle; newRows, newCols: integer);function CalculateLowDiscard(oldLength, newLength: integer): integer;function CalculateHighDiscard(oldLength, newLength: integer): integer;implementation{$IFC UNDEFINED THINK_Pascal}uses Memory;{$ENDC}{Called from UpdateAnimals}procedure DrawBoxes(theBoxes: BoxesHandle);var  theBox: AnimalBoxHandle;begin   {Erase all the boxes that aren't the special}  with theBoxes^^ do  begin    theBox := theBoxes^^.firstAnimalBox;    while theBox <> nil do    begin      if theBox <> midBox then        FrameRect(theBox^^.box)      else      begin        PenSize(3, 3);        FrameRect(theBox^^.box);        PenSize(1, 1);      end;      theBox := theBox^^.Next;    end;  end;end;procedure RedimensionBoxes(theBoxes: BoxesHandle; newRows, newCols: integer);begin  with theBoxes^^ do  begin    nRows := newRows;    nCols := newCols;    NBoxes := NRows * NCols;  end;end;function CalculateLowDiscard(oldLength, newLength: integer): integer;begin  if (oldLength mod 2 = 1) or (newLength mod 2 = 0) then    CalculateLowDiscard := (oldLength - newLength) div 2  else    CalculateLowDiscard := (oldLength - newLength) div 2 + 1;end;function CalculateHighDiscard(oldLength, newLength: integer): integer;begin  if (oldLength mod 2 = 0) or (newLength mod 2 = 1) then    CalculateHighDiscard := oldLength - (oldLength - newLength) div 2 + 1  else    CalculateHighDiscard := oldLength - (oldLength - newLength) div 2;end;function NewBoxes(nRows, nCols: integer): BoxesHandle;var  theBoxes: BoxesHandle;  i: integer;  newAnimalBox: AnimalBoxHandle;  prevAnimalBox: AnimalBoxHandle;  midBoxIndex: integer;begin  theBoxes := BoxesHandle(NewHandle(SizeOf(Boxes)));  RedimensionBoxes(theBoxes, nRows, nCols);  with theBoxes^^ do  begin    prevAnimalBox := nil;    midBoxIndex := NBoxes div 2 + 1;    for i := 0 to NBoxes do    begin      newAnimalBox := AnimalBoxHandle(NewHandle(sizeOf(AnimalBox)));      if i = 1 then        firstAnimalBox := newAnimalBox;      if i = 0 then        engineeringAnimalBox := newAnimalBox;      if i = midBoxIndex then        midBox := newAnimalBox;      with newAnimalBox^^ do      begin        hasPicture := False;        BreedersChoice := nil;      end;      if prevAnimalBox <> nil then        prevAnimalBox^^.Next := newAnimalBox;      prevAnimalBox := newAnimalBox;    end;    newAnimalBox^^.Next := nil;  end;  NewBoxes := theBoxes;end;procedure DisposeBoxes(theBoxes: BoxesHandle);var  theAnimalBox: AnimalBoxHandle;  nextAnimalBox: AnimalBoxHandle;  quit: boolean;begin  quit := False;  with theBoxes^^ do    theAnimalBox := theBoxes^^.engineeringAnimalBox;  while not quit do  begin    with theAnimalBox^^ do    begin      if hasPicture then        KillPicture(AnimalPicture);    end;    if theAnimalBox^^.Next = nil then      quit := True;    nextAnimalBox := theAnimalBox^^.Next;    DisposeHandle(Handle(theAnimalBox));    theAnimalBox := nextAnimalBox;  end;  DisposeHandle(Handle(theBoxes));end;procedure SetUpBoxes(theBoxes: BoxesHandle; pRect: Rect);var  theBox: AnimalBoxHandle;  l, t, row, column, boxwidth, Height: integer;begin  {pRect := windowToTessellate^.PortRect;}  with pRect do  begin    bottom := bottom - 20;    right := right - 20;  end;  theBoxes^^.pRect := pRect;  EraseRect(pRect);  with theBoxes^^ do  begin    theBox := firstAnimaLBox;    with pRect do    begin      boxwidth := (right - left) div ncols;      Height := (bottom - top) div nrows;      for row := 1 to NRows do        for column := 1 to NCols do        begin          l := left + boxwidth * (column - 1);          t := top + Height * (row - 1);          with theBox^^ do          begin            SetRect(box, l, t, l + boxwidth, t + Height);            with box do            begin              Centre.h := left + boxwidth div 2;              Centre.v := top + Height div 2;            end;          end;          theBox := theBox^^.Next;        end; {row & column loop}    end; {WITH pRect}    {Special box for Engineering window}    with engineeringAnimalBox^^ do    begin      SetRect(Box, 261, 28, 483, 320);      with Box do      begin        boxwidth := right - left;        Height := bottom - top;        Centre.h := left + boxwidth div 2;        Centre.v := top + Height div 2;      end;    end;  end;end; {setup boxes}end.