unit unit_evolve;interfaceuses {$IFC UNDEFINED THINK_Pascal}  Types, Quickdraw, {$ENDC}  unit_boxes, unit_grow_child, unit_preferences, unit_slide, unit_atoms;type  EvolveStateOp = (    Clicked,    Erasing,    Sliding,    SettingUpBoxes,    DrawingParent,    GrowingChildren,    GrowingMoreChildren,    EvolveComplete);  EvolveStateHandle = ^EvolveStatePtr;  EvolveStatePtr = ^EvolveState;  EvolveState = record    evolveOp: EvolveStateOp;    MLoc: Point;    special: AnimalBoxHandle;    sstate: SlideStateHandle;    gState: GrowChildStateHandle;    preserveLivingSpecimens: boolean;  end;{call this as Evolve(MyPt) from Do_Breeding_Window }{immediately after defining MyPt}function evolve(myPt: Point): EvolveStateHandle;procedure evolveStep(prefs: ArthromorphPreferencesHandle; state: EvolveStateHandle);function NewEvolveState(myPt: Point): EvolveStateHandle;procedure DisposeEvolveState(eState: EvolveStateHandle);implementationuses {$IFC UNDEFINED THINK_Pascal}  Memory, {$ENDC}  unit_richard, unit_draw;function NewEvolveState(myPt: Point): EvolveStateHandle;var  eState: EvolveStateHandle;begin  eState := EvolveStateHandle(NewHandle(SizeOf(EvolveState)));  with eState^^ do  begin    evolveOp := Clicked;    MLoc := myPt;    special := nil;    sstate := nil;    preserveLivingSpecimens := false;  end;  NewEvolveState := eState;end;procedure DisposeEvolveState(eState: EvolveStateHandle);begin  DisposeHandle(Handle(eState));end;procedure EraseAllBoxesButSpecial(prefs: ArthromorphPreferencesHandle;  theBoxes: BoxesHandle; special: AnimalBoxHandle);var  j: integer;  theBox: AnimalBoxHandle;begin   {Erase all the boxes that aren't the special}  with theBoxes^^ do  begin    theBox := theBoxes^^.firstAnimalBox;    j := 0;    while theBox <> nil do      begin        j := j + 1;        if theBox <> special then          if not prefs^^.resizing then            EraseRect(theBox^^.box);        theBox := theBox^^.Next;      end;  end;end;procedure EraseBoxFrame(theBox: AnimalBoxHandle);var  savePenState: PenState;begin  GetPenState(savePenState);  PenPat(white);  FrameRect(theBox^^.box);  SetPenState(savePenState);end;function DetermineBoxClicked(theBoxes: BoxesHandle; thePoint: Point): AnimalBoxHandle;var  theBox: AnimalBoxHandle;  special: AnimalBoxHandle;begin  theBox := theBoxes^^.firstAnimalBox;  special := nil;   {Figure out which 'special' box was selected by mouse click}  with theBoxes^^ do  begin    while theBox <> nil do      begin        if (PtInRect(thePoint, theBox^^.box)) then          special := theBox;        theBox := theBox^^.next;      end;    if special <> nil then      DetermineBoxClicked := special    else      DetermineBoxClicked := nil;  end;end;procedure evolveStep(prefs: ArthromorphPreferencesHandle; state: EvolveStateHandle);begin  with state^^ do    with prefs^^ do      with theBoxes^^ do        case evolveOp of          Clicked:          begin            special := DetermineBoxClicked(theBoxes, MLoc);            if (special <> nil) and (special^^.BreedersChoice <> nil) then              evolveOp := Erasing            else              evolveOp := EvolveComplete;          end;          Erasing:          begin            ObscureCursor;            if not state^^.preserveLivingSpecimens then              begin                EraseAllBoxesButSpecial(prefs, prefs^^.theBoxes, special);                {Erase the special's outline prior to sliding}                EraseBoxFrame(special);              end;              {Slide the special into the MidBox}              if special <> midBox then                evolveOp := Sliding              else                evolveOp := SettingUpBoxes          end;          Sliding:          begin            if sstate = nil then            begin              sstate := NewSlideState(prefs, special^^.box,                midBox^^.box);            end;            if SlideFrame(sstate) then {finished sliding}            begin              DisposeSlideState(sstate);              sstate := nil;              kill(midBox^^.BreedersChoice);              {Point the MidBox to the existing animal that will become the}              {next parent. Classic Arthromorphs did a copy here. To accomodate}              {this revision in the Second Edition, GrowChild has been changed}              {so that it refrains}              {from killing the midbox animal}              {based on the animal start, not on the box number - ABC}              midBox^^.BreedersChoice :=                special^^.BreedersChoice;              PrintMiddle(prefs, MidBox);              evolveOp := SettingUpBoxes;            end;          end;          SettingUpBoxes:          begin            SetUpBoxes(theBoxes, BreedingWindow^.portRect);            DrawBoxes(theBoxes);            evolveOp := DrawingParent;          end;          DrawingParent:          begin            ClipRect(midBox^^.Box);            gState := NewGrowChildState(theBoxes);            with prefs^^ do              gstate^^.VerticalOffset :=                DrawInBox(prefs, MidBox, gstate^^.VerticalOffset);            evolveOp := GrowingChildren;          end;          GrowingChildren:          begin            ClipRect(Prect);            with gState^^ do            begin              gState^^.preserveLivingSpecimens := state^^.preserveLivingSpecimens;              if (theBox <> MidBox) then begin                if state^^.preserveLivingSpecimens                   and                 (theBox^^.breedersChoice <> nil) then                 gstate^^.operation := Drawing;                GrowChild(prefs, gState)                end              else                gState^^.operation := GrowChildComplete;              if operation = GrowChildComplete then              begin                if theBox^^.next = nil then                begin                  evolveOp := EvolveComplete;                  ShowCursor;                  DisposeGrowChildState(gState);                  gState := nil;                  special := midBox;                  prefs^^.expandingBoxes := False;                end                else                begin                  theBox := theBox^^.next;                  operation := DrawingSparkLine;                end;              end;            end;          end;        end;end; {evolve}function evolve(myPt: Point): EvolveStateHandle;begin  evolve := NewEvolveState(myPt);end;end.