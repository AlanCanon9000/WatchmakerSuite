unit unit_richard;interfaceuses  unit_atoms, unit_preferences, unit_boxes;procedure PrintMiddle(prefs: ArthromorphPreferencesHandle; midBox: AnimalBoxHandle);implementation	uses{$IFC UNDEFINED THINK_Pascal}		Types, TextUtils,{$ENDC}    unit_strbuffer, unit_dialog_helper;	var		segCounter: INTEGER;  {Convert a real to a string, rounded to two decimal places, left padded with}  {blanks so that it's at least ten characters wide.}  {A more elegant implementation would take field width and decimal places as}  {parameters. Doing so is left as an exercise for the student.}  {-- Alan Canon 2015-11-07}	procedure RealToString (r: real; var theString: Str255);		var			wholePart: LONGINT;			tempString: Str255;			stringLength: INTEGER;			i: integer;	begin		wholePart := Trunc(r);		NumToString(wholePart, theString);		Insert('.', theString, length(theString) + 1);		r := r - wholePart;		wholePart := Trunc(Round(r * 100));		NumToString(wholePart, tempString);		if wholePart < 10 then			insert('0', theString, length(theString) + 1);		if wholePart = 0 then			insert('0', theString, length(theString) + 1)		else			insert(tempString, theString, length(theString) + 1);		stringLength := length(theString);		if stringLength < 10 then			for i := 1 to (10 - stringLength) do				insert(' ', theString, 1);	end;	procedure PrintAt (prefs: ArthromorphPreferencesHandle; theAtom: AtomHdl);		var			strHeight: Str255;			strWidth: Str255;			strAngle: Str255;      theString: Str255;      theAtomString: Str255;      theSegCountString: Str255;	begin		with theAtom^^ do			begin				RealToString(Height, strHeight);				RealToString(Width, strWidth);				RealToString(Angle, strAngle);				{write(Height : 10 : 2, Width : 10 : 2, Angle : 10 : 2, '     ');}				theString := concat(strHeight, strWidth, strAngle, '     ');				case kind of					AnimalTrunk: 						theAtomString := 'AnimalTrunk';					AnimalJoint: 						theAtomString := '    AnimalJoint';					AnimalClaw: 						theAtomString := '    AnimalClaw';					SectionTrunk: 						theAtomString := '        SectionTrunk';					SectionJoint: 						theAtomString := '            SectionJoint';					SectionClaw: 						theAtomString := '            SectionClaw';					SegmentTrunk: 						begin							segCounter := segCounter + 1;              NumToString(segCounter, theSegCountString);							theAtomString := concat('                SegmentTrunk ',                theSegCountString);						end;					SegmentJoint: 						theAtomString := '                    SegmentJoint';					SegmentClaw: 						theAtomString := '                    SegmentClaw';					Joint: 						theAtomString := '                        Joint';					Claw: 						theAtomString := '                        Claw';				end; {cases}        theString := concat(theString, theAtomString);        writelnStrBuffer(prefs^^.genomeStrBuffer, theString);			end	end; {PrintAt}	procedure Print (prefs: ArthromorphPreferencesHandle; which: AtomHdl);   {Print this animal}   {Recursively step through the animal}	begin		with which^^ do			begin				if kind <> free then					PrintAt(prefs, which);				if FirstBelowMe <> nil then					Print(prefs, FirstBelowMe);				if (NextLikeMe <> nil) and (kind <> AnimalTrunk) then					Print(prefs, NextLikeMe);			end	end;	procedure PrintMiddle(prefs: ArthromorphPreferencesHandle; midBox: AnimalBoxHandle);		var			sub: AtomHdl;      tmpStr: Str255;	begin    with prefs^^ do      begin        RewriteStrBuffer(genomeStrBuffer);        NumToString(getAtomCount, tmpStr);		    writeStrBuffer(genomeStrBuffer, 'Atom Count: ');        writelnStrBuffer(genomeStrBuffer, tmpStr);        writelnStrBuffer(genomeStrBuffer, '    Height     Width     Angle');        with midBox^^ do          begin		        sub := BreedersChoice;		        segCounter := 0;		        if sub <> nil then			        if sub^^.kind = AnimalTrunk then				        Print(prefs, BreedersChoice);          end;        InvalidateWindow(GenomeWindow);     end;	end;end.