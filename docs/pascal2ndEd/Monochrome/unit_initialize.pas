unit unit_initialize;{These routines are called once only at startup.  Keep this file in a separate segment that can be unloaded}{At present, initialize proc is *very* long, mostly because of the vast numbers of global vars. We should try}{to cut this down, splitting the proc up and giving vars file scope or less where possible}{History}{v1.1  Added system check}{       Added attempts to save temp file in several places (v1.01 failed on locked server volumes) }{          Removed calls to toolbox inits (done automatically by Think Pascal)}{          Removed calls to MoreMasters (10 calls "             "       "        "   )}{          No longer lock down cursors throughout program execution}{      Improved out of memory warnings (but still some plain ExitToShells in there) }interface	procedure Initialize;implementation	uses{$IFC UNDEFINED THINK_Pascal}		GestaltEqu, think_pascal, Types, OSUtils, StandardFile, Files, SegLoad, TextUtils, Memory, Dialogs, Quickdraw, QuickdrawText, Menus, Controls, Windows, Events, ToolUtils,  {$ENDC}		Traps, Script, Folders, unit_pedigree, unit_globals, unit_miscellaneous, unit_biomorphs, unit_error, unit_standard_get_folder;{Private uses, keeps compilation speed up}(************************************************}{*                       InspectSystem                       *}{*                                                          *}{*  Gather information about the current OS                        *}{*  Added for v1.1.  We collect more info than we really need at present   *}{************************************************){VAR}{S: LongInt;}{Set to size of person, but probably not used otherwise.}	procedure InspectSystem;		var			err: integer;			environs: SysEnvRec;			response: longint;	begin		gSystem.hasGestalt := TrapAvailable(_GestaltDispatch);		gSystem.hasWNE := WNEIsImplemented;		gSystem.hasScriptMgr := TrapAvailable(_ScriptUtil);		gSystem.scriptsInstalled := 1; (* assume only Roman script  *)		err := SysEnvirons(1, environs);		if (err = noErr) then			begin				gSystem.hasColorQD := environs.hasColorQD;				gSystem.hasFPU := environs.hasFPU;				gSystem.systemVersion := environs.systemVersion;    {2-byte hex number, eg $0710 or $0607}				gSystem.sysVRefNum := environs.sysVRefNum;			end		else			begin				gSystem.hasColorQD := False;				gSystem.hasFPU := False;				gSystem.systemVersion := 0;			end;		if (gSystem.hasGestalt) then      {copied from TCL, but I am not sure this always works}			begin				gSystem.hasAppleEvents := Gestalt(gestaltAppleEventsAttr, response) = noErr;				gSystem.hasAliasMgr := Gestalt(gestaltAliasMgrAttr, response) = noErr;				gSystem.hasEditionMgr := Gestalt(gestaltEditionMgrAttr, response) = noErr;				gSystem.hasHelpMgr := Gestalt(gestaltHelpMgrAttr, response) = noErr;				gSystem.hasFolderMgr := Gestalt(gestaltFindFolderAttr, response) = noErr;				if (gSystem.hasScriptMgr) then					begin						err := Gestalt(gestaltScriptCount, response);						if (err = noErr) then							gSystem.scriptsInstalled := integer(response);					end;			end		else  (* If we don't have Gestalt, then we can't have any System 7 features  *)			begin				gSystem.hasAppleEvents := False;				gSystem.hasAliasMgr := False;				gSystem.hasEditionMgr := False;				gSystem.hasFolderMgr := False;				gSystem.hasHelpMgr := False;				if (gSystem.hasScriptMgr) then					gSystem.scriptsInstalled := GetEnvirons(smEnabled);			end;	end;{************************************************}{*   We follow this strategy to deal with servers and locked volumes:          *}{*    1) Try to save into the temp folder on the default disk  (sys 7)      *}{*   2) Try to save in the System folder                          *}{*    3) Try to save in the same folder as the application              *}{*   4) Ask the user                                          *}{*   5) If all the above fail, quit with message to user                *}{*    6) If there is a fossil history file already, delete it              *}{************************************************}	procedure CreateHistoryFile;		const			No = 2;    {Button number in alert}		var			err, ignore: OSErr;			foundVRefNum: integer;                    {vRefNum and dirID of temp folder}			foundDirID, procID: longint;			answer: integer;                        {Alert button pressed}			reply: SFReply;			errString, errCode: Str255;                {String for alerts}			where: Point;                          {For positioning SFPutFile dialog}		procedure GetAFolder (var volRefNum: integer; var dirID: longint; fName: Str255);  {If we have System 7 available we can ask user for a folder if there is trouble. Under System 6}  {we use SFGetFile in the main CreateHistoryFile proc to ask to save the file (maybe this stuff}  {can be converted to system 6?)}			var				mySFReply: StandardFileReply;				myFSSpec: FSSpec;		begin			where.h := -1;              {Get the system to position the box}			where.v := -1;			StandardGetFolder(where, 'Save temp file to:', mySFReply);			if not mySFReply.sfGood then  {User cancelled}				ExitToShell;			volRefNum := mySFReply.sfFile.vRefNum;			dirID := mySFReply.sfFile.parID;			err := FSMakeFSSpec(mySFReply.sfFile.vRefNum, mySFReply.sfFile.parID, fName, myFSSpec);			if err <> noErr then				Exit(GetAFolder);			err := FSpCreate(myFSSpec, 'DAWK', 'FOSS', mySFReply.sfScript);    {We will exit the loop if this succeeded}		end; {GetAFolder}	begin		fileName := 'Fossil History';		volRefNum := defaultVolNum;		dirID := defaultDir;		err := -1;    {set it to anything but noErr to start}		if gSystem.hasFolderMgr then			if FindFolder(volRefNum, kTemporaryFolderType, kCreateFolder, foundVRefNum, foundDirID) = noErr then				begin    {If we found the temp folder, we will try to use it. Otherwise use default folder}					volRefNum := foundVRefNum;					dirID := foundDirID;					DeleteOldFile(volRefNum, dirID, fileName);      {There may already be a file left open after a crash. }					err := HCreate(volRefNum, dirID, fileName, 'DAWK', 'FOSS');				end;		if err <> noErr then			begin            {Second try under system 7, first try under system 6}				ignore := GetWDInfo(gSystem.sysVRefNum, volRefNum, dirID, procID);				DeleteOldFile(volRefNum, dirID, fileName);				err := HCreate(volRefNum, dirID, fileName, 'DAWK', 'FOSS');			end;		if err <> noErr then			begin      {try the default directory}				volRefNum := defaultVolNum;				dirID := defaultDir;				DeleteOldFile(volRefNum, dirID, fileName);				err := HCreate(volRefNum, dirID, fileName, 'DAWK', 'FOSS');			end;		if err <> noErr then			begin  {ask the user to choose a place}				GetIndString(errString, 128, 1);				NumToString(err, errCode);				ParamText(errString, errCode, '', '');				PositionDialog('ALRT', 200);				answer := StopAlert(200, nil);    {'Problem saving temp file, do you want to choose a folder?'}				if answer = No then					ExitToShell;				if gSystem.systemVersion >= $0700 then					GetAFolder(volRefNum, dirID, fileName)  {System 7 ask for folder}				else					begin                            {System 6 normal save file dialog}						FindDlogPosition('DLOG', PutDlgID, where);      {NB NOT sfPutDialogID! That is the System 7 style dialog, which doesn't exist in earlier systems}						SFPutFile(where, 'Save temp file to', fileName, nil, reply);						with reply do							begin								if not good then  {User cancelled operation}									ExitToShell;								ignore := GetWDInfo(vRefNum, volRefNum, dirID, procID);								fileName := fname;								err := HCreate(volRefNum, dirID, fileName, 'DAWK', 'FOSS');							end;{with}					end;{if not sys7}			end;{if}		if err = noErr then    {Okay, we have a file, now try to open it. }			err := HOpen(volRefNum, dirID, fileName, fsRdWrPerm, slides);		if err <> noErr then			begin				GetIndString(errString, 128, 2);				IOError(err, errString);                  { 'Error opening temp file'}				err := HDelete(volRefNum, dirID, fileName);          {Try to clean up after ourself}				ExitToShell;			end;  {if}	end;{CreateHistoryFile}	procedure LoadCursors;{* Load Cursors from resources.   v1.1 renumbered cursors to allow looping. }{* We no longer lock handles, just prevent them from being purged. *}		var			indx: integer;	begin		for Indx := iBeamCursor to watchCursor do          { get four standard system cursors}			begin				CursList[Indx] := GetCursor(Indx);               { read in from system resource}				HNoPurge(Handle(CursList[Indx]));			end;		for indx := leftCursID to BlankCursID do            {Now load custom cursors}			begin				CursList[indx - 130] := GetCursor(indx);				HNoPurge(Handle(CursList[indx - 130]));          {make sure they don't get purged}			end;		SetCursor(CursList[watchCursor]^^);                { bring up watch cursor}	end;  {LoadCursors}	procedure Initialize;{    purpose         initialize everything for the program}{NB Think Pascal sets up toolbox managers, flushes event queue, and calls MoreMasters 10x}		var			SizeNeeded: longint;			j: integer;			ToldToStop: boolean;			errString, helpString: Str255;			aTime: longint;           { keeps track of time }			AlbumBounds: Rect;			ErrorCode: OSErr;			ThumbStrip: Rect;	begin		FossilsToSave := False;		AlbumEmpty := True;		ErrorCode := HGetVol(@DefaultVolume, DefaultVolNum, DefaultDir);  {v1.1 changed to get dirID as well}		if errorcode <> NoErr then			ExitToShell;		InspectSystem;              {**ADDED v1.1*}		CreateHistoryFile;          {      "                 }		Fossilizing := False;  { set up window stuff }		GetWMgrPort(ScreenPort);                { get grafport for all windows      }		SetPort(ScreenPort);                      { and keep hand just in case        }		Prect := ScreenBits.Bounds;		with PRect do			begin				Left := Left + 2;				Top := Top + 20;				Right := Right - 2;				Bottom := Bottom - 2;			end;		PlayBackRect := PRect;		PlayBackRect.Top := PRect.Top + 70;		PlayBackRect.Left := PRect.Left + 50;		PlayBackRect.Bottom := PRect.Bottom - 50;		PlayBackRect.Right := PRect.Right - 50;		MainPtr := NewWindow(@MainRec, PRect, '', True, plainDbox, Pointer(-1), False, 0);  { get window }		SetPort(MainPtr);                           { set window to current graf port   }		MainPeek := WindowPeek(MainPtr);        { get pointer to window record      }		MainPeek^.windowKind := PascalKind;       { set window type  (ID=32700)}		SelectWindow(MainPtr);                     { and make window active            }		frontw := MainPtr;                       { remember that it's in front       }		PlayBackPtr := NewWindow(@PlayBackRecord, PlaybackRect, 'Fossils', False, DocumentProc, Pointer(-1), True, 0);    { get window }		WindowPeek(PlayBackPtr)^.windowKind := PascalKind;		PlayBackRect := PlayBackPtr^.PortRect;		ThumbStrip := PlayBackPtr^.PortRect;		with PlayBackRect do			begin				right := right - Scrollbarwidth - 1;				bottom := bottom - Scrollbarwidth - 1;				MidPoint.h := (right - left) div 2;				MidPoint.v := (bottom - top) div 2;			end;		with PlayBackPtr^.PortRect do			begin				ThumbStrip.left := right - (ScrollBarWidth - 1);				thumbStrip.top := top - 1;				thumbStrip.right := right + 1;				ThumbStrip.bottom := (bottom + 1) - (ScrollBarWidth - 1);			end;		LoadCursors;    {Changed v1.1}		MyControl := NewControl(PlayBackPtr, ThumbStrip, '', True, 0, 0, 0, ScrollBarProc, 0);		MakeOffScreen(MainPtr^.PortBits.Bounds, MyBitMap, burst);		if burst then			begin    {Not enough Memory - Added alert v1.1}				GetIndString(errString, 128, 3);				GetIndString(helpString, 128, 4);				DisplayError(-108, errString, helpString, StopError);				ExitToShell;			end;		AlbumBounds := MainPtr^.PortBits.Bounds;		SizeNeeded := longint(8 * PicSizeMax);		if longint((Memavail - SizeNeeded)) < SafetyValve then			begin    {MemoryMessage(4405, 'in setting up space for biomorph linked list', Verdict);  v1.1 changed to below}				GetIndString(errString, 128, 5);  {** v1.1 **}				GetIndString(helpString, 128, 4);				DisplayError(-108, errString, helpString, StopError);				ExitToShell;			end;		MyPic.BasePtr := NewPtr(longint(SizeNeeded));		if MemError <> noErr then			ExitToShell;		RootGod := GodHandle(NewHandle(SizeOf(God)));		if MemError <> noErr then			ExitToShell;		RootGod^^.Adam := nil;		RootGod^^.NextGod := nil;		RootGod^^.PreviousGod := nil;		ThatFull := Created;		SizeOfPerson := SizeOf(Person);  {v1.1 Saves calculating it before every save to file}		ToldToStop := False;		MaxPages := 4;    {v1.1 was 1, but in turbo was a constant set to 4}		j := 0;		repeat			MakeOffScreen(AlbumBounds, AlbumBitMap[j], burst);			if burst then				begin					MaxPages := j - 1;					NumToString(MaxPages, errString);					if MaxPages >= 1 then						begin							MemoryMessage(27291, errString, Verdict);						end					else						begin							GetIndString(errString, 128, 20);  {** v1.1 **}							GetIndString(helpString, 128, 4);							DisplayError(-108, errString, helpString, StopError);							ExitToShell;        {MemoryMessage(4405, 'No room for Bitmap screens', Verdict)}						end;				end			else				j := j + 1;			ToldToStop := burst or (j > 4)		until ToldToStop;		if MaxPages < 1 then			ExitToShell;		ScreenArea := screenBits.Bounds;  { get size of screen (don't assume) }		with ScreenArea do			begin				SetRect(DragArea, 20, 20, Right - 5, Bottom - 10);   { set drag region       }				SetRect(GrowArea, 50, 20, Right - 5, Bottom - 10);   { set grow region       }    {MoveWindow(MainPtr,Left+1,Top+36,TRUE);}    {    SizeWindow(MainPtr,Right-1,bottom-36,TRUE);}			end;  { set up menus }		MenuList[AM] := GetMenu(ApplMenu);{ read menus in from resource fork  }		MenuList[FM] := GetMenu(FileMenu);		MenuList[EM] := GetMenu(EditMenu);		MenuList[OM] := GetMenu(OperMenu);		MenuList[BM] := GetMenu(BoxMenu);		MenuList[MM] := GetMenu(MutationMenu);		MenuList[PM] := GetMenu(PedigreeMenu);		MenuList[HM] := GetMenu(HelpMenu);		SpecialBreedMenu := GetMenu(SpecMenu);		AddResMenu(MenuList[AM], 'DRVR');  { pull in all desk accessories      }		LargeMenus;		NRows := 3;		Ncols := 5;		NBoxes := 15;		BreedNBoxes := 15;		AlbumNRows := NRows;		AlbumNCols := NCols;		BreedNRows := 3;		BreedNCols := 5;		FossilCounter := 0;		TheMode := Preliminary;		SetUpBoxes;		Page := 1;		BoxNo := 1;		Morph := 1;		Prect := MainPtr^.portRect;  (*SetPortBits (MainPtr^.portbits); needed here? *)		CopyBits(MainPtr^.PortBits, AlbumBitMap[Page], PRect, PRect, srcCopy, nil);  { program-specific initialization }  {Close(Slides);}		Finished := False;                 { set program terminator to false   }		for j := 6 to 7 do			Mut[j] := False;		Mut[8] := True;		Mut[9] := True;		for j := 1 to 5 do			Mut[j] := True;        {** changed 1.1 **}		for j := 1 to MutTypeNo do			CheckItem(MenuList[MM], j, Mut[j]);		for j := 1 to 6 do			SetItemState(EM, j, False);		TextSize(9);		TextFace([]);		Album.size := 0;		OldSpecial := 0;		Special := 0;		ShowPen;		TheMode := Preliminary;		SetUpBoxes; {Needed only to define MidBox. Doesn't show because not breeding}		{DelayedDrawing := False; ABC}		OldBox := 0;		for j := 1 to 4 do			SetItemState(BM, j, True);		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		for j := 1 to MaxPages do			PBoxNo[j] := 0;		CurrentPage := 1;		Page := 1;		LastPutFileName := '';		LastGetFileName := '';		aTime := TickCount;		repeat			j := random		until Tickcount > aTime + 50;  {GetDateTime(RandSeed);}		SomethingToRestore := False;		Region2 := NewRgn;		DestRegion := NewRgn;		SaveRegion := NewRgn;		Rays := 1;		OldSpecialFull := nil;		SpecialFull := nil;		CheckItem(MenuList[PM], 4, True);		CheckItem(MenuList[PM], 5, False);		CheckItem(MenuList[PM], 6, False);		with MidScreen do			begin				h := PRect.Left + (Prect.right - Prect.left) div 2;				v := PRect.Top + (PRect.Bottom - PRect.Top) div 2;			end;		MyPenSize := 1;  {PrDrvrOpen;}		SweepOn := False;		hideInBackGround := False;  {by default, we leave windows alone. Under System 6 this might make disks unaccessable}		AlbumChanged := False;		Danger := False;		GetIndString(AsymString, 12947, 1);		GetIndString(BilatString, 12947, 2);		GetIndString(SingleString, 12947, 3);		GetIndString(UpDnString, 12947, 4);		GetIndString(RadialString, 12947, 5);		SetItemState(EM, 5, False);		Zoomed := False;		OldMode := Breeding;		ClipBoarding := False;		Naive := True;		WarningHasBeenGiven := False;  {S := SizeOf(person);}	end; { of proc Initialize }end.