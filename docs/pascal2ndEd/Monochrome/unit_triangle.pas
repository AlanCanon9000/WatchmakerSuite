unit unit_triangle;interface	uses{$IFC UNDEFINED THINK_Pascal}		think_pascal, Memory, Quickdraw, TextUtils, Types,  {$ENDC}		unit_globals, unit_biomorphs, unit_miscellaneous, unit_error;	procedure AtLeast (var OutRect: Rect);	procedure OwnCursor (theRect: Rect; fromBitMap: BitMap; var theCursor: Cursor);	procedure MainTriangle;	procedure PlotTriangle (MLoc: point; Localswitch: Boolean);	procedure FlickerTriangle (MLoc: Point);implementation{$IFC UNDEFINED THINK_Pascal}	uses		SegLoad, ToolUtils;{$ENDC}	procedure Triangle (var r1, r2, r3: real; b: point; m: point);		var			x, y, k: real;			screenheight: LONGINT;	begin		screenheight := screenbits.bounds.bottom - screenbits.bounds.top;		k := round(200 * screenheight / 340);		x := m.h - b.h;		y := (screenheight - m.v) - (screenheight - b.v);		r1 := y / k;		r3 := (x - y / 2) / k;		r2 := (k - x - y / 2) / k;	end; {triangle}	procedure DrawTriangle (a, b, c: point);	begin		Moveto(a.h, a.v);		LineTo(b.h, b.v);		LineTo(c.h, c.v);		LineTo(a.h, a.v);	end; {drawtriangle}	procedure Concoct (r1, r2, r3: real; a, b, c: person; var new: person);		var			j, weight: Integer;		function Force3 (r: real): Integer;			var				i: Integer;		begin			i := round(r);			if i > 2 then				i := 2;			if i < 0 then				i := 0;			Force3 := i		end; {Force3}		function Force2 (r: real): Integer;			var				i: Integer;		begin			i := round(r);			if i > 1 then				i := 1;			if i < 0 then				i := 0;			Force2 := i		end; {Force2}	begin		with new do			begin				SegNoGene := round(r1 * a.SegNoGene + r2 * b.SegNoGene + r3 * c.SegNoGene);				if SegNoGene < 1 then					SegNoGene := 1;				SegDistGene := round(r1 * a.SegDistGene + r2 * b.SegDistGene + r3 * c.SegDistGene);				CompletenessGene := CompletenessType(Force2(r1 * Integer(a.CompletenessGene) + r2 * Integer(b.CompletenessGene) + r3 * Integer(c.CompletenessGene)));				SpokesGene := SpokesType(Force3(r1 * Integer(a.SpokesGene) + r2 * Integer(b.SpokesGene) + r3 * Integer(c.SpokesGene)));				for j := 1 to 9 do					gene[j] := round(r1 * a.gene[j] + r2 * b.gene[j] + r3 * c.gene[j]);				SizeWorry := SegNoGene * TwoToThe(gene[9]);				if SizeWorry > WorryMax then					Gene[9] := Gene[9] - 1;				if gene[9] < 1 then					gene[9] := 1;				tricklegene := round(r1 * a.tricklegene + r2 * b.tricklegene + r3 * c.tricklegene);				MutSizeGene := round(r1 * a.MutSizeGene + r2 * b.MutSizeGene + r3 * c.MutSizeGene);				MutProbGene := round(r1 * a.MutProbGene + r2 * b.MutProbGene + r3 * c.MutProbGene);				if mutprobgene < 1 then					mutprobgene := 1;				if mutprobgene > 100 then					mutprobgene := 100;				for j := 1 to 10 do					dgene[j] := swelltype(Force3(r1 * Integer(a.dgene[j]) + r2 * Integer(b.dgene[j]) + r3 * Integer(c.dgene[j])));			end	end; {concoct}	procedure PlotTriangle (MLoc: point; Localswitch: Boolean);		var			margcentre, offset: Integer;			OffCentre: Point;	begin		if LocalSwitch then			GlobalToLocal(Mloc);		triangle(r1, r2, r3, b, MLoc);		concoct(r1, r2, r3, topan, leftan, rightan, child[special]);		develop(child[special], Mloc, true);		with margin do			margcentre := top + (bottom - top) div 2;		offset := margcentre - MLoc.v;		with Margin do			begin				Top := Top - Offset;				Bottom := Bottom - Offset			end;		with OffCentre do			begin				h := MLoc.h;				v := MLoc.v - offset;			end;		grow(margin, 2);		EraseRect(margin);		FrameRect(margin);		DrawPic(MyPic, offcentre, child[special]);{MakeGeneBox(child[special]);}	end; {PlotTriangle}	procedure MainTriangle;		var			ScreenWidth, ScreenHeight: LONGINT;			Storeanimal: person;	begin		AlreadyTriangling := FALSE;		if special > 0 then			Storeanimal := child[special];		LastMouse.h := -1;		LastMouse.v := -1;		eraserect(Prect);		with Screenbits.Bounds do			begin				ScreenWidth := right - left;				ScreenHeight := bottom - top			end;		a.h := round(234 * ScreenWidth / 512);		a.v := round(51 * ScreenHeight / 342);		b.h := round(134 * ScreenWidth / 512);		b.v := round(250 * ScreenHeight / 342);		c.h := round(333 * ScreenWidth / 512);		c.v := round(250 * ScreenHeight / 342);		drawtriangle(a, b, c);		mous.v := 0;		mous.h := 0;		eraserect(Prect);		drawtriangle(a, b, c);		if special = 0 then			special := 1;		PlotTriangle(a, FALSE);		PlotTriangle(b, FALSE);		PlotTriangle(c, FALSE);		if special > 0 then			child[special] := storeanimal;	end; {maintriangle}	procedure OwnCursor (theRect: Rect; fromBitMap: BitMap; var theCursor: Cursor);		var			Box, SmallRect: Rect;			aBitMap: BitMap;			myBits16: Bits16;			SizeNeeded: LONGINT;			CanDo: Boolean;			errString, helpString: Str255;		function MakeBits16 (theBitMap: BitMap; var theBits16: Bits16): Boolean;			type				BitsPtr = ^Bits16;			var				thePtr: BitsPtr;				thebase: LONGINT;		begin			SizeNeeded := LONGINT(SizeOf(BitsPtr));			if (Memavail - SizeNeeded) < SafetyValve then				begin					GetIndString(errString, 128, 13);			{** v1.1 **}					GetIndString(helpString, 128, 14);					DisplayError(-108, errString, helpString, StopError);					ExitToShell;{was: MemoryMessage ( 4405 , ' in making Bits16' , Verdict ); exitToShell from proc}					MakeBits16 := FALSE				end			else				begin					thePtr := BitsPtr(NewPtr(SizeOf(BitsPtr)));					if MemError <> noErr then						ExitToShell;					thePtr := BitsPtr(theBitMap.BaseAddr);					theBits16 := thePtr^;					DisposPtr(Ptr(thePtr));					MakeBits16 := TRUE;				end; {TRUE condition}		end; {Make Bits16}		function BigEnough (var theRect: Rect): Boolean;			var				Width, Height: Integer;		begin			with theRect do				begin					Width := Right - Left;					Height := Bottom - Top;				end;			BigEnough := (Width > 16) and (Height > 16);		end; {LargerRect}	begin		SetRect(Box, 0, 0, 16, 16);		with theRect do			begin				left := left + 2;				right := right - 2;				top := top + 2;				bottom := bottom - 2			end;		aBitMap.rowBytes := 2;		aBitMap.bounds := box;		SizeNeeded := LONGINT(SizeOf(Bits16));		if (Memavail - SizeNeeded) < SafetyValve then			begin				GetIndString(errString, 128, 14);		{** v1.1 **}				GetIndString(helpString, 128, 4);				DisplayError(-108, errString, helpString, StopError);				ExitToShell;{was: MemoryMessage(4405, 'Canï¿½t make biomorphic cursor', Verdict);}				CanDo := FALSE;			end		else			begin				CanDo := TRUE;				aBitMap.baseAddr := NewPtr(SizeOf(Bits16));				if MemError <> noErr then					ExitToShell;     {No memory available}				CopyBits(fromBitMap, aBitMap, TheRect, box, srcCopy, nil);			end;		if CanDo and MakeBits16(aBitMap, MyBits16) and (BigEnough(theRect) or (theMode = Triangling)) then			begin				theCursor.data := MyBits16;				theCursor.mask := curslist[breedcursor]^^.mask;				theCursor.hotSpot.v := 8;				theCursor.hotSpot.h := 8;				DisposPtr(aBitMap.baseAddr);			end		else			theCursor := curslist[crosscursor]^^;	end; {OwnCursor}	function DivisibleByEight (n: Integer): Boolean;	begin		DivisibleByEight := 8 * (n div 8) = n	end;	procedure AtLeast (var OutRect: Rect);		var			width, height: Integer;	begin		InsetRect(OutRect, -3, -3);		with OutRect do			begin				while not (DivisibleByEight(left)) do					left := left - 1;				while not (DivisibleByEight(right)) do					right := right + 1			end	end;	procedure MakeNiceBox (Inbox: Rect; var outbox: Rect);		var			width, height, MidWidth, MidHeight, Widthbytes: Integer;	begin		OutBox := InBox;		with OutBox do			begin				height := bottom - top;{1+}				width := right - left;{1+}				if width < height then					width := height				else					height := width;    {WidthBytes:=width DIV 8;}{    WHILE odd(WidthBytes) DO WidthBytes:=WidthBytes+1;}{    Width:=WidthBytes*8;}				left := 8;				Right := left + Width;				Top := 8;				Bottom := Top + Height;				AtLeast(outbox);				right := right + 1;			end;	end; {MakeNiceBox}	procedure CursSnap (ThisPic: Pic; box: Rect; offset: Integer; biomorph: person);		var			Midpoint: Point;			NiceBox: Rect;			Offcentre: Point;			Centre: Integer;			SavePort: GrafPtr;			SaveBitMap: Bitmap;	begin {ClipRect(businessPart);}		GetPort(SavePort);		SaveBitMap := SavePort^.PortBits;		SetPortBits(AlbumBitMap[0]);		MakeNiceBox(box, NiceBox);		with NiceBox do			begin				MidPoint.v := top + (bottom - top) div 2;				MidPoint.h := left + (right - left) div 2;			end;		EraseRect(NiceBox); {offscreen}		Offcentre := MidPoint;		Offcentre.v := Offcentre.v - offset;		DrawPic(ThisPic, Offcentre, biomorph);		OwnCursor(Nicebox, AlbumBitMap[0], theCursor);		SetPort(SavePort);		SetPortBits(SaveBitMap);		ClipRect(MainPtr^.PortRect);	end; {CursSnap}	procedure FlickerTriangle (MLoc: Point);		var			infant: person;			margcentre, offset: Integer;	begin		triangle(r1, r2, r3, b, MLoc);		concoct(r1, r2, r3, topan, leftan, rightan, infant);		if theMode <> triangling then			begin				if infant.gene[9] > 6 then					infant.gene[9] := 6;				if infant.SegNoGene > 2 then					infant.SegNoGene := 2;			end;		{DelayedDrawing := TRUE; }		Develop(infant, MLoc, true);    {At this point Margin really does correctly frame the biomorph}		with margin do			margcentre := top + (bottom - top) div 2;		offset := margcentre - MLoc.v;		CursSnap(MyPic, Margin, offset, infant);	end; {FlickerTriangle}end.