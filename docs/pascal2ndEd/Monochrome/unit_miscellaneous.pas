unit unit_miscellaneous;{******************************************************}{*												v1.1 Sept 1993														 *}{*																															 *}{*		Changed Message procs to use Alerts																 *}{*		Removed PictMessage (never called), change Message calls to DisplayError	 *}{*		Added positioning to alerts and dialogs															 *}{*		Alert now uses STR# for closing, quitting, etc		  										 *}{*		Added several functions, for EOF and checking system (see below)					 *}{*     Validated the rect after RestoreOffscreen to prevent drawing twice				 *}{******************************************************}interface	uses {$IFC UNDEFINED THINK_Pascal}		think_pascal, OSUtils, Resources, Quickdraw, Types, {$ENDC}		unit_globals;	function FossilsExist: Boolean;	procedure DireMessage (string1ID, string2ID: Integer; var Verdict: Integer; YesNo: Boolean);	procedure MemoryMessage (ID: Integer; InMessage: Str255; var Verdict: Integer); { 27291 for Fewer album screens, 27295 for Careful}	procedure SimpleMessage (ID: Integer; var Verdict: Integer);	procedure HelpMessage (StrID: Integer);	procedure SyringeMessage;	procedure Pause (Message: Str255);	procedure SetItemState (Mndx, Indx: Integer; Flag: Boolean);	function RandInt (Max: Integer): Integer;	function Odd (i: Integer): Boolean;	function RandSwell (Indgene: Swelltype): SwellType;	procedure EraseInnerRect (box: Rect);	procedure FrameOuterRect (box: Rect);	procedure FrameInnerRect (box: Rect);	procedure StoreOffScreen (box: Rect; var Snapshot: BitMap);	procedure RestoreOffScreen (box: Rect; Snapshot: BitMap);	procedure CleanUp;	procedure MakeOffScreen (box: Rect; var Snapshot: BitMap; var Burst: Boolean);	procedure DrawInt (i: Integer);{PROCEDURE Drawi (i: Integer);}{Unimplemented ABC}	procedure Grow (var Box: Rect; d: Integer);	procedure BoxesOnly;	procedure OwnEditMenu;	function DawkFilter (param: ParmBlkPtr): Boolean;	procedure SmallMenus;	procedure LargeMenus;	procedure BigFuncBox (Box: Rect; var Outbox: Rect);	procedure SmallFuncBox (Box: Rect; var Outbox: Rect; BoxSize: Integer);	procedure FuncBox (Box: Rect; var Outbox: Rect; BoxSize: Integer);	procedure Poop (n: Integer);	procedure StartDocuments (DocumentCount: Integer);	function TwoToThe (n: integer): integer;{*****  Procedures added for v1.1 ********}										{ Operating System utilities }	function TrapAvailable (theTrap: LONGINT): Boolean;	function WNEIsImplemented: Boolean;	function TempMemCallsAvailable: Boolean;	procedure DeleteOldFile (volRefNum: Integer; dirID: LongInt; fileName: Str255);										{ Dialog Manager utilities		}	procedure PositionDialog (theType: ResType; theID: integer);	procedure FindDlogPosition (theType: ResType; theID: integer; var corner: Point);	function IsEOF (refNum: Integer; howClose: LongInt): Boolean;	function FileSize (refNum: Integer): LongInt;		{returns the number of bytes in the file. Same as}{	the toolbox function GetEOF, except this returns the size instead of an error code. It has this name to emulate the }{   Turbo routine, except this returns bytes (since we don't use pascal type-files now).}implementation	uses {$IFC UNDEFINED THINK_Pascal}		Dialogs, Events, Files, Memory, Menus, QuickdrawText, SegLoad, SysEqu, TextUtils, ToolUtils, Windows, {$ENDC}		Traps, Script;{*	Operating System utilities	*}	function TwoToThe (n: integer): integer;		var			t: integer;	begin		case n of			0: 				t := 1;			1: 				t := 2;			2: 				t := 4;			3: 				t := 8;			4: 				t := 16;			5: 				t := 32;			6: 				t := 64;			7: 				t := 128;			8: 				t := 256;			9: 				t := 512;			10: 				t := 1024;			11: 				t := 2048;			12: 				t := 4096;			otherwise				t := 8192		end; {cases}		TwoToThe := t	end; {TwoToThe}{****************************************************}{ TrapAvailable}{}{ 	Check whether a certain trap exists on this machine.  }{ this function uses the new approved method as per IM-VI}{	p. 3-8												}{}{****************************************************}	function TrapAvailable (theTrap: LONGINT): Boolean;		var			tType: TrapType;			numToolBoxTraps: Integer;	begin 		(* first determine the trap type *)		if BAND(theTrap, $0800) > 0 then			tType := ToolTrap		else			tType := OSTrap; 		(* next find out how may traps there are *)		if NGetTrapAddress(_InitGraf, ToolTrap) = NGetTrapAddress($AA6E, ToolTrap) then			numToolBoxTraps := $200		else			numToolBoxTraps := $400; 		(* check if trap number is too big for current trap table *)		if tType = ToolTrap then			begin				theTrap := BAND(theTrap, $07FF);				if theTrap >= numToolBoxTraps then					theTrap := _Unimplemented;			end; 		(* the trap is implemented if its address is different 	*) 		(* from the unimplemented trap's address				*)		TrapAvailable := NGetTrapAddress(theTrap, tType) <> NGetTrapAddress(_Unimplemented, ToolTrap);	end;{****************************************************}{ WNEIsImplemented}{}{ 	See if WaitNextEvent is implemented }{}{****************************************************}	function WNEIsImplemented: Boolean;		const			_WaitNextEvent = $A860;					{ WaitNextEvent trap					}		var			theWorld: SysEnvRec;						{ System environment				}			errCode: OSErr;	begin		errCode := SysEnvirons(1, theWorld);		{ Check environment					}		if theWorld.machineType < 0 then 			{ Old ROMs, definitely not present	}			WNEIsImplemented := FALSE		else											{ Check for WNE trap					}			WNEIsImplemented := TrapAvailable(_WaitNextEvent)	end;{****************************************************}{ TempMemCallsAvailable}{}{ 	Check whether the MultiFinder temporary memory calls are available}{}{****************************************************}	function TempMemCallsAvailable: Boolean;		const			_OSDispatch = $A88F;						{ Temporary MF memory calls		}	begin						{ Check for the OSDispatch trap	}		TempMemCallsAvailable := TrapAvailable(_OSDispatch);	end;{*	Dialog Manager utilities	*}{****************************************************}{ PositionDialog}{}{		Center the bounding box of a dialog or alert in the upper third}{		of the screen.  This is the preferred location according to the}{		Human Interface Guidelines.}{}{****************************************************}	procedure PositionDialog (theType: ResType; theID: integer);		var			theRect: Rect;			theRectPtr: RectPtr;		{ Ptr to bounding box of dialog	}			theTemplate: Handle;		{ Handle to resource template	}			left,							{ Left side of centered rect		}			top: integer;				{ Top side of centered rect		}	begin		{ The first field of the resource template for DLOG's and ALRT's 	}		{ is its bounding box.  Get a pointer to this rectangle.  This   			}		{ handle dereferencing is safe since the remaining statements in 	}		{ this function do not move memory (assignment and simple math). 	}		theTemplate := GetResource(theType, theID);		if resError <> noErr then			Exit(PositionDialog);	{If we fail to load it, forget about positioning}		theRectPtr := RectPtr(theTemplate^);		theRect := theRectPtr^;		if (theRect.left >= theRect.right) or (theRect.top >= theRect.bottom) then			Exit(PositionDialog); {Position Dialog is creating problems that I don't understand.  RD}{e.g. theRect can have a left bigger than its right}		{ Center horizontally on screen	}		left := (screenBits.bounds.right - (theRect.right - theRect.left)) div 2;		{ Leave twice as much space as above	 }		top := (screenBits.bounds.bottom - (theRect.bottom - theRect.top)) div 3;		{ Don't put rect under menu bar	}		if top < GetMBarHeight + 7 then			top := GetMBarHeight + 7;		theRect.right := theRect.right + left - theRect.left;		theRect.left := left;		theRect.bottom := theRect.bottom + top - theRect.top;		theRect.top := top;		theRectPtr^ := theRect;	end;{****************************************************}{ FindDLOGPosition}{}{ 		Return the coordinates of the top left corner of a dialog or alert}{ 		which centers the box in the upper third of the main screen. This is}{ 		the preferred location according to the Human Interface Guidelines.}{}{****************************************************}	procedure FindDlogPosition (theType: ResType; theID: integer; var corner: Point);		type			RectPtr = ^Rect;			RectHandle = ^RectPtr;		var			theRect: Rect;		{ Bounding box of dialog				}			left, top: integer;	{ Left, top side of centered rect		}	begin		{ The first field of the resource template for DLOG's and ALRT's 	}		{ is its bounding box.  Access this rectangle.  This   					}		{ handle dereferencing is safe since the remaining statements in 	}		{ this function do not move memory (assignment and simple math). 	}		theRect := RectHandle(GetResource(theType, theID))^^;		{ Center horizontally on screen	}		corner.h := (screenBits.bounds.right - (theRect.right - theRect.left)) div 2;		{ Leave twice as much space as above	 }		corner.v := (screenBits.bounds.bottom - (theRect.bottom - theRect.top)) div 3;		{ Don't put rect under menu bar	}		if corner.v < GetMBarHeight + 7 then			corner.v := GetMBarHeight + 7;	end;	procedure DeleteOldFile (volRefNum: Integer; dirID: LongInt; fileName: Str255);{If there was a crash, the fossil file may be present but busy. We need to convince the }{finder that it is okay to delete it}		var			info: CInfoPBRec;			info2: ParamBlockRec;			err: OSErr;	begin		with info do			begin				ioCompletion := nil;				ioNamePtr := @fileName;				ioDirID := dirID;				ioVRefNum := volRefNum;				ioFDirIndex := 0;				err := PBGetCatInfo(@info, FALSE);				if err = noErr then		{if it exists}					begin						if ioFRefNum <> 0 then   {File has been left open}							begin								info2.ioCompletion := nil;								info2.ioRefNum := ioFRefNum;								err := PBClose(@info2, FALSE);							end;						err := HDelete(volRefNum, dirID, fileName);					end;{if}			end;{with}	end;{DeleteOldFile}	function IsEOF (refNum: Integer; howClose: LongInt): Boolean;{Acts like Pascal's eof() function, but in addition you can specify how close to the end of the file}{you are allowed to be (takes care of truncated files)}		var			err: OSErr;			eof, positionNow: LongInt;	begin		IsEOF := TRUE;		err := GetFPos(refNum, positionNow);		err := GetEOF(refNum, eof);		if err <> noErr then			Exit(IsEOF);		{If something went wrong, we should stop reading}		IsEOF := (eof - positionNow) < howClose	end;	function FileSize (refNum: Integer): LongInt;		var			err: OSErr;			numBytes: LongInt;	begin		err := GetEOF(refnum, numBytes);		if err <> noErr then			numBytes := 0;	{Problem with the file, should signal an exception here.}		FileSize := numBytes;	end;{***** End of v1.1 additions*****}	function FossilsExist: Boolean;{replace, but not precisely mimic, Turbo's built-in function}		var			Err: OSErr;			filePos: LongInt;	begin		Err := GetFPos(slides, FilePos);		FossilsExist := FilePos > 0	end; {FossilsExist}	procedure DireMessage (string1ID, string2ID: Integer; var Verdict: Integer; YesNo: Boolean);{v1.1 changed DLOGs to ALRTs.}{}		var			theItem: Integer;			MessagePtr: DialogPtr;			string1, string2: Str255;	begin		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		GetIndString(string1, kAlertStringsID, string1ID);		GetIndString(string2, kAlertStringsID, string2ID);		ParamText(string1, string2, '', '');		if YesNo then			begin				if gSystem.systemVersion < $0700 then		{added v1.1}					PositionDialog('ALRT', 151);					{Save changes alert. YesNo?}				theItem := CautionAlert(151, nil);			end		else			begin				if gSystem.systemVersion < $0700 then		{added v1.1}					PositionDialog('ALRT', 17089);				theItem := CautionAlert(17089, nil);			end; { get dialog box}		Verdict := theItem;		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		FlushEvents(EveryEvent, 0);		ValidRect(Prect);	end; { of proc DireMessage }	procedure MemoryMessage (ID: Integer; InMessage: Str255; var Verdict: Integer); {27291 for Fewer album screens, 27295 for Careful}{*** Change this to handle appropriate type alerts with strings from STR# ***}{ v1.1 changed to alerts, position correctly on screen,}{ ID 4405 (got to quit) message changed to DisplayError call}		var			theItem: Integer;			MessagePtr: DialogPtr;	begin		SetCursor(CursList[CrossCursor]^^);		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		if (ID = 27295) then			InMessage := '';		ParamText('', InMessage, '', '');		if gSystem.systemVersion < $0700 then		{added v1.1}			PositionDialog('ALRT', ID);		theItem := CautionAlert(ID, nil);		Verdict := theItem;		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		FlushEvents(EveryEvent, 0);		ValidRect(Prect);	end; {MemoryMessage}	procedure SimpleMessage (ID: Integer; var Verdict: Integer);{v1.1 redesigned the alert slightly and made it a Caution Alert. This procedure}{seems to be always called with the same string ID. If more are added, the alert}{may need to be made less specific}		var			S: Stringhandle;	begin		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		S := GetString(ID);		ParamText(S^^, '', '', '');		if gSystem.systemVersion < $0700 then		{added v1.1}			PositionDialog('ALRT', 17089);		verdict := CautionAlert(17089, nil);	{changed v1.1}		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		FlushEvents(EveryEvent, 0);		ValidRect(Prect);	end; {SimpleMessage}	procedure HelpMessage (StrID: Integer);		var			HelpPtr: dialogPtr;			theItem, v: Integer;			S1, S2, S3, S4: Str255;	begin		GetIndString(S1, StrID, 1);		GetIndString(S2, StrID, 2);		GetIndString(S3, StrID, 3);		GetIndString(S4, StrID, 4);		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		ParamText(S1, S2, S3, S4);		if gSystem.systemVersion < $0700 then		{added v1.1}			PositionDialog('DLOG', 2000);		HelpPtr := GetNewDialog(2000, nil, Pointer(-1));		ModalDialog(nil, theItem);             { put dialog box up; get result }		DisposDialog(HelpPtr);               { get rid of dialog box         }  {ReStoreOffScreen(MainPtr^.PortRect,MyBitMap);}		FlushEvents(EveryEvent, 0);		ValidRect(Prect);	end; { of proc HelpMessage }	procedure SyringeMessage;{v1.1 Changed to alert, and set the first two alert stages to simple beeps}		var			SyrPtr: dialogPtr;			theItem: Integer;	begin		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		if gSystem.systemVersion < $0700 then		{added v1.1}			PositionDialog('ALRT', 30130);		theItem := Alert(30130, nil);		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		FlushEvents(EveryEvent, 0);		ValidRect(Prect);	end; { of proc SyringeMessage }	procedure Pause (Message: Str255);	begin		if Button then			repeat			until not Button; {Gotoxy(5,5); Writeln(message);}		repeat		until Button	end;	procedure SetItemState (Mndx, Indx: Integer; Flag: Boolean);{}{    purpose         if true, enables item Indx of menu Mndx; else disables}{    last update     22 Aug 86}{}	begin		if Flag then			EnableItem(MenuList[Mndx], Indx)		else			DisableItem(MenuList[Mndx], Indx)	end; { of proc SetItemState }	function RandInt (Max: Integer): Integer;	begin		randint := 1 + (abs(random) mod max);	end; {randint}	function Odd (i: Integer): Boolean;	begin		Odd := 2 * (i div 2) <> i	end;	function RandSwell (Indgene: Swelltype): SwellType;		var			r: 1..3;	begin		case Indgene of			Shrink: 				Randswell := Same;			Same: 				if randint(2) = 1 then					Randswell := Shrink				else					Randswell := Swell;			Swell: 				RandSwell := Same		end {Cases}	end; {RandSwell}	procedure EraseInnerRect (box: Rect);		var			InnerRect: Rect;	begin		with InnerRect do			begin				left := box.left + 1;				right := box.right - 1;				top := box.top + 1;				bottom := box.bottom - 1			end;		EraseRect(InnerRect)	end; {EraseInnerRect}	procedure FrameOuterRect (box: Rect);		var			OuterRect: Rect;	begin		with OuterRect do			begin				left := box.left - 1;				right := box.right + 1;				top := box.top - 1;				bottom := box.bottom + 1			end;		FrameRect(OuterRect)	end; {FrameOuterRect}	procedure FrameInnerRect (box: Rect);		var			InnerRect: Rect;	begin		with InnerRect do			begin				left := box.left + 1;				right := box.right - 1;				top := box.top + 1;				bottom := box.bottom - 1			end;		FrameRect(InnerRect)	end; {FrameInnerRect}	procedure StoreOffScreen (box: Rect; var Snapshot: BitMap);	begin		if FrontWindow = MainPtr then			CopyBits(MainPtr^.PortBits, Snapshot, box, box, srcCopy, nil);	end; {StoreOffScreen}	procedure RestoreOffScreen (box: Rect; Snapshot: BitMap);	begin {IF FrontWindow=MainPtr THEN}		CopyBits(Snapshot, MainPtr^.PortBits, box, box, srcCopy, nil);		ValidRect(box);			{**v1.1 since we have redrawn it already, }{we can stop the update event which would cause the window to be redrawn twice}	end; {RestoreOffScreen}	procedure CleanUp;{}{    purpose         to do whatever's needed before returning to Finder}{}		var			err: OSErr;	begin		err := FSClose(Slides);		err := HDelete(volRefNum, dirID, fileName);	end; { of proc CleanUp }	procedure MakeOffScreen (box: Rect; var Snapshot: BitMap; var Burst: Boolean);{From system 6 onwards we can use GWorlds instead of writing our own here - Alun}		var			bitsRowBytes, height: Integer;			ZeroRect: Rect;			tempPtr: Ptr;			SizeNeeded: LONGINT;	begin		with box do			begin				height := bottom - top;				bitsRowBytes := (((right - left - 1) div 16) + 1) * 2;			end;		with ZeroRect do			begin				left := 0;				right := box.right - box.left;				top := 0;				bottom := height			end;		SizeNeeded := LONGINT(bitsRowBytes) * LONGINT(height);		if (Memavail - SizeNeeded) < SafetyValve then			Burst := TRUE		else			begin				tempPtr := NewPtr(SizeNeeded);				if MemError <> noErr then					begin						Sysbeep(1);						ExitToShell;					end;   {No memory available}				Snapshot.baseaddr := tempPtr;				Snapshot.bounds := zerorect;				Snapshot.rowBytes := bitsRowBytes;				Burst := FALSE;			end;	end;{MakeOffScreen}	procedure DrawInt (i: Integer);		procedure Drawi (i: Integer);			var				l, r: Integer;		begin			if i <= 9 then				drawchar(chr(ord('0') + i))			else				begin					l := i div 10;					r := i - 10 * l;					drawi(l);					drawi(r);				end;		end; {drawi}	begin {drawint proper}		if i < 0 then			begin				drawchar('-');				i := abs(i);			end		else			Drawchar('+');		drawi(i);	end; {drawint}	procedure Grow (var Box: Rect; d: Integer);	begin		with box do			begin				left := left - d;				right := right + d;				top := top - d;				bottom := bottom + d;			end;	end; {grow}	procedure BoxesOnly;		var			j: Integer;	begin		for j := 1 to NBoxes do			FrameRect(box[j]);		theMode := preliminary;	end; {BoxesOnly}{PROCEDURE DrawNum(n:Integer);}{VAR s,c:CHAR;}{BEGIN IF n<0 THEN s:='-' ELSE s:='+';}{n:=abs(n); c:=chr(n+48);}{DrawChar(s); DrawChar(c)}{END} {DrawNum;} {This is where frillsegment used to begin}	procedure OwnEditMenu;	begin		SetItemState(EM, 1, FALSE);		SetItemState(EM, 2, FALSE);		SetItemState(EM, 3, FALSE);		SetItemState(EM, 4, (Special > 0) and ((TheMode = Highlighting) or (TheMode = Albuming)));		SetItemState(EM, 5, FALSE);		SetItemState(EM, 6, FALSE);	end; {OwnEditMenu}	function DawkFilter (param: ParmBlkPtr): Boolean;		var			Wanted: Boolean;	begin		Wanted := (param^.ioFlFndrInfo.fdCreator = 'DAWK') and (param^.ioFlFndrInfo.fdType <> 'APPL') and (param^.ioFlFndrInfo.fdType <> 'BIOC') and (param^.ioFlFndrInfo.fdType <> 'FOSS');		DawkFilter := not Wanted	end;	procedure SmallMenus;		var			Indx: Integer;	begin		ClearMenuBar;		InsertMenu(MenuList[AM], 0);			 {This was commented out - Alun}		InsertMenu(SpecialBreedMenu, 0);		InsertMenu(MenuList[HM], 0);		DrawMenuBar;                   { draw updated menu bar to screen   }	end; {SmallMenus}	procedure LargeMenus;		var			indx: Integer;	begin		ClearMenuBar;		for Indx := 1 to MenuCnt do       { place menus in menu bar           }			InsertMenu(MenuList[Indx], 0);		OwnEditMenu;		DrawMenuBar;                   { draw updated menu bar to screen   }	end; {LargeMenus}	procedure BigFuncBox (Box: Rect; var Outbox: Rect);	begin		Outbox := box;		with Box do			begin				if Bottom - Top > Right - Left then					begin						Outbox.right := (Right + Left + Bottom - Top) div 2;						Outbox.left := outbox.right - (bottom - top)					end				else					begin						Outbox.bottom := (Top + Bottom + Right - Left) div 2;						Outbox.Top := Outbox.bottom - (right - left)					end			end;	end; {FuncBox}	procedure SmallFuncBox (Box: Rect; var Outbox: Rect; BoxSize: Integer);	begin		Outbox := box;		with Box do			begin				Outbox.Right := (Left + Right + BoxSize) div 2;				Outbox.left := Outbox.right - BoxSize;				Outbox.bottom := (top + bottom + Boxsize) div 2;				Outbox.top := Outbox.bottom - Boxsize			end;	end; {SmallFuncBox}	procedure FuncBox (Box: Rect; var Outbox: Rect; BoxSize: Integer);	begin		with Box do			if ((Right - Left) > BoxSize) or ((Bottom - Top) > Boxsize) then				BigFuncBox(Box, Outbox)			else				SmallFuncBox(Box, Outbox, Boxsize);		with Outbox do			begin				right := right + 1;				bottom := bottom + 1;			end;	end;	procedure Poop (n: Integer);		var			j: Integer;	begin {FOR j:=1 TO N DO Sysbeep(1)}	end; {poop}	procedure StartDocuments (DocumentCount: Integer);{v1.1 The original procedure would fail if you double click on a colour biomorph file,}{because those files have the same creator signiture but different file formats.}{Added check of file format - Alun}		var			j, k, volume, PersFile: Integer;			theFile: AppFile;			errorCode: OSErr;			dirID, procID, bytesToRead: LongInt;	begin		j := 0;		for k := 1 to DocumentCount do			begin				GetAppFiles(k, theFile);				with theFile do					if (fType = 'APPL') | not ((fType = 'COLL') | (fType = 'BIOM') | (fType = 'FOSS')) then							{v1.1 added last three type tests}						SysBeep(1)					else						begin							errorCode := GetWDInfo(vRefNum, volume, dirID, procID);							errorCode := HOpen(volume, dirID, fName, fsRdPerm, persFile);							if errorCode <> noErr then								SysBeep(1)							else								begin									while not ((IsEOF(PersFile, SizeOfPerson)) or (j >= MaxAlbum)) do										begin											j := succ(j);											bytesToRead := SizeOfPerson;											errorCode := FSRead(persFile, bytesToRead, @ThisMenagerie.Member[j]);											if errorCode <> noErr then												j := j - 1;										end;									errorCode := FSClose(PersFile)								end						end			end;		ThisMenagerie.Size := j;	end; {StartDocuments}{   *********   event handling routines   *********** }end.