unit unit_user_interface;{******************************************************************}{*															v1.1 Sept 1993.																	*}{* 	Added Suspend/Resume events																									*}{*		Added command key handling																										*}{*		Split activate/deactivate event handling																					*}{*		New menu item -> hide windows in background																			*}{*		Save screen if hiding windows, otherwise don't - speed up context switching								*}{*		Enabled desk accessories																											*}{*		Added bad disk handling																												*}{*		Split up HandleMenu proc into several procedures - one per menu 												*}{*		Added named constants for menu items (so ordinary mortals like me can read this!)					*}{*		All file operations converted to Mac file manager calls																*}{*		DLOGs for DireMessages changed to Alerts, conforming to Apple's HIG										*}{*		Removed Repeat/Until loops around save changes alerts																*}{*		Removed many unused variables, and restricted USE of other units											*}{*		Added auto positioning of dialogs and alerts under System 6 (urgh). Added auto position to			*}{*				resources for System 7																									*}{*		Saving files in same folder as file with same name now removes old file, even if open (not			*}{*				sure of the wisdom of this, though)																					*}{*																																						*}{--------------------------------------------------------------------------------------------}{*																	TO DO																			*}{*		Check out other dialogs, some of them should be alerts	(done)													*}{*		Offscreen bitmaps:																													*}{*			1) Save only rect of dialog or alert																						*}{*			2) Don't save screen before switching out (makes response sluggish - Apple says don't do it)	*}{*			3) Change DoUpdate so that it draws normally if no offscreen saved										*}{*			4) Remove spurious calls to StoreOffScreen																			*}{*			5) Disentangle activate and update event handling																	*}{*		Restrict window size, and allow users to change size. Option: leave space for disk icons				*}{*		Add support for a least the required set of Apple Events 															*}{*																																						*}{******************************************************************}interface	uses{$IFC UNDEFINED THINK_Pascal}		Events, {$ENDC}		unit_globals, unit_album, unit_miscellaneous, unit_engineering, unit_biomorphs, unit_pedigree, unit_triangle;	procedure HandleEvent (theEvent: EventRecord);implementation{$IFC UNDEFINED THINK_Pascal}	uses		Desk, Dialogs, DiskInit, Controls, Files, Fonts, Menus, OSUtils, Quickdraw, ToolUtils, Types, Windows;{$ENDC}	procedure DoAbout;{}{    Purpose         bring up 'About...' box using a dialog box}{}		var			theItem: Integer;			AboutPtr: DialogPtr;	begin		if frontwindow = mainptr then			Storeoffscreen(MainPtr^.PortRect, MyBitMap);		SetCursor(CursList[CrossCursor]^^);      				{set to my cursor}  {ShowCursor; }                          { and turn it back on           }		if gSystem.systemVersion < $0700 then			PositionDialog('DLOG', 11271);		AboutPtr := GetNewDialog(11271, nil, Pointer(-1));    	{get dialog box}		ModalDialog(nil, theItem);             					{put dialog box up; get result }		DisposDialog(AboutPtr);               						{get rid of dialog box }		SetCursor(Arrow);	end; { of proc DoAbout }	procedure ToggleFlag (var Flag: Boolean; Mndx, Indx: Integer);{}{    purpose         checks or de-checks item Indx in menu Mndx}{    last update     20 Aug 86}{}		var			Ch: Char;	begin		Flag := not Flag;                     { toggle flag (for you)         }		if Flag then                               { if flag is True...            }			Ch := Chr(CheckMark)           {   then check item in menu     }		else			Ch := Chr(NoMark);             {   else clear any checkmark    }		SetItemMark(MenuList[Mndx], Indx, Ch)   { put char by item in menu      }	end; { of proc ToggleFlag }	procedure EnableMenus;		var			i: Integer;	begin		for i := 1 to MenuCnt do			EnableItem(MenuList[i], 0);		OwnEditMenu;		DrawMenuBar;	end;	procedure DisableMenus;		var			i: Integer;	begin		for i := 2 to MenuCnt do			DisableItem(MenuList[i], 0);		EnableItem(MenuList[3], 0);		for i := 1 to 6 do			EnableItem(MenuList[3], i);		for i := 7 to 10 do			DisableItem(MenuList[3], i);		DrawMenuBar;	end;	procedure DoDeskAcc (Item: Integer);{}{    purpose         start up desk accessory from Apple menu}{v1.1 DName was incorrectly declared as a STRING and some lines commented out. DAs now work correctly.}		var			SavePort: GrafPtr;			DName: Str255;      RefNum: INTEGER;	begin		if frontwindow = mainptr then			begin				if theMode = Albuming then					Danger := TRUE;				Storeoffscreen(MainPtr^.PortRect, MyBitMap);			end;		GetPort(SavePort);                    			{ save port before starting it  }		GetItem(MenuList[AM], Item, DName);		{ get name of desk accessory    }		refNum := OpenDeskAcc(DName);			{*This line was commented out! -Alun v1.1*}     										{ and start that sucker up!     }		SetPort(SavePort);                    			{ restore grafport and continue }		DAon := TRUE	end; { of proc DoDeskAcc }	procedure DoFileMenuCommands (menuItem: Integer);{v1.1 same as before, I have just split the very long proc into readable pieces}		var			verdict, StoreNRows, StoreNCols: Integer;			err: OSErr;	begin		StoreNRows := NRows;		StoreNCols := NCols;		case menuItem of			LoadAlbumItem: 				begin					NRows := AlbumNRows;					NCols := AlbumNCols;					SetUpBoxes;					LoadingFossils := FALSE;					DoLoad(TRUE);					NRows := StoreNRows;					NCols := StoreNCols;				end;			LoadFossilsItem: 				begin					if not FossilsExist then						ResetFossils					else						begin							DotheSave := FALSE;							DireMessage(kFossilsID, kResettingID, Verdict, true);							if Verdict = 1 then								SaveSlides; {Yes}                            {returns with DoTheSave}							if (Verdict = 1) and (DoTheSave) then								ResetFossils;							if Verdict = 2 then								ResetFossils {No}						end;					if verdict <> 3 then {3=cancel}						begin							Fossilizing := FALSE;  {Filetype := 'COLL';}							err := SetEOF(slides, 0);							LoadingFossils := TRUE;							ReadAnimals(ThisMenagerie); {Menagerie is dummy}                        {The next 3 lines are necessary for Spencer's manual but better out}                        (*ClosePlayBack;}{                        Fossilizing:=TRUE;}{                        DoBreed*)                        {Reset(slides);}{                        StartPlayBack;}						end; {Not cancelled}				end;{case 2}			SaveBiomorphItem: 				DoSave(1);			SaveFossilsItem: 				SaveSlides;			SaveAlbumItem: 				if theMode = Moving then					DoSave(2)				else					DoSave(3);			CloseAlbumItem: 				DoClose;			QuitItem: 				Finished := True;   { Quit command              }		end;{case}	end;{DoFileMenuCommands}	procedure DoEditMenuCommands (item: Integer);		var			StoreNRows, StoreNCols: Integer;	begin		StoreNRows := NRows;		StoreNCols := NCols;		if Item <> CutItem then			ClipBoarding := FALSE;		if (Item >= AddBiomItem) then			begin				if TheMode <> Albuming then					StoreBreedingScreen;				NRows := AlbumNRows;				NCols := AlbumNCols;				TheMode := Albuming;				SetUpBoxes			end;		case Item of			UndoItem: 				if not SystemEdit(0) then					Sysbeep(1);			2: 				;  {----------------}			CutItem: 				if not SystemEdit(2) then					Sysbeep(1);			Copyitem: 				if not SystemEdit(3) then					SendToClipBoard;			PasteItem: 				if not SystemEdit(4) then					DoClear(FALSE);			ClearItem: 				if not SystemEdit(5) then					DoClear(TRUE);			7: 				;  {----------------}			HighlightBiomItem: 				DoHighlight;			AddBiomItem: 				begin					AddToAlbum(child[special]);				end;{****}                    {Range check fails on special, gives bomb, when album emptied}			ShowAlbumItem: 				if Page > 1 then					Zoom				else					begin						UncurtainPage(CurrentPage);						TakeCare(CurrentPage);						if OldSpecial = 0 then							begin								OldSpecial := Special;								InvertRect(Box[special])							end;					end;		end; {Cases}		if Item >= HighlightBiomItem then			begin				NRows := StoreNRows;				NCols := StoreNCols;			end;	end;{DoEditMenuCommand}	procedure DoSpecMenuCommands (item: Integer);	begin		case Item of			ClosePlaybackItem: 				begin {Child[MidBox]:=FirstBiomorph;}					ClosePlayBack;				end;			BreedCurrentItem: 				begin					FirstBiomorph := TheBiomorph;					ClosePlayBack;					Fossilizing := FALSE;					DoBreed				end;			QuitPlaybackItem: 				Finished := TRUE;		end;	end;{DoSpecMenuCommands}	procedure DoOperationMenuCommands (item: Integer);		var			verdict: Integer;			err: OSErr;	begin		ClipBoarding := FALSE;		case Item of              { Operation Menu          }			BreedItem: 				begin					NRows := BreedNRows;					NCols := BreedNCols;					SetUpBoxes;					NActiveBoxes := NBoxes;					DoBreed;				end;			DriftItem: 				begin					EraseRect(Prect);					TheMode := Drifting;					DriftOne := 0;					NActiveBoxes := 0;				end;			EngineeringItem: 				begin					DoEngineer				end;			HopeMonsterItem: 				begin					DoSaltation;				end;			InitFossRecItem: 				begin					if not FossilsExist then						ResetFossils					else						begin							DotheSave := FALSE;							DireMessage(kFossilsID, kResettingID, Verdict, true);							if Verdict = 1 then								SaveSlides; {Yes}                            {returns with DoTheSave}							if (Verdict = 1) and (DoTheSave) then								ResetFossils;							if Verdict = 2 then								ResetFossils {No}						end;				end;			PlayFossilItem: 				begin					err := SetFPos(Slides, fsFromStart, 0);		{v1.1  was reset(Slides);} 																											{Only play back history made this time}					StartPlayBack;  {Play Back Fossil Record}				end;			RecordFossilItem: 				Fossilizing := not Fossilizing;			TriangleItem: 				begin					TheMode := triangling;					OldSpecial := 0;					MainTriangle				end;		end;	end;	procedure DoBoxMenuCommands (item: Integer);		var			verdict: Integer;	begin		ClipBoarding := FALSE;		case Item of			MoreRowsItem: 				DoRowMore;			FewerRowsItem: 				DoRowLess;			MoreColumnsItem: 				DoColMore;			FewerColumnsItem: 				DoColLess;			ThickerPenItem: 				begin					MyPenSize := MyPenSize + 1;					DoEngineer				end;			ThinnerPenItem: 				begin					MyPenSize := MyPenSize - 1;					DoEngineer				end;			DriftSweepItem: 				begin					SweepOn := not SweepOn;					CheckItem(MenuList[BM], Item, SweepOn);                        {EraseRect(PRect);}					DriftOne := 0;                        {TheMode:=Drifting}				end;			TriangleTopItem: 				begin					if theMode = Triangling then						begin							SimpleMessage(14234, Verdict);							if verdict = 1 then								begin									Topan := child[special];									MainTriangle								end						end					else						Topan := child[special]				end;			TriangleLeftItem: 				begin					if theMode = Triangling then						begin							SimpleMessage(14234, Verdict);							if verdict = 1 then								begin									Leftan := child[special];									MainTriangle								end						end					else						Leftan := child[special]				end;			TriangleRightItem: 				begin					if theMode = Triangling then						begin							SimpleMessage(14234, Verdict);							if verdict = 1 then								begin									Rightan := child[special];									MainTriangle								end						end					else						Rightan := child[special]				end;			11: 				; {line}			HideWindowItem:{Toggle hide windows}				begin					hideInBackground := not hideInBackGround;		{TRUE = hide windows when switching out}					CheckItem(MenuList[BM], Item, hideInBackGround);				end;		end;		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		BreedNRows := NRows;		BreedNCols := NCols;		BreedNBoxes := NBoxes;	end;	procedure DoMutationMenuCommands (item: Integer);	begin		ClipBoarding := FALSE;		CheckItem(MenuList[MM], Item, not Mut[Item]);		Mut[Item] := not Mut[Item];		SetItemState(MM, 2, Mut[1]);		if not Mut[1] then			begin				Mut[2] := FALSE;				CheckItem(MenuList[MM], 2, FALSE)			end	end;	procedure DoPedigreeMenuCommands (item: Integer);	begin		case Item of			DisplayPedigreeItem: 				PhylogNew(Child[special]);			2: 				; {-------------------}			DrawOutItem: 				TheMode := Phyloging;			NoMirrorsItem: 				begin					Rays := 1;					CheckItem(MenuList[PM], 4, TRUE);					CheckItem(MenuList[PM], 5, FALSE);					CheckItem(MenuList[PM], 6, FALSE);				end;			SingleMirrorItem: 				begin					Rays := 2;					CheckItem(MenuList[PM], 5, TRUE);					CheckItem(MenuList[PM], 4, FALSE);					CheckItem(MenuList[PM], 6, FALSE);				end;			DoubleMirrorItem: 				begin					Rays := 4;					CheckItem(MenuList[PM], 6, TRUE);					CheckItem(MenuList[PM], 4, FALSE);					CheckItem(MenuList[PM], 5, FALSE);				end;			7: 				;{-------------------}			MoveItem: 				TheMode := Moving;			DetachItem: 				TheMode := Detaching;			KillItem: 				TheMode := Killing;		end;	end;{DoPedigreeMenuCommands}	procedure DoHelpMenuCommands (item: Integer);	begin		if ClipBoarding then			HelpMessage(7699)		else			case Item of				HelpCurrentItem: 					case theMode of						Breeding: 							HelpMessage(2630);						albuming: 							HelpMessage(11506);						phyloging: 							HelpMessage(12587);						killing: 							HelpMessage(11150);						moving: 							HelpMessage(4241);						detaching: 							HelpMessage(16204);						randoming: 							HelpMessage(26732);						engineering: 							HelpMessage(8597);						drifting: 							HelpMessage(8947);						highlighting: 							HelpMessage(19866);						PlayingBack: 							HelpMessage(11238);						triangling: 							HelpMessage(17751);						sweeping: 							HelpMessage(8947);					end; {Cases}				HelpMiscItem: 					HelpMessage(21128);			end; {Help 2 cases}	end;{DoHelpMenuCommands}	procedure HandleMenu (MenuInfo: LongInt);{####)}{}{}{    purpose         decode MenuInfo and carry out command}{}		var			Menu: Integer;          { menu number that was selected     }			Item: Integer;	begin		if MenuInfo <> 0 then			begin				PenNormal;                      				{ set the pen back to normal}				Menu := HiWord(MenuInfo);       		{ find which menu the command is in }				Item := LoWord(MenuInfo);       			{ get the command number}				case Menu of					ApplMenu: 						begin							if Item = 1 then								DoAbout            	{ bring up "About..." window}							else								DoDeskAcc(Item);   	{ start desk accessory}                     								{ and carry it out }						end;					FileMenu: 						DoFileMenuCommands(item);					EditMenu: 						DoEditMenuCommands(item);					SpecMenu: 						DoSpecMenuCommands(item);					OperMenu: 						DoOperationMenuCommands(item);					BoxMenu: 						DoBoxMenuCommands(item);					MutationMenu: 						DoMutationMenuCommands(item);					PedigreeMenu: 						DoPedigreeMenuCommands(item);					HelpMenu: 						DoHelpMenuCommands(item);					otherwise						Sysbeep(1);				end;{case of Menu}				HiliteMenu(0);                          { reset menu bar            }			end;	end; {of proc HandleMenu}	procedure DoUpdate (theEvent: EventRecord);{}{    purpose         handles window update event}{}		var			SavePort, theWindow: WindowPtr;	begin		theWindow := WindowPtr(theEvent.Message);     { find which window     }		if (theWindow = MainPtr) or (theWindow = PlayBackPtr) then			begin            { only update ours      }				SetCursor(CursList[watchCursor]^^);         { set cursor to watch   }				GetPort(SavePort);                          { save current grafport }				SetPort(theWindow);                         { set as current port   }				BeginUpdate(theWindow);                     { signal start of update}				if theWindow = MainPtr then					ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);  { and here's the update stuff! }				if theWindow = PlayBackPtr then					begin						PlayBackRect := PlayBackPtr^.PortRect;						EraseRect(PlayBackRect);						DrawGrowIcon(PlayBackPtr);                   { draw grow icon  }						DrawControls(PlayBackPtr);						with PlayBackRect do							begin								right := right - Scrollbarwidth - 1;								bottom := bottom - Scrollbarwidth - 1;							end;						if theMode = PlayingBack then							Snapshot(MyPic, PlayBackRect, theBiomorph);					end;  { now, back to our program...}				EndUpdate(theWindow);                       { signal end of update  }				SetPort(SavePort);                          { restore grafport      }				SetCursor(Arrow)                            { restore cursor        }			end; {MainPtr}	end; { of proc DoUpdate }	procedure HandleClick (WPtr: WindowPtr; MLoc: Point);{}{    purpose         handle mouse click within window}{}		var			MP: point;			Ticker: LongInt;      ErrCode: OSErr;	begin		if (WPtr = MainPtr) or (WPtr = PlayBackPtr) then     { if this is our window...  }			begin				if WPtr <> frontw then             { and it's not in front...  }					begin						SelectWindow(WPtr);               { ...then make it active    }						frontw := MainPtr;						reStoreOffScreen(MainPtr^.PortRect, MyBitMap);             {DoUpdate(theEvent);}						enablemenus;					end				else if TheMode = triangling then					PlotTriangle(MLoc, TRUE)				else if TheMode = breeding then					begin						SetCursor(CursList[watchCursor]^^);						evolve(MLoc);						SetCursor(CursList[crossCursor]^^)					end				else if TheMode = randoming then					DoSaltation				else if TheMode = PlayingBack then					begin						GlobalToLocal(MLoc);						if PtInRect(MLoc, MyControl^^.contrlRect) then							begin								DoPlayBack(MLoc)							end					end				else if (TheMode = Phyloging) then					begin						RunningFull := SpecialFull;						GetMouse(MP);						if MouseInBox(MP, RunningFull) then							DrawOutFrom(RunningFull);					end;				if TheMode = Moving then					begin						RunningFull := SpecialFull;						GetMouse(MP);						if MouseInBox(MP, RunningFull) then							FollowMouse(RunningFull)					end;				if TheMode = Detaching then					begin						RunningFull := SpecialFull;						GetMouse(MP);						if MouseInBox(MP, RunningFull) then							begin								if IsAnAdam(RunningFull) then									SysBeep(1)								else									Detach(RunningFull)							end					end;				if TheMode = Killing then					begin						RunningFull := SpecialFull;						GetMouse(MP);						if MouseInBox(MP, RunningFull) then							Shoot(RunningFull);					end;				if TheMode = engineering then					begin						Ticker := TickCount;						if FirstTime then							SetCursor(CursList[watchCursor]^^);						Manipulation(MLoc);						if FirstTime then							begin								FirstTime := FALSE;								repeat								until TickCount - Ticker > GetDblTime;							end;						if button then							ErrCode := PostEvent(MouseDown, 0)					end				else if TheMode = highlighting then					emphasize(MLoc);				if (TheMode = Albuming) and (not Zoomed) then					emphasize(MLoc);				Zoomed := FALSE;			end;	end; { of proc HandleClick }	procedure HandleGrow (WPtr: WindowPtr; MLoc: Point);{}{    purpose         handle mouse click in grow box}{}		type			GrowRec = record					case Integer of						0: (								Result: LongInt						);						1: (								Height, Width: Integer						)				end;		var			GrowInfo: GrowRec;	begin		if WPtr = PlayBackPtr then			with GrowInfo do  { if it's our window    }				begin					InvalRect(WPtr^.portRect);                   {   set up for update   }					Result := GrowWindow(WPtr, MLoc, GrowArea);   {   get amt of growth   }					SizeWindow(WPtr, Width, Height, True);         {   resize window       }					with PlayBackPtr^.PortRect do						begin							MoveControl(MyControl, right - (ScrollBarWidth - 1), top - 1);							SizeControl(MyControl, ScrollBarWidth, (bottom + 1) - (top - 1) - (ScrollBarWidth - 1))						end;{    PlayBackRect:=WPtr^.PortRect;}{    WITH PlayBackRect DO}{        BEGIN right:=right-Scrollbarwidth-1;}{        bottom:=bottom-Scrollbarwidth-1;}{        MidPoint.h:=(right-left) DIV 2;}{        MidPoint.v:=(bottom-top) DIV 2}{        END;}    {InvalRect(MainPtr^.PortRect);}				end;	end; { of proc HandleGrow }	procedure DoActivate (theEvent: EventRecord);{}{    purpose         handles window activation event}{}		var			theWindow: WindowPtr;	begin		with theEvent do			begin				theWindow := WindowPtr(Message);            { get the window        }				SetPort(theWindow);                       {   make it the port    }				frontw := theWindow;                  {   know it's in front  }				SelectWindow(theWindow);              { -- in place of the previous}                                             { -- line.   AG              }				if theWindow = MainPtr then					ReStoreOffScreen(MainPtr^.PortRect, MyBitMap)				else					begin						DrawGrowIcon(theWindow);					{v1.1 to ensure activating icon}						HiliteControl(myControl, 0);					{activate scrollbar}					end;				InvalRect(theWindow^.PortRect);				Enablemenus;				DAon := FALSE;                      { it must be our window }			end	end;	procedure DoDeactivate (theEvent: EventRecord);		var			theWindow: WindowPtr;	begin		with theEvent do			begin				theWindow := WindowPtr(Message);            { get the window        }				if theWindow = PlaybackPtr then					begin						child[special] := FirstBiomorph;						HiliteControl(myControl, 255);	{deactivate scrollbar}					end				else					Storeoffscreen(MainPtr^.PortRect, MyBitMap);				SetPort(ScreenPort);                      { else reassign port    }			end;                              {   update menu bar     }	end;	procedure DoSuspend (theEvent: EventRecord);{We have to do everything necessary (deactivate windows, copy local}{scrap to global, etc) before being switched out}{Set the flag to say we are in the background													}	begin		if frontw = PlaybackPtr then			begin				child[special] := FirstBiomorph;				HiliteControl(myControl, 255);	{deactivate scrollbar}			end;		if hideInBackGround then			begin				HideWindow(PlaybackPtr);				Storeoffscreen(MainPtr^.PortRect, MyBitMap);				HideWindow(MainPtr)			end;		InitCursor;						{Set arrow cursor for other programs}		DAOn := True;		RememberMode := theMode;	end;	procedure DoResume (theEvent: EventRecord);{Activate the front window}	begin		if hideInBackground then			begin				ShowWindow(MainPtr);				if frontw = playbackPtr then					ShowWindow(PlaybackPtr)				else					ReStoreOffScreen(MainPtr^.PortRect, MyBitMap)			end;{Enablemenus;}		DAon := FALSE;		SetCursor(theCursor);		theMode := RememberMode;	end;	procedure DoDiskEvent (macEvent: EventRecord); (* The disk event					*)		var			corner: Point; 	(* Location for Dialog box			*)			ignore: Integer;	begin		if (HiWord(macEvent.message) <> noErr) then			begin						(* Some sort of error occurred.		*)						(*   Check if user wants to format	*)						(*   the disk.						*)				SetPt(corner, 112, 80);						(* ??? Can dialog box be centered	*)						(*   There doesn't appear to be a	*)						(*   DLOG resource for this one.	*)						(*   Location (112,80) is the value	*)						(*   used by Finder 6.1. 			*)				ignore := DIBadMount(corner, macEvent.message);			end;	end;	procedure HandleGoAway (WPtr: WindowPtr; MLoc: Point);{}{    purpose         handle mouse click in go-away box}{}		var			WPeek: WindowPeek;           { for looking at windows    }	begin		if WPtr = frontw then{Indow}			begin          { if it's the active window }				WPeek := WindowPeek(WPtr);              { peek at the window        }				if TrackGoAway(WPtr, MLoc) then					begin    {   and the box is clicked  }						if WPeek^.WindowKind = PascalKind then       {     if it's our window    }							begin								child[special] := FirstBiomorph;								ClosePlayBack;							end						else							begin								DAon := FALSE;								Sysbeep(1);								CloseDeskAcc(WPeek^.WindowKind);{       else close DeskAcc  }								enablemenus;                   {   and re-enable menus     }								Sysbeep(1);								repeat								until not button;								repeat								until button;							end;					end			end		else			SelectWindow(WPtr)                   { else make it active       }	end; { of proc HandleGoAway }	procedure DoKeypress (KeyCh: Char);{If the user presses a key, we go into evolving the biomorph until the mouse is pressed.}	begin		min := 30000;{TargetEvolve(target);}	end; { of proc DoKeypress }	procedure KeyDownEvents (theEvent: EventRecord);{ A key was pressed.  Do something with incoming character.}		var			ch: CHAR;	begin		with theEvent do			begin				ch := CHR(BitAnd(message, charCodeMask));    		{Get character}				if BitAnd(modifiers, Cmdkey) <> 0 then     		{If command key pressed}					HandleMenu(MenuKey(ch))       						{  then execute command}				else					DoKeyPress(ch)											{else use character}			end {with}	end; {KeyDownEvents}	procedure DoOtherEvent (macEvent: EventRecord);{Things like network events.  We don't do anything with these, this is a place-holder for future enhancements}	begin	end;	procedure DoMouseDown (theEvent: EventRecord);{}{    purpose         identify where mouse was clicked and handle it}{}		var			Location: Integer;			theWindow: WindowPtr;			MLoc: Point;			WLoc: Integer;	begin		MLoc := theEvent.Where;              { get mouse position            }		WLoc := FindWindow(MLoc, theWindow);   { get window, loc in window     }		case WLoc of                          { handle window locations       }			InMenuBar: 				HandleMenu(MenuSelect(MLoc));     { in the menu       }			InContent: 				HandleClick(theWindow, MLoc);      { inside the window }			IngoAway: 				HandleGoAway(theWindow, MLoc);     { in the go away box}			InGrow: 				HandleGrow(theWindow, MLoc);       { in the grow box   }			InDrag: 				begin					DragWindow(theWindow, MLoc, DragArea); { in the drag bar}					with PlayBackPtr^.PortRect do						begin							MoveControl(MyControl, right - (ScrollBarWidth - 1), top - 1);							SizeControl(MyControl, ScrollBarWidth, (bottom + 1) - (top - 1) - (ScrollBarWidth - 1))						end;				end;			InSysWindow: 				begin					SystemClick(theEvent, theWindow);  { in a DA window    }                  { if frontwindow=mainptr then enablemenus;}{                   front}				end;		end	end; { of proc DoMouseDown }	procedure HandleEvent (theEvent: EventRecord);{}{    purpose         decodes event and handles it}{* v1.1 Sept 1993.  Added handling of suspend/resume events - Alun *}{}		const			MouseMovedEvt = $FA;		{ Mouse moved event code		}			SuspendResumeEvt = $01;		{ Suspend/Resume event code	}			ResumeEvtMask = $1;			{ Supend or Resume selector	}			ConvertScrapMask = $2;		{ Scrap conversion flag			}	begin		case theEvent.What of			mouseDown: 				DoMouseDown(theEvent);      		{ mouse button pushed   }			MouseUp: 				FirstTime := TRUE;			keyDown,								{ Key was pressed		}			keyUp, autoKey: 				KeyDownEvents(theEvent);			{ key pressed down      }			diskEvt: 				DoDiskEvent(theEvent);				{ Disk insertion Event	}			updateEvt: 				DoUpdate(theEvent);         				{ window need updating  }			activateEvt:				{ Activate or Deactivate a window	}								{   Check the modifiers field to		}								{   determine which one it is			}				if BitAnd(theEvent.modifiers, activeFlag) <> 0 then					DoActivate(theEvent)				else					DoDeactivate(theEvent);						{* MULTIFINDER EVENTS *}			app4Evt: 				case BAND(BSR(theEvent.message, 24), $FF) of								{ Event type is stored in the			}								{   high byte of the event message	}								{   Typecast to unsigned long so		}								{   we won't get sign extension		}								{   when the bits are shifted			}					MouseMovedEvt: 						;									{ Since we adjust the cursor shape }									{   before handling an event, we 	}									{   can just idle here. 				}{DoIdle(theEvent);	 We could do things like update cursor shape in a DoIdle proc, which is preferable,}{but this is done earlier at the moment. Alun}					SuspendResumeEvt: 		{ Context switch		}						if BAND(theEvent.message, ResumeEvtMask) <> 0 then							DoResume(theEvent)						else							DoSuspend(theEvent);				end;			otherwise						{ Some other event	}				DoOtherEvent(theEvent);		end	end; { of proc HandleEvent }end.