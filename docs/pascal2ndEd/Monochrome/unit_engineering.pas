unit unit_engineering;interface	uses{$IFC UNDEFINED THINK_Pascal}		Quickdraw, Types,  {$ENDC}		unit_globals, unit_miscellaneous, unit_biomorphs;	procedure DoEngineer;	procedure DoSaltation;	procedure Manipulation (MLoc: point);	function LeftRightPos (MLoc: Point; Box: Rect): HorizPos;	function Rung (Mloc: Point; Box: Rect): VertPos;implementation	procedure DoEngineer;	begin		TheMode := engineering;		EraseRect(Prect);		SetUpBoxes;		child[midbox] := child[special];		special := midbox;		Delayvelop(child[special], centre[MidBox]);		MakeGeneBox(child[special]);		StoreOffScreen(MainPtr^.PortRect, MyBitMap);	end; {DoEngineer}	function LeftRightPos (MLoc: Point; Box: Rect): HorizPos;	begin		with Box do			if MLoc.h < left + (right - left) div 3 then				LeftRightPos := LeftThird			else if Mloc.h > right - (right - left) div 3 then				LeftRightPos := RightThird			else				LeftRightPos := MidThird	end;	function Rung (Mloc: Point; Box: Rect): VertPos;	begin		with Box do			if MLoc.v < top + (bottom - top) div 3 then				Rung := TopRung			else if MLoc.v > bottom - (bottom - top) div 3 then				Rung := BottomRung			else				Rung := MidRung	end;	procedure SnapDevelop (Biomorph: person; Place: Point);		var			SnappyBox: Rect;	begin		SnappyBox := Margin;		Develop(biomorph, Place, true);		with Snappybox do			begin				if Margin.left < left then					left := Margin.left;				if Margin.right > right then					right := Margin.right;				if Margin.top < top then					top := Margin.top;				if Margin.bottom > bottom then					bottom := Margin.bottom			end;		Grow(Snappybox, MyPenSize);		Snapshot(MyPic, Snappybox, Biomorph);	end; {SnapDevelop}	procedure Manipulation (MLoc: point);		var			j, chosenbox: Integer;			Cent: Point;			swallowing, refrain: Boolean;	begin		GlobalToLocal(Mloc);		ChosenBox := 0;		if Mloc.v < GeneBox[1].bottom then			for j := 1 to 16 do				if PtInRect(MLoc, GeneBox[j]) then					ChosenBox := j;		j := ChosenBox;		if ChosenBox = 0 then			SyringeMessage		else			begin				with child[special] do					case ChosenBox of						1..8: 							case LeftRightPos(Mloc, GeneBox[j]) of								LeftThird: 									gene[j] := gene[j] - MutSizeGene;								RightThird: 									gene[j] := gene[j] + MutSizeGene;								MidThird: 									case Rung(Mloc, GeneBox[j]) of										TopRung: 											dGene[j] := Swell;										MidRung: 											dGene[j] := Same;										BottomRung: 											dGene[j] := Shrink;									end; {MidThird}							end; {CASE 1..8}						9: 							case LeftRightPos(Mloc, GeneBox[j]) of								LeftThird: 									gene[j] := gene[j] - 1;								RightThird: 									begin										gene[j] := gene[j] + 1;										SizeWorry := SegNoGene * TwoToThe(gene[9]);										if SizeWorry > WorryMax then											Gene[9] := Gene[9] - 1;									end;								MidThird: 									case Rung(Mloc, GeneBox[j]) of										TopRung: 											dGene[j] := Swell;										MidRung: 											dGene[j] := Same;										BottomRung: 											dGene[j] := Shrink;									end; {MidThird}							end; {CASE 1..8}						10: 							case LeftRightPos(Mloc, GeneBox[10]) of								LeftThird: 									SegNoGene := SegNoGene - 1;								MidThird: 									;   {No Action}								RightThird: 									begin										SegNoGene := SegNoGene + 1;										SizeWorry := SegNoGene * TwoToThe(gene[9]);										if SizeWorry > WorryMax then											SegNoGene := SegNoGene - 1;									end;							end;						11: 							case LeftRightPos(Mloc, GeneBox[11]) of								LeftThird: 									SegDistGene := SegDistGene - TrickleGene;								MidThird: 									case Rung(Mloc, GeneBox[j]) of										TopRung: 											dGene[10] := Swell;										MidRung: 											dGene[10] := Same;										BottomRung: 											dGene[10] := Shrink;									end; {MidThird}								RightThird: 									SegDistGene := SegDistGene + TrickleGene;							end;						12: 							case LeftRightPos(Mloc, GeneBox[12]) of								LeftThird: 									CompletenessGene := Single;								MidThird: 									;    {No Action}								RightThird: 									CompletenessGene := Double;							end;						13: 							case LeftRightPos(Mloc, GeneBox[13]) of								LeftThird: 									SpokesGene := NorthOnly;								MidThird: 									SpokesGene := NSouth;								RightThird: 									SpokesGene := Radial;							end;						14: 							case LeftRightPos(Mloc, GeneBox[j]) of								LeftThird: 									begin										tricklegene := tricklegene - 1;										if tricklegene < 1 then											tricklegene := 1;									end;								RightThird: 									tricklegene := tricklegene + 1;								MidThird: 									; {No action}							end;						15: 							case LeftRightPos(Mloc, GeneBox[j]) of								LeftThird: 									begin										MutSizegene := MutSizegene - 1;										if MutSizegene < 1 then											MutSizegene := 1									end;								RightThird: 									MutSizegene := MutSizegene + 1;								MidThird: {No action}							end;						16: 							case LeftRightPos(Mloc, GeneBox[j]) of								LeftThird: 									begin										MutProbGene := MutProbGene - 1;										if MutProbgene < 1 then											MutProbgene := 1									end;								RightThird: 									begin										MutProbGene := MutProbGene + 1;										if MutProbgene > 100 then											MutProbgene := 100									end;								MidThird: {No action}							end;					end;				with child[special] do					begin						Refrain := (Gene[9] > 12) or (Gene[9] < 1) or (SegNoGene < 1) or (ChosenBox >= 15);{����}						if Gene[9] < 1 then							Gene[9] := 1;						if SegNoGene < 1 then							SegNoGene := 1					end;				if not Refrain then					SnapDevelop(child[special], centre[MidBox]);				ShowGeneBox(chosenbox, child[special]);			end	end; {Manipulation}	procedure DoSaltation;		var			j, maxgene, r: Integer;			factor: -1..1;	begin		{DelayedDrawing := FALSE; ABC}		special := MidBox;		with child[special] do {bomb 5, range check failed, here after killing top Adam}			begin				if Mut[1] then					begin						SegNoGene := randint(6);						SegDistGene := randint(20);					end				else					begin						SegNoGene := 1;						SegDistGene := 1					end;				r := randint(100);				CompletenessGene := Double;				if Mut[3] then					if r < 50 then						CompletenessGene := Single					else						CompletenessGene := Double;				r := randint(100);				if Mut[4] then					begin						if r < 33 then							SpokesGene := Radial						else if r < 66 then							SpokesGene := NSouth						else							SpokesGene := NorthOnly					end				else					SpokesGene := NorthOnly;				if Mut[5] then					begin						TrickleGene := 1 + randint(100) div 10;						if TrickleGene > 1 then							MutSizeGene := Tricklegene div 2					end;				for j := 1 to 8 do					repeat						gene[j] := MutSizeGene * (randint(19) - 10);						if Mut[2] then							dGene[j] := RandSwell(dgene[j])						else							dGene[j] := Same;						case dGene[j] of							Shrink: 								factor := 1;							Same: 								factor := 0;							Swell: 								factor := 1;						end; {Cases}						maxgene := gene[j] * SegNoGene * factor;					until (maxgene <= 9 * Tricklegene) and (maxgene >= -9 * Tricklegene);				repeat					if Mut[8] then						dGene[9] := RandSwell(dgene[9])					else						dGene[9] := Same;					if Mut[2] then						dGene[10] := RandSwell(dgene[9])					else						dGene[10] := Same;					case dGene[j] of						Shrink: 							factor := 1;						Same: 							factor := 0;						Swell: 							factor := 1;					end; {Cases}					maxgene := SegDistGene * SegNoGene * factor;				until (maxgene <= 100) and (maxgene >= -100);				repeat					Gene[9] := randint(6)				until Gene[9] > 1;			end;		EraseRect(Prect);		Develop(child[special], centre[midBox], false);    DrawPic(MyPic, centre[midBox], child[special]);		MakeGeneBox(child[special]);		TheMode := Randoming;	end; {DoSaltation}end.