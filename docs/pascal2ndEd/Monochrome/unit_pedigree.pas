unit unit_pedigree;interface	uses{$IFC UNDEFINED THINK_Pascal}		Types,  {$ENDC}		unit_globals, unit_miscellaneous, unit_biomorphs, unit_triangle, unit_album;	procedure PhylogNew (Biomorph: Person);	procedure DrawOutFrom (ThisFull: FullHandle);	procedure Detach (ThisFull: FullHandle);	procedure Shoot (ThisFull: FullHandle);	function MouseInBox (MLoc: Point; var ThisFull: FullHandle): Boolean;	procedure FollowMouse (ThisFull: FullHandle);	function IsAnAdam (ThisFull: FullHandle): Boolean;	function Created: FullHandle;implementation	uses{$IFC UNDEFINED THINK_Pascal}		think_pascal, Events, Memory, OSUtils, Quickdraw, SegLoad, TextUtils, ToolUtils,  {$ENDC}		unit_error;	function Created: FullHandle;		var			TickValue: LongInt;			Mem: Size;			interim: FullHandle;			sizeNeeded: LongInt;			errString, helpString: Str255;	begin		Mem := CompactMem(SizeOf(Full));		if Mem < SizeOf(Full) then			Sysbeep(1);		SizeNeeded := SizeOf(Full);		if (Memavail - SizeNeeded) < SafetyValve then			begin				GetIndString(errString, 128, 15);				GetIndString(helpString, 128, 4);				DisplayError(-108, errString, helpString, StopError);				GracefulDeath;{was MemoryMessage(4405, ' in Creating new Pedigree origin', Verdict);}			end;		Interim := FullHandle(NewHandle(SizeNeeded));		if MemError <> noErr then			ExitToShell;		Interim^^.Parent := nil;		Interim^^.FirstBorn := nil;		Interim^^.LastBorn := nil;		Interim^^.ElderSib := nil;		Interim^^.YoungerSib := nil;		Interim^^.Damaged := FALSE;		Interim^^.next := nil;		Interim^^.prec := nil;		created := interim	end;	function MouseInBox (MLoc: Point; var ThisFull: FullHandle): Boolean;		var			Victim: FullHandle;		procedure CheckVictim (ThisFull: FullHandle);		begin			if PtInRect(MLoc, ThisFull^^.Surround) then				Victim := ThisFull			else				begin					if ThisFull^^.Next <> nil then						CheckVictim(ThisFull^^.Next)				end		end; {CheckVictim}	begin		Victim := nil;		if ThisFull <> nil then			CheckVictim(ThisFull);		if Victim = nil then			MouseInBox := FALSE		else			begin				ThisFull := Victim;				MouseInBox := TRUE			end	end; {MouseInBox}	procedure HighlightAll (ThisFull: FullHandle);	begin {Highlights Thisfull and its elder sibs, and all their descendants}		if ThisFull <> nil then			InvertRect(ThisFull^^.Surround);		if ThisFull^^.LastBorn <> nil then			HighlightAll(ThisFull^^.LastBorn);		if ThisFull^^.ElderSib <> nil then			HighlightAll(ThisFull^^.ElderSib);	end; {HighlightAllSibs}	procedure HighlightPedigree (ThisFull: FullHandle);	begin		if ThisFull <> nil then			begin				InvertRect(ThisFull^^.Surround);				if ThisFull^^.LastBorn <> nil then					HighlightAll(ThisFull^^.LastBorn);			end	end; {HighlightPedigree}	procedure FindLastGod; {Delivers last God in theGod}		var			thisGod: GodHandle;		procedure TryGod (thisGod: GodHandle);		begin			GodCounter := GodCounter + 1;			if thisGod^^.NextGod = nil then				theGod := thisGod			else				TryGod(thisGod^^.NextGod)		end; {TryGod}	begin		thisGod := RootGod;		GodCounter := 1;		if thisGod^^.NextGod = nil then			theGod := thisGod		else			TryGod(thisGod)	end; {FindLastGod}	function IsAnAdam (ThisFull: FullHandle): Boolean;{Returns TRUE if ThisFull is an Adam}		var			Yes: Boolean;			TryGod: GodHandle;		procedure AdamError (WhichError: Integer);		begin			if thisfull <> nil then				InvertRect(ThisFull^^.Surround);			Sysbeep(1); {Writeln('Adam Error');}			Sysbeep(1);			if Whicherror = 1 then {Writeln('Is Adam but Parent<>NIL') ELSE}{        Writeln('Not Adam, but Parent=NIL')}				;			InvertRect(ThisFull^^.Surround)		end; {AdamError}		procedure CheckAdam (ThisGod: GodHandle);		begin			if ThisGod <> nil then				begin					if ThisGod^^.Adam <> nil then						begin							if ThisGod^^.Adam = ThisFull then								begin									Yes := TRUE;									theGod := thisGod								end						end;					if ThisGod^^.NextGod <> nil then						CheckAdam(ThisGod^^.NextGod);				end;		end; {CheckAdam}	begin		Yes := FALSE;		tryGod := rootGod;		if ThisFull <> nil then			CheckAdam(tryGod);{IF Yes AND (ThisFull^^.parent<>NIL) THEN AdamError(1);}{IF (NOT Yes) AND (ThisFull^^.Parent=NIL) THEN AdamError(2);}		IsAnAdam := Yes	end; {IsAnAdam}	procedure ShowAllAdams (theGod: GodHandle);	begin		if theGod <> nil then			begin				InvertRect(theGod^^.Adam^^.surround);				if theGod^^.nextGod <> nil then					ShowAllAdams(theGod^^.NextGod)			end	end;	procedure ShowRelatives (thisFull: FullHandle);	begin		if thisFull <> nil then			begin				if thisFull^^.parent <> nil then					FrameRect(ThisFull^^.parent^^.surround);				if thisFull^^.ElderSib <> nil then					FrameRect(ThisFull^^.ElderSib^^.surround);				if thisFull^^.YoungerSib <> nil then					FrameRect(ThisFull^^.YoungerSib^^.surround);				if thisFull^^.LastBorn <> nil then					FrameRect(ThisFull^^.LastBorn^^.surround);				if thisFull^^.FirstBorn <> nil then					FrameRect(ThisFull^^.FirstBorn^^.surround);			end	end;	procedure ShowAllFulls (thisFull: FullHandle);	begin		if thisFull <> nil then			begin				Framerect(thisFull^^.surround);				ShowRelatives(ThisFull)			end;		if ThisFull^^.Next <> nil then			ShowAllFulls(ThisFull^^.Next)	end;	procedure MarkIf (ThisFull: FullHandle);	begin		if IsAnAdam(ThisFull) then			begin				FrameInnerRect(ThisFull^^.Surround);			end	end; {MarkIf}	procedure MarkUp (ThisFull: FullHandle);	begin		if ThisFull <> nil then			MarkIf(ThisFull);		if ThisFull^^.Next <> nil then			MarkUp(ThisFull^^.Next)	end; {MarkUp}	procedure ReDevelop (ThisFull: FullHandle);		var			TempSnap: BitMap;			TickValue: LongInt;	begin		if thisfull <> nil then			begin				TempSnap.BaseAddr := ThisFull^^.SnapHandle^;				TempSnap.rowBytes := ThisFull^^.SnapBytes;				TempSnap.Bounds := ThisFull^^.SnapBounds;				CopyBits(TempSnap, MainPtr^.PortBits, TempSnap.Bounds, thisFull^^.Surround, srcCopy, nil);				MarkIf(ThisFull);				ThisFull^^.Damaged := FALSE;			end;	end; {ReDevelop}	procedure CrossOut (ThisFull: FullHandle; Colour: Pattern);	begin		if thisfull <> nil then			begin				MoveTo(ThisFull^^.Surround.Left, ThisFull^^.Surround.Top);				PenPat(Colour);				LineTo(ThisFull^^.Surround.Right, ThisFull^^.Surround.Bottom);				PenNormal			end	end;	procedure SetAllUndamaged (ThisFull: FullHandle);	begin		if ThisFull <> nil then			begin				if ThisFull^^.Damaged then					CrossOut(ThisFull, White);				ThisFull^^.Damaged := FALSE;			end;		if ThisFull^^.Next <> nil then			SetAllUndamaged(ThisFull^^.Next)	end; {SetAllUndamaged}	procedure JuniorIntersection (ThisFull, OtherFull: FullHandle);{Records whether any intersection between This and Other (or Other's juniors),}{    in truth value of Other^^.Damaged and This^^.Damaged}	begin		if (thisfull <> nil) and (OtherFull <> nil) then			begin				if ThisFull <> OtherFull then					begin						if SectRect(ThisFull^^.Surround, OtherFull^^.Surround, DummyRect) then							begin								OtherFull^^.Damaged := TRUE;								ThisFull^^.Damaged := TRUE							end					end;				if OtherFull^^.Next <> nil then					JuniorIntersection(ThisFull, OtherFull^^.Next);			end	end; {JuniorIntersection}	procedure Coverer (ThisFull: FullHandle);	begin		if (ThisFull <> nil) and (ThisFull^^.Next <> nil) then			JuniorIntersection(ThisFull, ThisFull^^.Next);{IF ThisFull^^.Next<>NIL THEN Coverer(ThisFull^^.Next)}	end; {Coverer}	function IsCovered (ThisFull: FullHandle): Boolean;{Returns TRUE IF Thisfull is covered by any of its own seniors}		var			Covered: Boolean;		procedure SeniorIntersection (ThisFull, OtherFull: FullHandle);{Records whether any intersection between This and Other (or Other's seniors,}{    in truth value of Other^^.Damaged and This^^.Damaged}		begin			if (thisfull <> nil) and (OtherFull <> nil) then				begin					if ThisFull <> OtherFull then						begin							if SectRect(ThisFull^^.Surround, OtherFull^^.Surround, DummyRect) then								Covered := TRUE						end;					if OtherFull^^.Prec <> nil then						SeniorIntersection(ThisFull, OtherFull^^.Prec);				end		end; {SeniorIntersection}	begin		if ThisFull <> nil then			begin				if ThisFull^^.Prec = nil then					IsCovered := FALSE				else					begin						Covered := FALSE;						SeniorIntersection(ThisFull, ThisFull^^.Prec);						IsCovered := Covered;					end;			end	end; {IsCovered}	function OverEdge (ThisFull: FullHandle): Boolean;		var			Any: Boolean;			DestRect: Rect;	begin		Any := SectRect(Prect, ThisFull^^.Surround, DestRect);    {Don't use Any, interested in DestRect}		OverEdge := not EqualRect(DestRect, ThisFull^^.Surround)	end; {OverEdge}	procedure ReDrawAll (ThisFull: FullHandle);	begin		if ThisFull <> nil then			begin				MoveTo(ThisFull^^.Centre.h, ThisFull^^.Centre.v);				if ThisFull^^.Parent <> nil then					LineTo(ThisFull^^.Parent^^.Centre.h, ThisFull^^.Parent^^.Centre.v)			end;		if ThisFull^^.LastBorn <> nil then			ReDrawAll(ThisFull^^.LastBorn);		if ThisFull^^.ElderSib <> nil then			ReDrawAll(ThisFull^^.ElderSib);	end; {ReDrawAll}	procedure ReDrawLines (ThisFull: FullHandle);{Draws line from each box to its parent, if it has one, treating}{original ThisFull as Adam}	begin		if ThisFull <> nil then			begin				MoveTo(ThisFull^^.Centre.h, ThisFull^^.Centre.v);				if ThisFull^^.Parent <> nil then					LineTo(ThisFull^^.Parent^^.Centre.h, ThisFull^^.Parent^^.Centre.v);				if ThisFull^^.LastBorn <> nil then					ReDrawAll(ThisFull^^.LastBorn);			end	end; {ReDrawLines}	procedure AllLines (theGod: GodHandle);	begin		if theGod <> nil then			begin				if theGod^^.Adam <> nil then					ReDrawLines(theGod^^.Adam);				if theGod^^.nextGod <> nil then					AllLines(theGod^^.nextGod)			end	end; {AllLines}	procedure Connect (NucleusFull, OrbitFull: FullHandle);	begin		if (nucleusfull <> nil) and (orbitfull <> nil) then			begin				MoveTo(NucleusFull^^.Centre.h, NucleusFull^^.Centre.v);				ThereAreLines := TRUE;				LineTo(OrbitFull^^.Centre.h, OrbitFull^^.Centre.v);			end	end;	procedure LocalLines (ThisFull: FullHandle);		procedure ChildLine (Child: FullHandle);		begin			Connect(ThisFull, Child);			if Child^^.YoungerSib <> nil then				ChildLine(Child^^.YoungerSib);		end; {ChildLine}	begin		if ThisFull^^.Parent <> nil then			Connect(ThisFull, ThisFull^^.Parent);		if ThisFull^^.FirstBorn <> nil then			ChildLine(ThisFull^^.FirstBorn)	end; {LocalLines}	procedure Incorporate (ThisFull: FullHandle);{Incorporates it into clip region so not drawn over in future}	begin		RectRgn(Region2, ThisFull^^.Surround);		DiffRgn(DestRegion, Region2, DestRegion); {DestRegion now updated to include new box}		SetClip(DestRegion)	end; {Incorporate}	procedure WithdrawProtection (ThisFull: FullHandle);	begin		RectRgn(Region2, ThisFull^^.Surround);		UnionRgn(DestRegion, Region2, DestRegion); {DestRegion now updated to include new box}		SetClip(DestRegion)	end; {WithdrawProtection}	procedure Protect;		procedure ProtectAll (ThisFull: FullHandle);		begin			if ThisFull <> nil then				Incorporate(ThisFull);			if ThisFull^^.Next <> nil then				ProtectAll(ThisFull^^.Next)		end; {ProtectAll}	begin		RectRgn(DestRegion, PRect);		if SpecialFull <> nil then			ProtectAll(SpecialFull);	end; {Protect}	procedure Repair;		procedure RepairThis (ThisFull: FullHandle);		begin			if ThisFull <> nil then				begin					if ThisFull^^.Damaged then						begin							Redevelop(ThisFull);							Incorporate(ThisFull);							ThisFull^^.Damaged := FALSE						end;					if ThisFull^^.Next <> nil then						RepairThis(ThisFull^^.Next)				end		end; {RepairThis}	begin		RectRgn(DestRegion, Prect);		RepairThis(SpecialFull)	end; {Repair}	procedure WeedOut (ThisFull: FullHandle);		var			OnlyChild: Boolean;	begin {WeedOut}		if ThisFull <> nil then			if ThisFull^^.Parent <> nil then				begin					OnlyChild := (ThisFull^^.YoungerSib = nil) and (ThisFull^^.ElderSib = nil);					if OnlyChild then						begin							ThisFull^^.Parent^^.LastBorn := nil;							ThisFull^^.Parent^^.FirstBorn := nil						end					else						begin {not only child}							if ThisFull^^.YoungerSib = nil then								ThisFull^^.Parent^^.LastBorn := ThisFull^^.ElderSib							else								ThisFull^^.YoungerSib^^.ElderSib := ThisFull^^.ElderSib;							if ThisFull^^.ElderSib = nil then								ThisFull^^.Parent^^.FirstBorn := ThisFull^^.YoungerSib							else								ThisFull^^.ElderSib^^.YoungerSib := ThisFull^^.YoungerSib;						end;				end;	end; {WeedOut}	procedure WipeOut (ThisFull: FullHandle);	begin		DamageRect := ThisFull^^.Surround;		Coverer(ThisFull);		if ThisFull = SpecialFull then			begin				OldSpecialFull := SpecialFull;				SpecialFull := ThisFull^^.Next;				ThisFull^^.Prec := nil;{Corrected by RD Dec 1993 to cure Norton-reported bug, bombing when ancestor Killed}				ThisFull^^.Next := nil;			end		else			ThisFull^^.Prec^^.Next := ThisFull^^.Next;		if ThisFull^^.Next <> nil then			ThisFull^^.Next^^.Prec := ThisFull^^.Prec;		EraseRect(DamageRect);	end; {WipeOut}	procedure KillAll (ThisFull: FullHandle);{Kill ThisFull and all its elder sibs, including all their descendants}		var			NextVictim, SecondVictim: FullHandle;	begin		if ThisFull <> nil then			begin				NextVictim := ThisFull^^.LastBorn;				SecondVictim := ThisFull^^.ElderSib;				WipeOut(ThisFull);				if ThisFull = nil then					SysBeep(1)				else					begin						DisposHandle(ThisFull^^.SnapHandle);						DisposHandle(Handle(ThisFull));						ThisFull := nil					end;			end;		if NextVictim <> nil then			KillAll(NextVictim);		if SecondVictim <> nil then			KillAll(SecondVictim);	end; {KillALL}	procedure Kill (ThisFull: FullHandle);{Kill this one and all its descendants}		var			NextVictim, SecondVictim: FullHandle;	begin		if ThisFull <> nil then			begin				NextVictim := ThisFull^^.LastBorn;				WipeOut(ThisFull);				if ThisFull = nil then					SysBeep(1)				else					begin						DisposHandle(ThisFull^^.SnapHandle);						DisposHandle(Handle(ThisFull));						ThisFull := nil					end;				if NextVictim <> nil then					KillAll(NextVictim);			end;	end; {Kill}	procedure DrawWholeLot (ThisFull: FullHandle);	begin		if THisFull <> nil then			begin				Redevelop(ThisFull);				Incorporate(ThisFull);				if ThisFull^^.Next <> nil then					DrawWholeLot(ThisFull^^.Next)			end	end; {DrawWholeLot}	procedure Shoot (ThisFull: FullHandle);		var			TempFull: FullHandle;			YesAdam: Boolean;	begin		FindLastGod;		YesAdam := IsAnAdam(ThisFull); {leaves theGod as ThisFull's god if any}		if not YesAdam then			begin				WeedOut(ThisFull);				Kill(ThisFull)			end		else			begin {only comes here if trying to kill an Adam}				if ThisFull^^.parent <> nil then					Sysbeep(1);				if ThisFull^^.LastBorn <> nil then					begin						KillAll(ThisFull^^.LastBorn);						ThisFull^^.FirstBorn := nil;						ThisFull^^.LastBorn := nil;					end;				if ThisFull <> nil then					begin						WipeOut(ThisFull);						DisposHandle(ThisFull^^.SnapHandle);						DisposHandle(Handle(ThisFull));						ThisFull := nil					end;				if GodCounter = 3 then					begin						TheMode := Preliminary;						Special := 0					end;				if theGod^^.PreviousGod = nil then					SysBeep(1)				else					theGod^^.PreviousGod^^.NextGod := theGod^^.NextGod;				if theGod^^.NextGod <> nil then					theGod^^.NextGod^^.PreviousGod := theGod^^.PreviousGod;				theGod^^.nextGod := nil;				theGod^^.PreviousGod := nil;				TheGod^^.Adam := nil;				if theGod = nil then					SysBeep(1)				else					begin						DisposHandle(Handle(theGod));						theGod := nil					end			end;{   Protect;}{   EraseRect(Prect);}{   AllLines(rootGod);}{   ClipRect(Prect);}{Repair;}		EraseRect(Prect);		RectRgn(DestRegion, PRect);		DrawWholeLot(SpecialFull);		AllLines(rootGod);		ClipRect(PRect);	end; {shoot}	procedure ShootAll (thisGod: GodHandle);	begin		if thisGod <> nil then			begin				if ThisGod^^.Adam <> nil then					Shoot(ThisGod^^.Adam);				if ThisGod^^.NextGod <> nil then					ShootAll(ThisGod^^.NextGod)			end	end; {ShootAll}	procedure Massacre (ThisFull: FullHandle);{Normally called with SpecialFull first}	begin		if ThisFull <> nil then			Shoot(ThisFull);		if ThisFull^^.Next <> nil then			Massacre(ThisFull^^.Next)	end; {Massacre}	procedure Detach (ThisFull: FullHandle);{Isolates ThisFull from all except its descendants, leaving rest of}{pedigree hierarchical linked list tidied up and pointing elsewhere.}{Does not touch linear Specialfull linked list, since this reflects}{spatial relations on screen, and nonrelatives can cover each other}		var			TempGod: GodHandle;			sizeNeeded: LongInt;			errString, helpString: Str255;	begin		if ThisFull^^.Parent <> nil then			begin				PenPat(White);				RectRgn(DestRegion, PRect);				Incorporate(ThisFull);				Incorporate(ThisFull^^.Parent);				Connect(ThisFull, ThisFull^^.Parent);				PenNormal;				ClipRect(Prect);				if ThisFull^^.Parent^^.LastBorn = ThisFull then					ThisFull^^.Parent^^.LastBorn := ThisFull^^.ElderSib;				if ThisFull^^.Parent^^.FirstBorn = ThisFull then					ThisFull^^.Parent^^.FirstBorn := ThisFull^^.YoungerSib;			end; {of whitening line connecting with ThisFull's parent}		if ThisFull^^.YoungerSib <> nil then			ThisFull^^.YoungerSib^^.ElderSib := ThisFull^^.ElderSib;		if ThisFull^^.ElderSib <> nil then			ThisFull^^.ElderSib^^.YoungerSib := ThisFull^^.YoungerSib;		ThisFull^^.ElderSib := nil;		ThisFull^^.YoungerSib := nil;		ThisFull^^.Parent := nil;		SizeNeeded := LONGINT(SizeOf(God));		if (Memavail - SizeNeeded) < SafetyValve then			begin				GetIndString(errString, 128, 16);				GetIndString(helpString, 128, 4);				DisplayError(-108, errString, helpString, StopError);{was: MemoryMessage(4405, ' in Detaching pedigree', Verdict);}				GracefulDeath;			end;		TempGod := GodHandle(NewHandle(SizeOf(God)));		if MemError <> noErr then			ExitToShell;		TempGod^^.NextGod := nil;		FindLastGod;		TempGod^^.PreviousGod := theGod;		TempGod^^.Adam := ThisFull;		theGod^^.nextGod := TempGod;		theGod := TempGod;		MarkIf(ThisFull);	end; {Detach}	procedure FollowMouse (ThisFull: FullHandle);		var			mous, OldMous: Point;			Height, Width, HalfHeight, HalfWidth, VertOffset, HorizOffset: Integer;			OldDamage: Rect;			TickValue: Longint;			MaskRegion: RgnHandle;			WasOverEdge: Boolean;			TempSnap: BitMap;	begin		SetCursor(CursList[WatchCursor]^^);		TempSnap.BaseAddr := ThisFull^^.SnapHandle^;		TempSnap.rowBytes := ThisFull^^.SnapBytes;		TempSnap.Bounds := ThisFull^^.SnapBounds;		if ThisFull^^.Prec = nil then{Chosen one is already in front. No change}		else			begin {Must bring chosen one to front, after isolating it}				ThisFull^^.Prec^^.Next := ThisFull^^.Next;				if ThisFull^^.Next <> nil then					ThisFull^^.Next^^.Prec := ThisFull^^.Prec;        {Chosen one has now been isolated, still called ThisFull}				ThisFull^^.Next := SpecialFull; {This brings it to front}				SpecialFull^^.Prec := ThisFull; {This corrects old specialfull's pointer to Prec}				OldSpecialFull := SpecialFull;				SpecialFull := ThisFull; {This gives the new specialfull its proper name}				SpecialFull^^.Prec := nil;			end;		Coverer(ThisFull); {Records all damage done by ThisFull, now also Specialfull}		Child[special] := SpecialFull^^.Genome;		WasOverEdge := OverEdge(ThisFull);		Width := ThisFull^^.Surround.Right - ThisFull^^.Surround.Left;		Height := ThisFull^^.Surround.Bottom - ThisFull^^.Surround.Top;		HalfWidth := Width div 2;		HalfHeight := Height div 2;		DamageRect := ThisFull^^.Surround;		Protect;		PenPat(White);		LocalLines(ThisFull);		GetMouse(mous);		if thisfull <> nil then			begin				HorizOffset := ThisFull^^.Centre.h - mous.h;				VertOffset := ThisFull^^.Centre.v - mous.v;				ThisFull^^.Surround.Left := ThisFull^^.Centre.h - HalfWidth;				ThisFull^^.Surround.Right := ThisFull^^.Surround.Left + width;				ThisFull^^.Surround.Top := ThisFull^^.Centre.v - Halfheight;				ThisFull^^.Surround.Bottom := ThisFull^^.Surround.Top + Height;				ClipRect(PRect);				EraseRect(ThisFull^^.Surround);			end;		CopyBits(MainPtr^.PortBits, MyBitMap, Prect, Prect, srcCopy, nil);    {store background}		CopyBits(TempSnap, MainPtr^.PortBits, TempSnap.Bounds, thisFull^^.Surround, srcCopy, nil); {show chosen one in front}		PenMode(PatXor); {White is bad because it deletes other lines}		PenPat(Black);		Protect;		ThereAreLines := FALSE;		LocalLines(ThisFull);		HideCursor;		repeat			OldMous := mous;			repeat				GetMouse(mous)			until PtInRect(mous, PRect);			ClipRect(ThisFull^^.Surround);    {CopyBits(TempSnap,MainPtr^.PortBits,}{        TempSnap.Bounds,thisFull^^.Surround,srcCopy,NIL);} {Bring on new one}			SetClip(DestRegion);			if (mous.h <> OldMous.h) or (mous.v <> oldmous.v) or (not Stilldown) then				if thisfull <> nil then					begin						ThatFull^^ := ThisFull^^;						ClipRect(Prect);						TickValue := TickCount;						if mous.v > 100 then							repeat							until TickCount <> TickValue;        {an empirically suggested device for reducing flicker}						CopyBits(MyBitMap, MainPtr^.PortBits, ThisFull^^.Surround, ThisFull^^.Surround, srcCopy, nil); {Bring back old}						ThisFull^^.Centre.h := mous.h + HorizOffset;						ThisFull^^.Centre.v := mous.v + VertOffset;						ThisFull^^.Surround.Left := ThisFull^^.Centre.h - HalfWidth;						ThisFull^^.Surround.Right := ThisFull^^.Surround.Left + width;						ThisFull^^.Surround.Top := ThisFull^^.Centre.v - Halfheight;						ThisFull^^.Surround.Bottom := ThisFull^^.Surround.Top + Height;						if ThereAreLines then							begin								SetClip(DestRegion);            {TickValue:=TickCount;}{            REPEAT UNTIL TickCount<>TickValue;}								LocalLines(ThatFull); {delete old lines}							end;						ClipRect(ThisFull^^.Surround);        {TickValue:=TickCount;}{        REPEAT UNTIL TickCount<>TickValue;}						CopyBits(TempSnap, MainPtr^.PortBits, TempSnap.Bounds, thisFull^^.Surround, srcCopy, nil);                {Bring on new one}						if ThereAreLines then							begin								Protect;            {TickValue:=TickCount;}{            REPEAT UNTIL TickCount<>TickValue;}								LocalLines(ThisFull)							end					end		until not StillDown;		ShowCursor;		SetCursor(CursList[HandCursor]^^);		PenNormal;		ClipRect(Prect);		ThisFull^^.Origin.h := mous.h + HorizOffset;		ThisFull^^.Origin.v := mous.v + VertOffset;		ThisFull^^.Damaged := TRUE;{WasOverEdge}		ClipRect(Prect);		Repair;		Protect;		AllLines(rootGod);		ClipRect(Prect);	end; {FollowMouse}	procedure DrawAll;		procedure DrawSibs (ThisFull: Fullhandle);		begin			if ThisFull <> nil then				ThisFull^^.Damaged := TRUE;			if ThisFull^^.FirstBorn <> nil then				DrawSibs(ThisFull^^.FirstBorn);			if ThisFull^^.YoungerSib <> nil then				DrawSibs(ThisFull^^.YoungerSib);		end; {DrawSibs}		procedure Draw (ThisFull: FullHandle);		begin			ThisFull^^.Damaged := TRUE;			if ThisFull^^.FirstBorn <> nil then				begin					Draw(ThisFull^^.FirstBorn);					if ThisFull^^.FirstBorn <> nil then						DrawSibs(ThisFull^^.FirstBorn^^.YoungerSib)				end		end; {Draw}	begin		ClipRect(Prect);		EraseRect(Prect);		Draw(theGod^^.Adam);		Protect;		AllLines(theGod);		ClipRect(Prect);	end; {DrawAll}	procedure SpawnOne (ThisFull: FullHandle; Here: Point; var current: FullHandle);		var			TempSnap: BitMap;			Width, WidthBytes, Height, voffset: Integer;			theRect: Rect;			Interim: FullHandle;			SizeNeeded: LongInt;			errString, helpString: Str255;	begin		SetCursor(Curslist[WatchCursor]^^);		Current := Created;		Reproduce(ThisFull^^.Genome, Current^^.Genome);		Current^^.Origin := here;		Develop(Current^^.Genome, here, true);		Current^^.Surround := Margin;		AtLeast(Current^^.Surround);		with Current^^.Surround do			begin				height := bottom - top;				WidthBytes := (right - left) div 8;				while odd(WidthBytes) do					WidthBytes := WidthBytes + 1;				Width := WidthBytes * 8;				voffset := 0;				if top < PRect.top then					begin						voffset := Prect.top - top;						top := Prect.top;						bottom := top + height;					end;				if bottom > PRect.bottom then					begin						voffset := Prect.bottom - bottom;						bottom := Prect.bottom;						top := bottom - height					end;				if left < PRect.left then					begin						left := PRect.left;						right := left + width					end;				if right > Prect.right then					begin						right := Prect.right;						left := right - width					end;			end;		EraseRect(Current^^.Surround);		Framerect(Current^^.Surround);		with Current^^.Surround do			begin				Current^^.Centre.h := Left + (Right - Left) div 2;				Current^^.Centre.v := Top + (Bottom - Top) div 2			end;		Here.v := current^^.origin.v + voffset;		Here.h := Current^^.Centre.h;		DrawPic(MyPic, here, Current^^.Genome);		with Current^^.SnapBounds do			begin				left := 0;				right := Current^^.Surround.right - Current^^.Surround.left;				top := 0;				bottom := height			end;		TempSnap.Bounds := Current^^.SnapBounds;		Current^^.SnapBytes := WidthBytes;		SizeNeeded := LONGINT(WidthBytes * Height);		if (Memavail - SizeNeeded) < SafetyValve then			begin				GetIndString(errString, 128, 17);	{** v1.1 **}				GetIndString(helpString, 128, 4);				DisplayError(-108, errString, helpString, StopError);{was: MemoryMessage(4405, ' in Spawning new pedigree member', Verdict);}				GracefulDeath;			end;		Current^^.SnapHandle := NewHandle(SizeNeeded);		if MemError <> noErr then			ExitToShell;		TempSnap.BaseAddr := Current^^.SnapHandle^;		TempSnap.rowBytes := Current^^.SnapBytes;		CopyBits(MainPtr^.PortBits, TempSnap, Current^^.Surround, TempSnap.Bounds, srcCopy, nil);		Current^^.Parent := ThisFull;		Current^^.ElderSib := ThisFull^^.LastBorn;		if Current^^.ElderSib <> nil then			Current^^.ElderSib^^.YoungerSib := Current;		Current^^.LastBorn := nil;		Current^^.YoungerSib := nil;		if ThisFull^^.LastBorn = nil then			ThisFull^^.FirstBorn := Current;		ThisFull^^.LastBorn := Current;		Current^^.Next := SpecialFull; {Puts Currentfull at head of list}		SpecialFull^^.Prec := Current;  {Updates seniority pointer of previous head}		OldSpecialFull := SpecialFull;		SpecialFull := Current;  {Gives new head its proper title}		SpecialFull^^.Prec := nil; {Probably unnecessary but good form}		Child[Special] := Current^^.Genome;		MarkIf(Current);	end; {SpawnOne}	procedure Radiate (From, Goal: Point; Spokes: Integer; var Here: PointArray);		var			dx, dy, j: Integer;	begin		dx := Goal.h - From.h;		dy := Goal.v - From.v;		Here[1].h := From.h + dx;		Here[1].v := From.v + dy;		Here[2].h := From.h - dx;		Here[2].v := From.v - dy;		Here[3].h := From.h - dy;		Here[3].v := From.v + dx;		Here[4].h := From.h + dy;		Here[4].v := From.v - dx;		for j := 1 to Spokes do			begin				MoveTo(From.h, From.v);				LineTo(Here[j].h, Here[j].v)			end;	end; {Radiate}	procedure DrawOutFrom (ThisFull: FullHandle);		var			mous: Point;			square: Rect;			tickValue: LongInt;			Current, OldFull: FullHandle;			OldMous: Point;			Here: PointArray;			wid, Ht, j: Integer;			DotCursor: Cursor;	begin		SetCursor(CursList[CrossCursor]^^);		ClipRect(Prect);		if IsCovered(ThisFull) then			Redevelop(ThisFull);		if ThisFull^^.Prec = nil then{Chosen one is already in front. No change}		else			begin {Must bring chosen one to front, after isolating it}				ThisFull^^.Prec^^.Next := ThisFull^^.Next;				if ThisFull^^.Next <> nil then					ThisFull^^.Next^^.Prec := ThisFull^^.Prec;        {Chosen one has now been isolated, still called ThisFull}				ThisFull^^.Next := SpecialFull; {This brings it to front}				SpecialFull^^.Prec := ThisFull; {This corrects old specialfull's pointer to Prec}				OldSpecialFull := SpecialFull;				SpecialFull := ThisFull; {This gives the new specialfull its proper name}				SpecialFull^^.Prec := nil;			end;		GetClip(SaveRegion);		RectRgn(DestRegion, PRect);		Protect;		PenMode(PatXor);		OwnCursor(SpecialFull^^.Surround, MainPtr^.PortBits, theCursor);		SetCursor(theCursor);		repeat			GetMouse(mous);{TickValue:=TickCount;}{REPEAT UNTIL TickValue<>TickCount;}{Framerect(ThisFull^^.Surround);} {Just for flicker}		until (not StillDown) or (not PtInRect(mous, ThisFull^^.Surround));		PenNormal;		Framerect(ThisFull^^.Surround);		MarkIf(ThisFull);		Child[special] := Thisfull^^.Genome;		if StillDown then			begin				SetClip(DestRegion);				PenMode(PatXor);				Radiate(ThisFull^^.Centre, mous, Rays, Here);				while StillDown do					begin						OldMous := Mous;						GetMouse(mous);						if mous.v < Prect.top then							mous.v := Prect.top;						if ((mous.h <> OldMous.h) or (mous.v <> OldMous.v)) then {(NOT PtInRect(mous,ThisFull^^.Surround)) AND}							begin								TickValue := TickCount;								repeat								until TickValue <> TickCount;								Radiate(ThisFull^^.Centre, OldMous, Rays, Here);								TickValue := TickCount;								repeat								until TickValue <> TickCount;								if not PtInRect(mous, ThisFull^^.Surround) then									Radiate(ThisFull^^.Centre, Mous, Rays, Here)							end;					end; {WHILE loop}{Button just released}{SetCursor(CursList[WatchCursor]^^);}				Radiate(ThisFull^^.Centre, Mous, Rays, Here);				PenNormal;				j := Rays;				ClipRect(Prect);				if not PtInRect(mous, ThisFull^^.Surround) then					while j >= 1 do						begin							theCursor.data := curslist[randcursor]^^.mask;							theCursor.data[8] := 128;  {make up dot cursor}							theCursor.mask := theCursor.data;							SetCursor(theCursor);							SpawnOne(Thisfull, Here[j], Current);							j := j - 1						end				else			end;		Protect;		LocalLines(ThisFull);{EraseRect(Prect);}{AllLines(rootGod);}		ClipRect(Prect);{REPEAT  GetMouse(mous)}{    UNTIL NOT PtInRect(mous,Current^^.Surround);  The purpose of this is to keep}{    the dot cursor going until we have left the new box.  But it bombs if you move back}{    to the old box before drawing has finished}		SetCursor(CursList[DrawOutCursor]^^);	end; {DrawOutFrom}	procedure PhylogNew (Biomorph: Person);		var			MLoc: Point;			tempGod: GodHandle;			TempSnap: BitMap;			Width, Height, SizeNeeded, Avail: LongInt;			errString, helpString: Str255;	begin		EraseRect(Prect);		SizeNeeded := LONGINT(SizeOf(God));		if (Memavail - SizeNeeded) < SafetyValve then			begin				GetIndString(errString, 128, 18);		{** v1.1 **}				GetIndString(helpString, 128, 4);				DisplayError(-108, errString, helpString, StopError);{was: MemoryMessage(4405, ' in starting up new pedigree', Verdict);}				GracefulDeath;			end;		TempGod := GodHandle(NewHandle(SizeOf(God)));		if MemError <> noErr then			ExitToShell;		TempGod^^.NextGod := nil;		FindLastGod;		TempGod^^.PreviousGod := theGod;		theGod^^.nextGod := TempGod;		theGod := TempGod;		theGod^^.Adam := Created;		theGod^^.Adam^^.Genome := Biomorph;		with ScreenBits.Bounds do			begin				theGod^^.Adam^^.Origin.h := (Right - Left) div 2;				theGod^^.Adam^^.Origin.v := (Bottom - Top) div 2			end;		delayvelop(theGod^^.Adam^^.Genome, theGod^^.Adam^^.Origin);		theGod^^.Adam^^.Surround := Margin;		AtLeast(theGod^^.Adam^^.Surround);		FrameRect(theGod^^.Adam^^.Surround);		FrameInnerRect(theGod^^.Adam^^.Surround);		with theGod^^.Adam^^.Surround do			begin				height := bottom - top;				Width := (right - left) div 8;				while odd(Width) do					begin {Write('Odd Width');}						Width := Width + 1;					end			end;		with theGod^^.Adam^^.SnapBounds do			begin				left := 0;				right := theGod^^.Adam^^.Surround.right - theGod^^.Adam^^.Surround.left;				top := 0;				bottom := height			end;		TempSnap.Bounds := theGod^^.Adam^^.SnapBounds;		theGod^^.Adam^^.SnapBytes := Width;		SizeNeeded := LONGINT(Width * Height);		if ((MemAvail - SizeNeeded) < SafetyValve) or (SizeNeeded > 100000) then			begin				GetIndString(errString, 128, 19);		{** v1.1 **}				GetIndString(helpString, 128, 4);				DisplayError(-108, errString, '', CautionError);{was: MemoryMessage(4405, ' in Pedigree', Verdict);}				Exit(PhylogNew);			end;		theGod^^.Adam^^.SnapHandle := NewHandle(SizeNeeded);		if MemError <> noErr then			ExitToShell;		TempSnap.BaseAddr := theGod^^.Adam^^.SnapHandle^;		TempSnap.rowBytes := theGod^^.Adam^^.SnapBytes;		CopyBits(MainPtr^.PortBits, TempSnap, theGod^^.Adam^^.Surround, TempSnap.Bounds, srcCopy, nil);		with theGod^^.Adam^^ do			begin				Centre.h := Surround.Left + (Surround.Right - Surround.Left) div 2;				Centre.v := Surround.Top + (Surround.Bottom - Surround.Top) div 2			end;		OldSpecialFull := SpecialFull;		if SpecialFull <> nil then			SpecialFull^^.Prec := theGod^^.Adam;    													{This corrects old specialfull's pointer to Prec}		theGod^^.Adam^^.next := SpecialFull;		SpecialFull := theGod^^.Adam;		SpecialFull^^.Prec := nil;		TheMode := Phyloging;								{Changed July 1990}		EraseRect(Prect);		RectRgn(DestRegion, PRect);		DrawWholeLot(SpecialFull);		AllLines(rootGod);		ClipRect(PRect);	end; 				{PhylogNew}end.