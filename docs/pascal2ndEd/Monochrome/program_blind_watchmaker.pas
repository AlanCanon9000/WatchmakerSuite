program program_blind_watchmaker;{*********************************************************************}{*                  v1.1 Sept 1993                                   *}{*                                                                   *}{*    Disabled Mutation-Gradient menu item when segmentation off     *}{*    Call WaitNextEvent if available, else systemTask/GetNextEvent  *}{*    Remove Repeat/Until loop on save changes.                      *}{*    Added QuitConfirmed function and moved savechanges check there *}{*    Changed sleep time - when drift sweep is on, small time for bg *}{*           tasks;  other modes give lots of bg time.               *}{*********************************************************************}uses{$IFC UNDEFINED THINK_Pascal}  SegLoad,  Memory,  Folders,  Script,  Quickdraw,  ToolUtils,  Types,  Events,  Windows,  Menus,  Desk,  think_pascal,{$ENDC}  unit_engineering,  unit_globals,  unit_biomorphs,  unit_triangle,  unit_miscellaneous,  unit_error,  unit_user_interface,  unit_initialize,  unit_album,  unit_standard_get_folder,  unit_pedigree;  procedure CursorAdjust;  {    purpose         change cursors depending upon location}  var    MousePt: Point;    j: integer;    InBox: boolean;  begin    if MainPtr = frontw then      with MainPeek^ do      begin        GetMouse(MousePt);                          {  find where mouse is  }        if PtInRect(MousePt, port.portRect) then     {  if over window then  }        begin          if TheMode = Breeding then            SetCursor(CursList[BreedCursor]^^)          else if theMode = Preliminary then            SetCursor(CursList[plusCursor]^^)          else if (theMode = highlighting) or (theMode = Albuming) then            SetCursor(CursList[BlackCursor]^^)          else if theMode = randoming then            SetCursor(CursList[RandCursor]^^)          else if theMode = phyloging then            SetCursor(CursList[DrawOutCursor]^^)          else if (theMode = moving) then            SetCursor(CursList[HandCursor]^^)          else if (theMode = Detaching) then            SetCursor(CursList[ScissorCursor]^^)          else if (theMode = Killing) then            SetCursor(CursList[GunCursor]^^)          else if (theMode = Triangling) then          begin            if Naive then            begin              Naive := False;              SetCursor(CursList[BlankCursor]^^);            end            else              SetCursor(theCursor);          end          else if (theMode = engineering) then          begin            j := 0;            InBox := False;            repeat              j := j + 1;              InBox := (PtInRect(MousePt, GeneBox[j]));            until (j = 16) or Inbox;            if InBox then              case LeftRightPos(MousePt, GeneBox[j]) of                LeftThird:                  SetCursor(CursList[leftCursor]^^);                RightThird:                  SetCursor(CursList[rightCursor]^^);                MidThird:                  if (j <= 9) or (j = 11) then                    case Rung(MousePt, GeneBox[j]) of                      TopRung:                        SetCursor(CursList[UpCursor]^^);                      MidRung:                        SetCursor(CursList[EqCursor]^^);                      BottomRung:                        SetCursor(CursList[DownCursor]^^);                    end {CASE WhichRung}                  else                    SetCursor(CursList[EqCursor]^^);              end {Cases}            else              SetCursor(CursList[InjectCursor]^^);          end {engineering}          else            SetCursor(CursList[crossCursor]^^);{    else make a cross  }        end        else          SetCursor(Arrow);                     {   else make an arrow  }      end;    {IF SpecialFull<>NIL THEN MarkUp(SpecialFull);}    if Memavail < CarefulThreshold then    begin      if not WarningHasBeenGiven then        MemoryMessage(27295, ' in Creating new Pedigree origin', Verdict);      WarningHasBeenGiven := True;    end;    if Memavail > CarefulThreshold then      WarningHasBeenGiven := False;  end; { of proc CursorAdjust }  procedure WindowAdjust;  var    ActualFront, ShouldBeFront: WindowPtr;  begin    ActualFront := FrontWindow;    if theMode = PlayingBack then      ShouldBeFront := PlayBackPtr    else if not DAOn then      ShouldBeFront := MainPtr;    if (not DAOn) and (ShouldBeFront <> ActualFront) then    begin      EraseRect(ActualFront^.PortRect);      SelectWindow(ShouldBeFront);      SetPort(ShouldBeFront);    end;  end; {WindowAdjust}  procedure DoDrift;  begin    if (TheMode = Drifting) and (not SweepOn) and (PtInRect(MLoc, PRect)) then    begin      ObscureCursor;      ClipRect(PRect);      Develop(Child[Special], MidScreen, false);      ClipRect(PRect);      Snapshot(MyPic, PRect, Child[Special]);      StoreOffScreen(MainPtr^.PortRect, MyBitMap);      Reproduce(Child[Special], Child[Special]);      NActiveBoxes := NactiveBoxes + 1;      if NActiveBoxes > NBoxes then        NactiveBoxes := NBoxes;    end; {drifting}  end;  procedure DoSweep;  begin    ObscureCursor;    if DriftOne > 0 then    begin      PenPat(White);      PenSize(3, 3);      Framerect(Box[DriftOne]);    end;    PenPat(Black);    DriftOne := DriftOne + 1;    if DriftOne > NBoxes then      DriftOne := 1;    EraseRect(Box[DriftOne]);    FrameRect(Box[DriftOne]);    PenSize(1, 1);    ClipRect(Box[DriftOne]);    Child[DriftOne] := Child[Special];    Delayvelop(Child[Special], Centre[DriftOne]);    ClipRect(PRect);    {IF Fossilizing THEN write(Slides,child[special]);}    Special := DriftOne;    Reproduce(Child[Special], Child[Special]);    NActiveBoxes := NactiveBoxes + 1;    if NActiveBoxes > NBoxes then      NactiveBoxes := NBoxes;  end; {sweeping}  procedure MenuGreyAdjust;  {v1.1 Disable Mutation-gradiant if segmentation off.}  {Removed spurious drawing of menu bar when oldMode does not equal theMode.}  {Menu bar is still redrawn unnecessarily when choosing DA, though. Alun}  var    Br: boolean;    j: integer;  begin    {SetItemState(AM, 0, (TheMode <> Drifting) AND (TheMode <> Highlighting) AND (TheMode <> Albuming));  }    {Don't know why the apple menu is disabled -Alun}    OldMode := theMode;    SetItemState(FM, 1, (Album.Size < MaxAlbum) and not albumfull); {Load to Album}    SetItemState(FM, 2, True);{(theMode=Breeding) AND (NOT Fossilizing)}    {Load to SlideBox}    SetItemState(FM, 3, Special > 0); {Save Biomorph}    SetItemState(FM, 4, FileSize(Slides) > 0);    {Save Fossil File}    SetItemState(FM, 5, ((not AlbumEmpty)));{ AND (TheMode=Albuming)}    {OR (TheMode=Moving)}    SetItemState(FM, 6, (Album.Size > 0) and (not AlbumEmpty) and (TheMode = Albuming));    {Close Album}    SetItemState(EM, 6, DAon or ((Special > 0) and (TheMode = Albuming)));    SetItemState(EM, 4, (Special > 0));    SetItemState(MM, 2, Mut[1]);    Pastable := False;    if (TheMode = Albuming) and (CopiedAnimal.Gene[9] > 0) then    begin {worth checking whether looking at vacant slot}      j := 0;      repeat        j := j + 1;      until (Album.Place[j].Page = CurrentPage) and (Album.Place[j].BoxNo = Special);      if Album.member[j].Gene[9] = 0 then        Pastable := True;    end;    SetItemState(EM, 5, Pastable or ((frontwindow <> Mainptr) and      (FrontWindow <> PlaybackPtr)));    SetItemState(EM, 7, False); {-----------}    {Highlight Biomorph:-}    SetItemState(EM, 8, ((TheMode = Breeding) or (TheMode = Highlighting)) and (not DAon));    {Add to Album:-}    SetItemState(EM, 9, (((TheMode = Highlighting) or (TheMode = Engineering) or      (TheMode = Triangling) or (TheMode = Phyloging) or (TheMode = Moving) or      (TheMode = Detaching) or (TheMode = Breeding) or (TheMode = Randoming))) and      not AlbumFull and not DAon);    {Zoom:=}    SetItemState(EM, 10, (Album.Size > 0) and (not AlbumEmpty) and not DAon);    SetItemState(OM, 1, Special > 0);  {Breed}    SetItemState(OM, 2, Special > 0);  {Drift}    SetItemState(OM, 3, Special > 0);  {3 Engineering}    {4 Hopeful Monster}    {5 Zero Fossil Record}    SetItemState(OM, 6, (FossilsExist) and (theMode = Breeding));    {Replay Fossil Record}    if FossilsExist then      SetItem(MenuList[OM], 5, 'Reinitialize Fossil Record')    else      SetItem(MenuList[OM], 5, 'Initialize Fossil Record');    SetItemState(OM, 7, FossilsExist);    CheckItem(MenuList[OM], 7, Fossilizing); {Recording Fossils?}    Br := (TheMode = Breeding) or (TheMode = Highlighting) or      (TheMode = Preliminary) or (TheMode = Drifting);    SetItemState(BM, 1, Br and (NBoxes < MaxBoxes));    SetItemState(BM, 2, Br and (NRows >= 3));    SetItemState(BM, 3, Br and (NBoxes < MaxBoxes));    SetItemState(BM, 4, Br and (NCols >= 3));    SetItemState(BM, 5, theMode = Engineering);    SetItemState(BM, 6, (theMode = Engineering) and (MyPenSize > 1));    {SetItemState(BM,9,(theMode<>Triangling));}    {     SetItemState(BM,10,(theMode<>Triangling));}    {     SetItemState(BM,11,(theMode<>Triangling));}    SetItemState(PM, 1, Special > 0);    SetItemState(PM, 3, (TheMode = Moving) or (TheMode = Detaching) or      (TheMode = Phyloging) or (TheMode = Killing));    SetItemState(PM, 4, TheMode = Phyloging);    SetItemState(PM, 5, TheMode = Phyloging);    SetItemState(PM, 6, TheMode = Phyloging);    SetItemState(PM, 8, (TheMode = Moving) or (TheMode = Detaching) or      (TheMode = Phyloging) or (TheMode = Killing));    SetItemState(PM, 9, (TheMode = Moving) or (TheMode = Detaching) or      (TheMode = Phyloging) or (TheMode = Killing));    SetItemState(PM, 10, (TheMode = Moving) or (TheMode = Detaching) or      (TheMode = Phyloging) or (TheMode = Killing));    SetItemState(PM, 11, False);    {(TheMode=Moving) OR (TheMode=Detaching) OR (TheMode=Phyloging) OR (TheMode=Killing)}    SetItemState(HM, 1, True);    SetItemState(HM, 2, True);  end; {MenuGreyAdjust}(******************************************************************************}{ GetAnEvent}{}{    Get the next event in the event queue. }{    Changed for v1.1 to use WaitNextEvent if it is available}{ ******************************************************************************)  function GetAnEvent(var macEvent: EventRecord): boolean;  var    eventResult: boolean;    sleep: longint;  begin    if (gSystem.hasWNE) then    begin      (* WaitNextEvent is the preferred   call.  It handles multitasking  *)      (*   in a friendly manner.      *)      if (theMode = Drifting) and SweepOn then        sleep := 2      else        sleep := 20;      eventResult := WaitNextEvent(everyEvent, macEvent, sleep, nil);    end    else        (* WaitNextEvent is not available.  *)    begin      (*  We must use the old method of calling SystemTask and GetNextEvent.*)      SystemTask;      eventResult := GetNextEvent(everyEvent, macEvent);    end;    GetAnEvent := eventResult;  end;begin { main body of program}  MoreMasters;    {10 are called automatically by Think Pascal}  MoreMasters;    {needs to be called from CODE 1, not init segment}  MoreMasters;  Initialize;  BasicTree(topan);   {3 defaults if all else fails}  Insect(leftan);  Chess(rightan);  Insect(target);  BasicTree(CopiedAnimal);  CopiedAnimal.Gene[9] := 0;  Special := MidBox;  CountAppFiles(DocumentMessage, DocumentCount);  if DocumentCount > 0 then {at least one biomorph double-clicked}  begin    StartDocuments(DocumentCount);    if ThisMenagerie.Size > 1 then    begin      AlbumChanged := True;      DoLoad(False);      SetUpBoxes;      Special := MidBox;      Child[special] := ThisMenagerie.Member[ThisMenagerie.Size];      DoBreed;      StoreOffScreen(MainPtr^.PortRect, MyBitMap);    end    else if ThisMenagerie.Size = 1 then {only one biomorph double-clicked}    begin      Special := MidBox;      Child[Special] := ThisMenagerie.MEMBER[1];      DoBreed;      StoreoffScreen(MainPtr^.PortRect, MyBitMap);    end;    AlbumChanged := False;  end {case of biomorph double-clicked, as opposed to BW icon itself}  else {case of BW icon itself double-clicked}  begin    BasicTree(Child[Special]);    {WITH Child[Special] DO Gene[9]:=1;}    DoBreed;    {StoreoffScreen(MainPtr^.PortRect, MyBitMap);}  end;  repeat                                   { keep doing the following  }    {UnloadSeg(@DoShowBoxes);  }    {Any procedure in FrillSegment will do}    if ((theMode = Breeding) or (theMode = Highlighting)) and (frontwindow = mainptr) then    begin      GetMouse(MLoc);      j := 0;      repeat        j := j + 1      until (PtInRect(Mloc, box[j])) or (j > NBoxes);      if (j <= NBoxes) and (j <> OldBox) then      begin        if oldbox > 0 then          ShowChangedGene(child[j], child[oldbox]);        OldBox := j;      end;    end;    GetMouse(MLoc);    if (theMode = Drifting) and (SweepOn) and (PtInRect(MLoc, PRect)) and (not DAOn) then      DoSweep;    if (TheMode = Drifting) and (not SweepOn) and (PtInRect(MLoc, PRect)) and      (not (DAOn)) then      DoDrift;    WindowAdjust;    CursorAdjust;                          { update which cursor       }    MenuGreyAdjust;    if theMode = triangling then    begin      GetMouse(NowMouse);      FlickerTriangle(NowMouse);    end;    if GetAnEvent(theEvent) then      HandleEvent(theEvent);    if Finished then    begin      if AlbumChanged then        DoClose;      if FossilsToSave then      begin        DireMessage(kFossilsID, kQuittingID, Verdict, True);        if Verdict = 3 then          Finished := False; {Cancel}        if Verdict = 1 then          SaveSlides; {Yes}      end;    end;  until Finished;                          { until user is done        }  Cleanup;                                 { clean everything up       }end. { of main progr}