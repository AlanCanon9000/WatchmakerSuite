unit unit_init_exit_exhibition; 													{Program Init and Exit routines}{Unit name:  InitExitExhibition.p  }{Function:  This module contains the extra program initialization}{     routine as well as the program exit and cleanup routine.}{ History: 6/10/91 Original by Prototyper 3.0   }interface	uses{$IFC UNDEFINED THINK_Pascal}		think_pascal, ErrorsMac, Types, Memory, ToolUtils, OSUtils, SegLoad, Resources, Quickdraw, Events,  {$ENDC}		unit_pcommon_exhibition, unit_common_exhibition, {Common}		unit_putils_exhibition, unit_utils_exhibition, {General Utilities}		unit_biomorphs, unit_breed_window;	{Program initializations}	procedure ApplInit_Exhibition;	{Program exit and cleanup}	procedure ApplExit_Exhibition;implementation	procedure HMovHLock (h: handle);	begin		MoveHHi(h);		HLock(h)	end;{=======================================================}	{Routine: ApplInit_Exhibition}	{Purpose: Extra program initialization.}	{	WNE: boolean, This variable set to TRUE says the WaitNextEvent trap is available, }	{		If we want to use that trap then we do nothing to this variable.  If we do not }	{		want to use that trap, and use GetNextEvent instead, then we change this }	{		variable to FALSE. }	{	SleepValue:integer, This is only valid if WNE is true.  This is the default sleep }	{		value to use with WaitNextEvent, it is set to 40.  This can be changed to any }	{		value desired at any time. }	procedure ApplInit_Exhibition;  									{Initialization}		var			j: integer;			r: LongInt;	begin		FileMenuEnabled := true;		Dice := GetCursor(DiceID);		HMovHLock(Handle(Dice));		Hand := GetCursor(HandID);		HMovHLock(Handle(Hand));		Watch := GetCursor(WatchCursor);		HMovHLock(Handle(Watch));		GetDateTime(RandSeed);		r := rainbow;		if (r = 0) or (r > 256) then			begin				message('Please reset your monitor to 256 colours');				exittoshell;			end;		if (r = 2) or (r = 8) then			Message('If you have 8-bit (256 shades) colour, please turn it on.  The biomorphs will look so much better');		nRows := 3;		nCols := 3;		Basictree(child[5]);		BasicTree(ourHero);		MyPic.BasePtr := NewPtr(10 * PicSizeMax);		if resError = memFullErr then			exittoshell;		MyPic.MovePtr := LinPtr(MyPic.basePtr);		upregion := NewRgn;		oldBox := 0;		oldSpecial := 1;		getMouse(LastMouse);		for j := 1 to MutTypeNo do			Mut[j] := true;		theMode := Preliminary;		WNE := false;		MonsterRevert := 120;		MonsterInterval := 1;		ResetClock;		EmptiedClip;		deskScrap := false;		YesRevert := false;		YesRhythm := false;		dullRgn := NewRgn;		midRgn := NewRgn;	end;{=======================================================}	{Routine: ApplExit_Exhibition}	{Purpose: Extra program cleanup upon exit from our program.}	{	This is where left over buffers are released and any open files are closed.}	procedure ApplExit_Exhibition; 									{Exit and cleanup}	begin		disposeRgn(dullRgn);		disposeRgn(midRgn);		disposeRgn(upRegion);		DisposPtr(MyPic.BasePtr);		U_Close_BreedWindow;	end;{=======================================================}end.    																		{End of the program}