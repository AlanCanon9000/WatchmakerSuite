unit unit_dialog_helper;interface{$IFC UNDEFINED THINK_Pascal}uses  Types, Quickdraw, Dialogs;{$ENDC}procedure FrameRoundRectAroundDialogItem(theDialog: DialogPtr; itemId: integer);procedure SetTextEditAttributesForDialog(theDialog: DialogPtr);procedure ToggleCheckbox(theDialog: DialogPtr; controlId: integer);procedure SetCheckboxStateFromBoolean(dialogItem: Handle; booleanValue: boolean);procedure SetTextboxTextFromNum(dialogItem: Handle; Value: longint);function GetTextboxTextAsNum(dialogItem: Handle): longint;function GetCtrlBool(dialogItem: Handle): boolean;procedure HandleRadioButtonHit(GetSelection: DialogPtr;  StartIndex, EndIndex, ItemHit: integer);procedure InvalidateWindow(theWindow: WindowPtr);implementation{$IFC UNDEFINED THINK_Pascal}uses  Controls, TextUtils, TextEdit, Memory, QuickdrawText, Fonts, Windows;{$ENDC}procedure InvalidateWindow(theWindow: WindowPtr);var  SavePort: GrafPtr;begin  if theWindow <> nil then    begin      GetPort(SavePort);      SetPort(theWindow);      InvalRect(theWindow^.portRect);      SetPort(SavePort);    end;end;procedure SetTextEditAttributesForDialog(theDialog: DialogPtr);var  ThisEditText: TEHandle;begin  ThisEditText := DialogPeek(theDialog)^.textH;  {Get to the TE record of the inner dialog definition record}  HLock(Handle(ThisEditText));{Lock it for safety}  ThisEditText^^.txSize := 12;{TE Point size}  TextSize(12);         {Window Point size}  ThisEditText^^.txFont := systemFont;{TE Font ID}  TextFont(systemFont);     {Window Font ID}  ThisEditText^^.txFont := 0;{TE Font ID}  ThisEditText^^.fontAscent := 12;{Font ascent}  ThisEditText^^.lineHeight := 12 + 3 + 1;{Font ascent + descent + leading}  HUnLock(Handle(ThisEditText));{UnLock the handle when done}end;{Draw a rounded rectangle around the OK button}procedure FrameRoundRectAroundDialogItem(theDialog: DialogPtr; itemId: integer);var  boundingRect: Rect;  dType: integer;  dialogItem: Handle;begin  GetDItem(theDialog, itemId, dType, dialogItem, boundingRect);{Get the item handle}  SetPort(theDialog);    {Point to our dialog window}  PenSize(3, 3);        {Change pen to draw thick default outline}  InsetRect(boundingRect, -4, -4);  {Draw outside the button by 4 pixels (1? in original source-ABC)}  FrameRoundRect(boundingRect, 16, 16); {Draw the outline}  PenSize(1, 1);        {Restore the pen size to the default value}end;procedure ToggleCheckbox(theDialog: DialogPtr; controlId: integer);var  dialogItem: Handle;  dType: integer;  tempRect: Rect;begin  GetDItem(theDialog, controlId, dType, dialogItem, tempRect);  SetCtlValue(Pointer(dialogItem), 1 - GetCtlValue(Pointer(dialogItem)));end;procedure SetCheckboxStateFromBoolean(dialogItem: Handle; booleanValue: boolean);begin  if booleanValue then    SetCtlValue(Pointer(dialogItem), 1)  else    SetCtlValue(Pointer(dialogItem), 0);end;procedure SetTextboxTextFromNum(dialogItem: Handle; Value: longint);var  sTemp: Str255;begin  NumToString(Value, sTemp);  SetIText(dialogItem, sTemp);end;function GetTextboxTextAsNum(dialogItem: Handle): longint;var  sTemp: Str255;  textboxTextAsNum: LONGINT;begin  GetIText(dialogItem, sTemp);{Get the text entered}  StringToNum(sTemp, textboxTextAsNum);  GetTextboxTextAsNum := textboxTextAsNum;end;function GetCtrlBool(dialogItem: Handle): boolean;begin  GetCtrlBool := boolean(GetCtlValue(Pointer(dialogItem)));end;procedure HandleRadioButtonHit(GetSelection: DialogPtr;  StartIndex, EndIndex, ItemHit: integer);var  Index: integer;  DItem: Handle;  tempRect: Rect;  DType: integer;begin  for Index := StartIndex to EndIndex do{Clear all other radios}  begin    GetDItem(GetSelection, Index, DType, DItem, tempRect);{Get the Radio handle}    if Index = ItemHit then      SetCtlValue(Pointer(DItem), 1) {Turn the radio selection ON}    else      SetCtlValue(Pointer(DItem), 0); {Turn the radio selection OFF}  end; {for}end;end.