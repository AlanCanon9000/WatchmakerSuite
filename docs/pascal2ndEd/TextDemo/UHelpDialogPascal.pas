{ ××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××}{// UHelpDialogPascal.p}{// ×××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××× }unit UHelpDialogPascal;interface{$IFC UNDEFINED THINK_Pascal}	uses		TextUtils;{$ENDC}	procedure DoHelp;implementationuses{$IFC UNDEFINED THINK_Pascal}		Events, Types, Quickdraw, TextEdit, Dialogs, ToolUtils, Resources,    Memory, Windows, QuickdrawText, Controls, OSUtils,{$ENDC}  unit_doerroralert, unit_doupdate, unit_docrec;	const		rHelpModal = 129;		iOK = 1;		iTextUserItem = 2;		iScrollBar = 3;		iPopupMenu = 4;		eHelpDialog = 9;		eHelpDocRecord = 10;		eHelpText = 11;		eHelpPicture = 12;		rTextIntroduction = 128;		rTextCreatingText = 129;		rTextModifyHelp = 130;		rPictIntroductionBase = 128;		rPictCreatingTextBase = 129;	type		PictInfoRec = record				bounds: Rect;				pictureHdl: PicHandle;			end;		PictInfoRecPointer = ^PictInfoRec;		PictInfoRecArray = array[0..0] of PictInfoRec;		PictInfoRecArrayPtr = ^PictInfoRecArray;		DocRecord = record				editRecHdl: TEHandle;				scrollbarHdl: ControlHandle;				pictCount: integer;				pictInfoRecPtr: PictInfoRecArrayPtr;			end;		DocRecordPtr = ^DocRecord;		DocRecordHandle = ^DocRecordPtr;	var		gTextResourceID: integer;		gPictResourceBaseID: integer;		gSavedClipRgn: RgnHandle;	procedure CloseHelp (modalDlgPtr: DialogPtr; oldPort: GrafPtr);	forward;	procedure DrawHelp (modalDlgPtr: DialogPtr; theItem: integer);	forward;	function GetText (modalDlgPtr: DialogPtr; textResourceID: integer; viewRect: Rect): boolean;	forward;	function GetPictureInfo (modalDlgPtr: DialogPtr; firstPictID: integer): boolean;	forward;	procedure HandleScrollBar (modalDlgPtr: DialogPtr; thePart: integer; mouseXY: Point);	forward;	procedure ActionProcedure (scrollbarHdl: ControlHandle; partCode: integer);	forward;	procedure ScrollTextAndPicts (modalDlgPtr: DialogPtr);	forward;	procedure DrawPictures (modalDlgPtr: DialogPtr; var updateRect: Rect);	forward;	function HelpDialogFilter (modalDlgPtr: DialogPtr; var theEvent: EventRecord; var itemHit: integer): boolean;	forward;	procedure DoHelp;		var			modalDlgPtr: DialogPtr;			docRecHdl: DocRecordHandle;			oldPort: GrafPtr;			itemType, itemHit, menuItem: integer;			itemHdl: Handle;			userItemRect, destRect, viewRect, itemRect: Rect;	begin		gSavedClipRgn := nil;		modalDlgPtr := GetNewDialog(rHelpModal, nil, WindowPtr(-1));		if (modalDlgPtr = nil) then			begin				DoErrorAlert(eHelpDialog);				Exit(DoHelp);			end;		docRecHdl := DocRecordHandle(NewHandle(sizeof(DocRecord)));		if (docRecHdl = nil) then			begin				DoErrorAlert(eHelpDocRecord);				DisposeDialog(modalDlgPtr);				Exit(DoHelp);			end;		SetWRefCon(modalDlgPtr, longint(docRecHdl));		GetPort(oldPort);		SetPort(modalDlgPtr);		GetDItem(modalDlgPtr, iTextUserItem, itemType, itemHdl, userItemRect);		SetDItem(modalDlgPtr, iTextUserItem, itemType, Handle(@DrawHelp), userItemRect);		GetDItem(modalDlgPtr, iScrollBar, itemType, itemHdl, itemRect);		docRecHdl^^.scrollbarHdl := ControlHandle(itemHdl);		InsetRect(userItemRect, kTextInset, kTextInset div 2);		destRect := userItemRect;		viewRect := userItemRect;		docRecHdl^^.editRecHdl := TEStylNew(destRect, viewRect);		docRecHdl^^.pictInfoRecPtr := nil;		gTextResourceID := rTextIntroduction;		gPictResourceBaseID := rPictIntroductionBase;		if not (GetText(modalDlgPtr, gTextResourceID, viewRect)) then			begin				CloseHelp(modalDlgPtr, oldPort);				Exit(DoHelp);			end;		if not (GetPictureInfo(modalDlgPtr, gPictResourceBaseID)) then			begin				CloseHelp(modalDlgPtr, oldPort);				Exit(DoHelp);			end;		gSavedClipRgn := NewRgn;		ShowWindow(modalDlgPtr);		repeat			ModalDialog(ModalFilterProcPtr(@HelpDialogFilter), itemHit);			if (itemHit = iPopupMenu) then				begin					SetCtlValue(docRecHdl^^.scrollbarHdl, 0);					GetDItem(modalDlgPtr, iPopupMenu, itemType, itemHdl, itemRect);					menuItem := GetCtlValue(ControlHandle(itemHdl));					case (menuItem) of						1: 							begin								gTextResourceID := rTextIntroduction;								gPictResourceBaseID := rPictIntroductionBase;							end;						2: 							begin								gTextResourceID := rTextCreatingText;								gPictResourceBaseID := rPictCreatingTextBase;							end;						3: 							begin								gTextResourceID := rTextModifyHelp;							end;					end;				{of case statement}					if not (GetText(modalDlgPtr, gTextResourceID, viewRect)) then						begin							CloseHelp(modalDlgPtr, oldPort);							Exit(DoHelp);						end;					if not (GetPictureInfo(modalDlgPtr, gPictResourceBaseID)) then						begin							CloseHelp(modalDlgPtr, oldPort);							Exit(DoHelp);						end;					DrawPictures(modalDlgPtr, viewRect);				end;		until (itemHit = iOK);		CloseHelp(modalDlgPtr, oldPort);		Exit(DoHelp);	end;		{of procedure DoHelp}{ ×××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××× CloseHelp }	procedure CloseHelp (modalDlgPtr: DialogPtr; oldPort: GrafPtr);		var			docRecHdl: DocRecordHandle;			editRecHdl: TEHandle;			a: integer;	begin		docRecHdl := DocRecordHandle(GetWRefCon(modalDlgPtr));		editRecHdl := docRecHdl^^.editRecHdl;		if (gSavedClipRgn <> nil) then			DisposeRgn(gSavedClipRgn);		if (docRecHdl^^.editRecHdl <> nil) then			TEDispose(docRecHdl^^.editRecHdl);		if (docRecHdl^^.pictInfoRecPtr <> nil) then			begin				for a := 0 to (docRecHdl^^.pictCount - 1) do					ReleaseResource(Handle(docRecHdl^^.pictInfoRecPtr^[a].pictureHdl));				DisposePtr(Ptr(docRecHdl^^.pictInfoRecPtr));			end;		DisposeHandle(Handle(docRecHdl));		DisposeDialog(modalDlgPtr);		SetPort(oldPort);	end;		{of procedure CloseHelp}{ ××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××× DrawHelp }	procedure DrawHelp (modalDlgPtr: DialogPtr; theItem: integer);		var			oldPenState: PenState;			itemHdl: Handle;			itemRect, viewRect: Rect;			itemType, buttonOval: integer;			docRecHdl: DocRecordHandle;			editRecHdl: TEHandle;	begin		GetPenState(oldPenState);		GetDItem(modalDlgPtr, iTextUserItem, itemType, itemHdl, itemRect);		InsetRect(itemRect, 1, 1);		BackColor(whiteColor);		FillRect(itemRect, white);		InsetRect(itemRect, -1, -1);		FrameRect(itemRect);		TextFont(0);		MoveTo(13, 309);		DrawString('Topic:');		GetDItem(modalDlgPtr, iOK, itemType, itemHdl, itemRect);		InsetRect(itemRect, -4, -4);		buttonOval := (itemRect.bottom - itemRect.top) div 2 + 2;		ForeColor(blackColor);		PenPat(black);		PenSize(3, 3);		FrameRoundRect(itemRect, buttonOval, buttonOval);		docRecHdl := DocRecordHandle(GetWRefCon(modalDlgPtr));		editRecHdl := docRecHdl^^.editRecHdl;		viewRect := editRecHdl^^.viewRect;		TEUpdate(viewRect, editRecHdl);		DrawPictures(modalDlgPtr, viewRect);		SetPenState(oldPenState);	end;		{of procedure DrawHelp}{ ×××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××× GetText }	function GetText (modalDlgPtr: DialogPtr; textResourceID: integer; viewRect: Rect): boolean;		var			docRecHdl: DocRecordHandle;			editRecHdl: TEHandle;			helpTextHdl: Handle;			stylScrpRecHdl: StScrpHandle;			numberOfLines, heightOfText, heightToScroll: integer;	begin		docRecHdl := DocRecordHandle(GetWRefCon(modalDlgPtr));		editRecHdl := docRecHdl^^.editRecHdl;		TESetSelect(0, 32767, editRecHdl);		TEDelete(editRecHdl);		editRecHdl^^.destRect := editRecHdl^^.viewRect;		SetCtlValue(docRecHdl^^.scrollbarHdl, 0);		helpTextHdl := GetResource('TEXT', textResourceID);		if (helpTextHdl = nil) then			begin				DoErrorAlert(eHelpText);				GetText := false;			end;		stylScrpRecHdl := StScrpHandle(GetResource('styl', textResourceID));		if (stylScrpRecHdl = nil) then			begin				DoErrorAlert(eHelpText);				GetText := false;			end;		TEStylInsert(helpTextHdl^, GetHandleSize(helpTextHdl), stylScrpRecHdl, editRecHdl);		ReleaseResource(helpTextHdl);		ReleaseResource(Handle(stylScrpRecHdl));		numberOfLines := editRecHdl^^.nLines;		heightOfText := TEGetHeight(longint(numberOfLines), 1, editRecHdl);		if (heightOfText > (viewRect.bottom - viewRect.top)) then			begin				heightToScroll := TEGetHeight(longint(numberOfLines), 1, editRecHdl) - (viewRect.bottom - viewRect.top);				SetCtlMax(docRecHdl^^.scrollbarHdl, heightToScroll);				HiliteControl(docRecHdl^^.scrollbarHdl, 0);			end		else			begin				HiliteControl(docRecHdl^^.scrollbarHdl, 255);			end;		GetText := true;	end;		{of function GetText}{ ××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××× GetPictureInfo }	function GetPictureInfo (modalDlgPtr: DialogPtr; firstPictID: integer): boolean;		var			docRecHdl: DocRecordHandle;			editRecHdl: TEHandle;			textHdl: Handle;			offset, textSize: longint;			numberOfPicts, a, lineHeight, fontAscent: integer;			optionSpace: array[1..1] of SignedByte;			pictInfoPtr: PictInfoRecArrayPtr;			picturePoint: Point;			whatStyle: TextStyle;	begin		optionSpace[1] := SignedByte($CA);		docRecHdl := DocRecordHandle(GetWRefCon(modalDlgPtr));		if (docRecHdl^^.pictInfoRecPtr <> nil) then			begin				for a := 0 to (docRecHdl^^.pictCount - 1) do					ReleaseResource(Handle(docRecHdl^^.pictInfoRecPtr^[a].pictureHdl));				DisposePtr(Ptr(docRecHdl^^.pictInfoRecPtr));				docRecHdl^^.pictInfoRecPtr := nil;			end;		docRecHdl^^.pictCount := 0;		editRecHdl := docRecHdl^^.editRecHdl;		textHdl := editRecHdl^^.hText;		textSize := GetHandleSize(textHdl);		offset := 0;		numberOfPicts := 0;		HLock(textHdl);		offset := Munger(textHdl, offset, @optionSpace[1], 1, nil, 0);		while ((offset >= 0) and (offset <= textSize)) do			begin				numberOfPicts := numberOfPicts + 1;				offset := offset + 1;				offset := Munger(textHdl, offset, @optionSpace[1], 1, nil, 0);			end;		if (numberOfPicts = 0) then			begin				HUnlock(textHdl);				GetPictureInfo := true;			end;		pictInfoPtr := PictInfoRecArrayPtr(NewPtr(sizeof(PictInfoRec) * numberOfPicts));		docRecHdl^^.pictInfoRecPtr := pictInfoPtr;		offset := longint(0);		for a := 0 to (numberOfPicts - 1) do			begin				pictInfoPtr^[a].pictureHdl := GetPicture(firstPictID + a);				if (pictInfoPtr^[a].pictureHdl = nil) then					begin						DoErrorAlert(eHelpPicture);						GetPictureInfo := false;					end;				offset := Munger(textHdl, offset, @optionSpace[1], 1, nil, 0);				picturePoint := TEGetPoint(integer(offset), editRecHdl);				TEGetStyle(offset, whatStyle, lineHeight, fontAscent, editRecHdl);				picturePoint.v := picturePoint.v - lineHeight;				offset := offset + 1;				pictInfoPtr^[a].bounds := pictInfoPtr^[a].pictureHdl^^.picFrame;				OffsetRect(pictInfoPtr^[a].bounds, ((editRecHdl^^.destRect.right + editRecHdl^^.destRect.left) - (pictInfoPtr^[a].bounds.right + pictInfoPtr^[a].bounds.left)) div 2, -pictInfoPtr^[a].bounds.top + picturePoint.v);			end;		docRecHdl^^.pictCount := a;		HUnlock(textHdl);		GetPictureInfo := true;	end;		{of function GetPictureInfo}{ ×××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××× HandleScrollBar }	procedure HandleScrollBar (modalDlgPtr: DialogPtr; thePart: integer; mouseXY: Point);		var			docRecHdl: DocRecordHandle;			ignored: OSErr;	begin		docRecHdl := DocRecordHandle(GetWRefCon(modalDlgPtr));		if (thePart = inThumb) then			begin				if (TrackControl(docRecHdl^^.scrollbarHdl, mouseXY, nil) = noErr) then					ScrollTextAndPicts(modalDlgPtr);			end		else			ignored := TrackControl(docRecHdl^^.scrollbarHdl, mouseXY, ProcPtr(@ActionProcedure));	end;		{of function GetPictureInfo}{ ×××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××× ActionProcedure }	procedure ActionProcedure (scrollbarHdl: ControlHandle; partCode: integer);		var			docRecHdl: DocRecordHandle;			modalDlgPtr: DialogPtr;			editRecHdl: TEHandle;			delta, oldValue, offset, lineHeight, fontAscent: integer;			thePoint: Point;			viewRect: Rect;			style: TextStyle;	begin		if (partCode <> 0) then			begin				modalDlgPtr := scrollbarHdl^^.contrlOwner;				docRecHdl := DocRecordHandle(GetWRefCon(modalDlgPtr));				editRecHdl := docRecHdl^^.editRecHdl;				viewRect := editRecHdl^^.viewRect;				thePoint.h := viewRect.left + kTextInset;				case (partCode) of					inUpButton:						begin							thePoint.v := viewRect.top - 4;							offset := TEGetOffset(thePoint, editRecHdl);							thePoint := TEGetPoint(offset, editRecHdl);							TEGetStyle(offset, style, lineHeight, fontAscent, editRecHdl);							delta := thePoint.v - lineHeight - viewRect.top;						end;					inDownButton:						begin							thePoint.v := viewRect.bottom + 2;							offset := TEGetOffset(thePoint, editRecHdl);							thePoint := TEGetPoint(offset, editRecHdl);							delta := thePoint.v - viewRect.bottom;						end;					inPageUp:						begin							thePoint.v := viewRect.top + 2;							offset := TEGetOffset(thePoint, editRecHdl);							thePoint := TEGetPoint(offset, editRecHdl);							TEGetStyle(offset, style, lineHeight, fontAscent, editRecHdl);							thePoint.v := thePoint.v + lineHeight - fontAscent;							thePoint.v := thePoint.v - viewRect.bottom - viewRect.top;							offset := TEGetOffset(thePoint, editRecHdl);							thePoint := TEGetPoint(offset, editRecHdl);							TEGetStyle(offset, style, lineHeight, fontAscent, editRecHdl);							delta := thePoint.v - viewRect.top;							if (offset = 0) then								delta := delta - lineHeight;						end;					inPageDown:						begin							thePoint.v := viewRect.bottom - 2;							offset := TEGetOffset(thePoint, editRecHdl);							thePoint := TEGetPoint(offset, editRecHdl);							TEGetStyle(offset, style, lineHeight, fontAscent, editRecHdl);							thePoint.v := thePoint.v - fontAscent;							thePoint.v := thePoint.v + viewRect.bottom - viewRect.top;							offset := TEGetOffset(thePoint, editRecHdl);							thePoint := TEGetPoint(offset, editRecHdl);							TEGetStyle(offset, style, lineHeight, fontAscent, editRecHdl);							delta := thePoint.v - lineHeight - viewRect.bottom;							if (offset = editRecHdl^^.teLength) then								delta := delta + lineHeight;						end;				end;				{of case statement}				oldValue := GetCtlValue(scrollbarHdl);				if (((delta < 0) and (oldValue > 0)) or ((delta > 0) and (oldValue < GetCtlMax(scrollbarHdl)))) then					begin						GetClip(gSavedClipRgn);						ClipRect(modalDlgPtr^.portRect);						SetCtlValue(scrollbarHdl, oldValue + delta);						SetClip(gSavedClipRgn);					end;				ScrollTextAndPicts(modalDlgPtr);			end;	end;		{of procedure ActionProcedure}{ ××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××× ScrollTextAndPicts }	procedure ScrollTextAndPicts (modalDlgPtr: DialogPtr);		var			docRecHdl: DocRecordHandle;			editRecHdl: TEHandle;			scrollDistance, oldScroll: integer;			updateRect: Rect;	begin		docRecHdl := DocRecordHandle(GetWRefCon(modalDlgPtr));		editRecHdl := docRecHdl^^.editRecHdl;		oldScroll := editRecHdl^^.viewRect.top - editRecHdl^^.destRect.top;		scrollDistance := oldScroll - GetCtlValue(docRecHdl^^.scrollbarHdl);		if (scrollDistance = 0) then			Exit(ScrollTextAndPicts);		TEScroll(0, scrollDistance, editRecHdl);		if (docRecHdl^^.pictCount = 0) then			Exit(ScrollTextAndPicts);		updateRect := editRecHdl^^.viewRect;		if (scrollDistance > 0) then			begin				if (scrollDistance < (updateRect.bottom - updateRect.top)) then					updateRect.bottom := updateRect.top + scrollDistance;			end		else			begin				if (-scrollDistance < (updateRect.bottom - updateRect.top)) then					updateRect.top := updateRect.bottom + scrollDistance;			end;		DrawPictures(modalDlgPtr, updateRect);	end;		{of procedure ScrollTextAndPicts}{ ××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××× DrawPictures }	procedure DrawPictures (modalDlgPtr: DialogPtr; var updateRect: Rect);		var			docRecHdl: DocRecordHandle;			editRecHdl: TEHandle;			pictCount, pictIndex, vOffset: integer;			thePictHdl: PicHandle;			pictLocRect, dummyRect: Rect;	begin		docRecHdl := DocRecordHandle(GetWRefCon(modalDlgPtr));		editRecHdl := docRecHdl^^.editRecHdl;		vOffset := editRecHdl^^.destRect.top - editRecHdl^^.viewRect.top - kTextInset;		pictCount := docRecHdl^^.pictCount;		for pictIndex := 0 to (pictCount - 1) do			begin				pictLocRect := docRecHdl^^.pictInfoRecPtr^[pictIndex].bounds;				OffsetRect(pictLocRect, 0, vOffset);				if (SectRect(pictLocRect, updateRect, dummyRect)) then					begin						thePictHdl := docRecHdl^^.pictInfoRecPtr^[pictIndex].pictureHdl;						LoadResource(Handle(thePictHdl));						HLock(Handle(thePictHdl));						GetClip(gSavedClipRgn);						ClipRect(updateRect);						DrawPicture(thePictHdl, pictLocRect);						SetClip(gSavedClipRgn);						HUnlock(Handle(thePictHdl));					end;			end;	end;		{of procedure DrawPictures}{ ××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××× HelpDialogFilter }	function HelpDialogFilter (modalDlgPtr: DialogPtr; var theEvent: EventRecord; var itemHit: integer): boolean;		var			docRecHdl: DocRecordHandle;			handledEvent: boolean;			itemType, thePart: integer;			charCode: char;			itemRect: Rect;			itemHdl: Handle;			mouseXY: Point;			finalTicks: LONGINT;			controlHdl: ControlHandle;	begin		handledEvent := false;		if ((theEvent.what = updateEvt) and (WindowPtr(theEvent.message) <> modalDlgPtr)) then			begin				DoUpdate(theEvent);			end		else			begin				case (theEvent.what) of					keyDown, autoKey: 						begin							charCode := char(BAnd(theEvent.message, charCodeMask));							if ((charCode = char(kReturn)) or (charCode = char(kEnter))) then								begin									GetDItem(modalDlgPtr, iOK, itemType, itemHdl, itemRect);									HiliteControl(ControlHandle(itemHdl), inButton);									Delay(10, finalTicks);									HiliteControl(ControlHandle(itemHdl), 0);									handledEvent := true;									itemHit := iOK;								end;						end;					mouseDown: 						begin							mouseXY := theEvent.where;							GlobalToLocal(mouseXY);							thePart := FindControl(mouseXY, modalDlgPtr, controlHdl);							docRecHdl := DocRecordHandle(GetWRefCon(modalDlgPtr));							if (controlHdl = docRecHdl^^.scrollbarHdl) then								begin									HandleScrollBar(modalDlgPtr, thePart, mouseXY);									itemHit := iScrollBar;									handledEvent := true;								end;						end;				end;				{of case statement}			end;		HelpDialogFilter := handledEvent;	end;		{of function HelpDialogFilter}end.	{of unit HelpDialogPascal}{ ×××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××× }