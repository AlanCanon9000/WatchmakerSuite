{Created: Friday, September 15, 1989 at 5:01 PM	SANE.p	Pascal Interface to the Macintosh Libraries	Copyright Apple Computer, Inc.	1985-1991	All rights reserved    This file is used in these builds: ROM System	Change History (most recent first):		 <3>	 2/17/92	MH		Move def on Extended80 to types.p, and include types.p		 <2>	  8/8/91	JL		Updated Copyright.	To Do:}	UNIT SANE;	INTERFACE        USES Types, Traps;CONST{*======================================================================* *	The interface specific to the software SANE library    * *======================================================================*}Invalid = 1;Underflow = 2;Overflow = 4;DivByZero = 8;Inexact = 16;IEEEDefaultEnv = 0; 	{IEEE-default floating-point environment constant}{*======================================================================* *	The common interface for the SANE library	 * *======================================================================*}DecStrLen = 255;SigDigLen = 20; 		{for 68K; use 28 in 6502 SANE}TYPERelOp = (GreaterThan,LessThan,EqualTo,Unordered);NumClass = (SNaN,QNaN,Infinite,ZeroNum,NormalNum,DenormalNum);RoundDir = (ToNearest,Upward,Downward,TowardZero);RoundPre = (ExtPrecision,DblPrecision,RealPrecision);DecimalKind = (FloatDecimal,FixedDecimal);{*======================================================================**  The interface specific to the software SANE library	  **======================================================================*}Exception = INTEGER;Environment = INTEGER;Extended96 = ARRAY [0..5] OF INTEGER;MiscHaltInfo = RECORD	HaltExceptions: INTEGER;	PendingCCR: INTEGER;	PendingD0: LONGINT;	END;{*======================================================================**  The common interface for the SANE library	**======================================================================*}DecStr = STRING[DecStrLen];DecForm = RECORD	style: DecimalKind;	digits: INTEGER;	END;Decimal = RECORD	sgn: 0..1;	exp: INTEGER;	sig: STRING[SigDigLen];	END;CStrPtr = ^CHAR;FUNCTION X96toX80(x: Extended): extended80;FUNCTION X80toX96(x: extended80): Extended;{ sine }FUNCTION Sin(x: Extended): Extended;FUNCTION Cos(x: Extended): Extended;FUNCTION ArcTan(x: Extended): Extended;FUNCTION Exp(x: Extended): Extended;FUNCTION Ln(x: Extended): Extended;FUNCTION Log2(x: Extended): Extended;FUNCTION Ln1(x: Extended): Extended;FUNCTION Exp2(x: Extended): Extended;FUNCTION Exp1(x: Extended): Extended;FUNCTION Tan(x: Extended): Extended;{ return halt vector }FUNCTION GetHaltVector: LONGINT;PROCEDURE SetHaltVector(v: LONGINT);{*======================================================================**  The common interface for the SANE library	**======================================================================*}{---------------------------------------------------* Conversions between numeric binary types.---------------------------------------------------}FUNCTION Num2Integer(x: Extended): INTEGER;FUNCTION Num2Longint(x: Extended): LONGINT;FUNCTION Num2Real(x: Extended): real;FUNCTION Num2Double(x: Extended): DOUBLE;FUNCTION Num2Extended(x: Extended): Extended;FUNCTION Num2Comp(x: Extended): Comp;PROCEDURE Num2Dec(f: decform;x: Extended;VAR d: decimal);FUNCTION Dec2Num(d: decimal): Extended;PROCEDURE Num2Str(f: decform;x: Extended;VAR s: DecStr);FUNCTION Str2Num(s: DecStr): Extended;PROCEDURE Str2Dec(s: DecStr;VAR Index: INTEGER;VAR d: decimal;VAR ValidPrefix: BOOLEAN);PROCEDURE CStr2Dec(s: CStrPtr;VAR Index: INTEGER;VAR d: decimal;VAR ValidPrefix: BOOLEAN);PROCEDURE Dec2Str(f: decform;d: decimal;VAR s: DecStr);FUNCTION Remainder(x: Extended;y: Extended;VAR quo: INTEGER): Extended;FUNCTION Rint(x: Extended): Extended;FUNCTION Scalb(n: INTEGER;x: Extended): Extended;FUNCTION Logb(x: Extended): Extended;FUNCTION CopySign(x: Extended;y: Extended): Extended;FUNCTION NextReal(x: real;y: real): real;FUNCTION NextDouble(x: DOUBLE;y: DOUBLE): DOUBLE;FUNCTION NextExtended(x: Extended;y: Extended): Extended;FUNCTION XpwrI(x: Extended;i: INTEGER): Extended;FUNCTION XpwrY(x: Extended;y: Extended): Extended;FUNCTION Compound(r: Extended;n: Extended): Extended;FUNCTION Annuity(r: Extended;n: Extended): Extended;FUNCTION RandomX(VAR x: Extended): Extended;FUNCTION ClassReal(x: real): NumClass;FUNCTION ClassDouble(x: DOUBLE): NumClass;FUNCTION ClassComp(x: Comp): NumClass;FUNCTION ClassExtended(x: Extended): NumClass;FUNCTION SignNum(x: Extended): INTEGER;FUNCTION NAN(i: INTEGER): Extended;PROCEDURE SetException(e: Exception;b: BOOLEAN);FUNCTION TestException(e: Exception): BOOLEAN;PROCEDURE SetHalt(e: Exception;b: BOOLEAN);FUNCTION TestHalt(e: Exception): BOOLEAN;PROCEDURE SetRound(r: RoundDir);FUNCTION GetRound: RoundDir;PROCEDURE SetPrecision(p: RoundPre);FUNCTION GetPrecision: RoundPre;PROCEDURE SetEnvironment(e: environment);PROCEDURE GetEnvironment(VAR e: environment);PROCEDURE ProcEntry(VAR e: environment);PROCEDURE ProcExit(e: environment);FUNCTION Relation(x: Extended;y: Extended): RelOp;IMPLEMENTATIONFUNCTION Num2Integer(x: Extended): INTEGER; BEGIN Num2Integer := 0 END;FUNCTION Num2Longint(x: Extended): LONGINT; BEGIN Num2Longint := 0 END;FUNCTION Num2Real(x: Extended): real; BEGIN  Num2Real:= 0 END;FUNCTION Num2Double(x: Extended): DOUBLE; BEGIN Num2Double := 0 END;FUNCTION Num2Extended(x: Extended): Extended; BEGIN Num2Extended := 0 END;FUNCTION Num2Comp(x: Extended): Comp; BEGIN Num2Comp := 0 END;PROCEDURE Num2Dec(f: decform;x: Extended;VAR d: decimal); BEGIN END;FUNCTION Dec2Num(d: decimal): Extended; BEGIN Dec2Num := 0 END;PROCEDURE Num2Str(f: decform;x: Extended;VAR s: DecStr); BEGIN END;FUNCTION Str2Num(s: DecStr): Extended; BEGIN Str2Num := 0 END;PROCEDURE Str2Dec(s: DecStr;VAR Index: INTEGER;VAR d: decimal;VAR ValidPrefix: BOOLEAN); BEGIN END;PROCEDURE CStr2Dec(s: CStrPtr;VAR Index: INTEGER;VAR d: decimal;VAR ValidPrefix: BOOLEAN); BEGIN END;PROCEDURE Dec2Str(f: decform;d: decimal;VAR s: DecStr); BEGIN END;FUNCTION Remainder(x: Extended;y: Extended;VAR quo: INTEGER): Extended; BEGIN Remainder := 0 END;FUNCTION Rint(x: Extended): Extended; BEGIN Rint := 0 END;FUNCTION Scalb(n: INTEGER;x: Extended): Extended; BEGIN Scalb := 0 END;FUNCTION Logb(x: Extended): Extended; BEGIN Logb := 0 END;FUNCTION CopySign(x: Extended;y: Extended): Extended; BEGIN CopySign := 0 END;FUNCTION NextReal(x: real;y: real): real; BEGIN NextReal := 0 END;FUNCTION NextDouble(x: DOUBLE;y: DOUBLE): DOUBLE; BEGIN NextDouble := 0 END;FUNCTION NextExtended(x: Extended;y: Extended): Extended; BEGIN NextExtended := 0 END;FUNCTION XpwrI(x: Extended;i: INTEGER): Extended; BEGIN XpwrI := 0 END;FUNCTION XpwrY(x: Extended;y: Extended): Extended; BEGIN XpwrY := 0 END;FUNCTION Compound(r: Extended;n: Extended): Extended; BEGIN Compound := 0 END;FUNCTION Annuity(r: Extended;n: Extended): Extended; BEGIN Annuity := 0 END;FUNCTION RandomX(VAR x: Extended): Extended; BEGIN RandomX := 0 END;FUNCTION ClassReal(x: real): NumClass; BEGIN ClassReal := NormalNum END;FUNCTION ClassDouble(x: DOUBLE): NumClass; BEGIN ClassDouble := NormalNum END;FUNCTION ClassComp(x: Comp): NumClass; BEGIN ClassComp := NormalNum END;FUNCTION ClassExtended(x: Extended): NumClass; BEGIN ClassExtended := NormalNum END;FUNCTION SignNum(x: Extended): INTEGER; BEGIN SignNum := 0 END;FUNCTION NAN(i: INTEGER): Extended; BEGIN NAN := 0 END;PROCEDURE SetException(e: Exception;b: BOOLEAN); BEGIN END;FUNCTION TestException(e: Exception): BOOLEAN; BEGIN TestException := false END;PROCEDURE SetHalt(e: Exception;b: BOOLEAN); BEGIN END;FUNCTION TestHalt(e: Exception): BOOLEAN; BEGIN TestHalt := false END;PROCEDURE SetRound(r: RoundDir); BEGIN END;FUNCTION GetRound: RoundDir; BEGIN GetRound := TowardZero END;PROCEDURE SetPrecision(p: RoundPre); BEGIN END;FUNCTION GetPrecision: RoundPre; BEGIN GetPrecision := ExtPrecision END;PROCEDURE SetEnvironment(e: environment); BEGIN END;PROCEDURE GetEnvironment(VAR e: environment); BEGIN END;PROCEDURE ProcEntry(VAR e: environment); BEGIN END;PROCEDURE ProcExit(e: environment); BEGIN END;FUNCTION Relation(x: Extended;y: Extended): RelOp; BEGIN Relation := EqualTo END;FUNCTION X96toX80(x: Extended): extended80; BEGIN X96toX80 := 0 END;FUNCTION X80toX96(x: extended80): Extended; BEGIN X80toX96 := 0 END;{ sine }FUNCTION Sin(x: Extended): Extended; BEGIN Sin := 0 END;FUNCTION Cos(x: Extended): Extended; BEGIN Cos := 0 END;FUNCTION ArcTan(x: Extended): Extended; BEGIN ArcTan := 0 END;FUNCTION Exp(x: Extended): Extended; BEGIN Exp := 0 END;FUNCTION Ln(x: Extended): Extended; BEGIN Ln := 0 END;FUNCTION Log2(x: Extended): Extended; BEGIN Log2 := 0 END;FUNCTION Ln1(x: Extended): Extended; BEGIN Ln1 := 0 END;FUNCTION Exp2(x: Extended): Extended; BEGIN Exp2 := 0 END;FUNCTION Exp1(x: Extended): Extended; BEGIN Exp1 := 0 END;FUNCTION Tan(x: Extended): Extended; BEGIN Tan := 0 END;{ return halt vector }FUNCTION GetHaltVector: LONGINT; BEGIN GetHaltVector := 0 END;PROCEDURE SetHaltVector(v: LONGINT); BEGIN END;END.