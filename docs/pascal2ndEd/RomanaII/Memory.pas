{Created: Saturday, July 27, 1991 at 9:41 PM Memory.p Pascal Interface to the Macintosh Libraries  Copyright Apple Computer, Inc. 1985-1992  All rights reserved	Change History (most recent first):		<10>	10/16/92	DTY		Add BlockMoveData.		 <9>	 7/30/91	JL		Updated Copyright.		 <8>	  3/1/91	ngk		Fixed double semicolon syntax error that DSG refuses to fix.		 <7>	 1/27/91	LN		Checked in Database generate file from DSG.		 <6>	12/14/90	dba		<JDR> add Translate24To32, low-level memory control routines,									and debugger support routines; also use more UNIV		 <5>	 11/5/90	DFH		Added new names for Temporary Memory calls.		 <4>	 11/4/90	dba		add calls and spellings that were previously only in the C .h									file: ApplicationZone, MaxBlockSys, NewEmptyHandleSys, HLockHi,									TempNewHandle, CompactMemSys, PurgeMemSys, FreeMemSys,									ReserveMem, ReserveMemSys, MaxMemSys, DisposePtr, DisposeHandle,									ReallocateHandle		<3>		 10/3/90	JAL		Added** 1.1	ngk 05/17/1989 Added NewHandleSys, NewPtrSys, etc interface** 1.0	CCH 11/17/1988 Adding to EASE.} UNIT Memory; INTERFACE USES Types;CONSTmaxSize = $800000;	{Max data block size is 8 megabytes}defaultPhysicalEntryCount = 8;{ values returned from the GetPageState function }kPageInMemory = 0;kPageOnDisk = 1;kNotPaged = 2;TYPESize = LONGINT;		{ size of a block in bytes }THz = ^Zone;Zone = RECORD bkLim: Ptr; purgePtr: Ptr; hFstFree: Ptr; zcbFree: LONGINT; gzProc: ProcPtr; moreMast: INTEGER; flags: INTEGER; cntRel: INTEGER; maxRel: INTEGER; cntNRel: INTEGER; maxNRel: INTEGER; cntEmpty: INTEGER; cntHandles: INTEGER; minCBFree: LONGINT; purgeProc: ProcPtr; sparePtr: Ptr; allocPtr: Ptr; heapData: INTEGER; END;MemoryBlock = RECORD address: Ptr; count: LONGINT; END;LogicalToPhysicalTable = RECORD logical: MemoryBlock; physical: ARRAY [0..defaultPhysicalEntryCount - 1] OF MemoryBlock; END;PageState = INTEGER;StatusRegisterContents = INTEGER;FUNCTION GetApplLimit: Ptr;FUNCTION GetZone: THz;FUNCTION SystemZone: THz;FUNCTION ApplicZone: THz;FUNCTION ApplicationZone: THz;FUNCTION NewHandle(byteCount: Size): Handle;FUNCTION NewHandleSys(byteCount: Size): Handle;FUNCTION NewHandleClear(byteCount: Size): Handle;FUNCTION NewHandleSysClear(byteCount: Size): Handle;FUNCTION HandleZone(h: Handle): THz;FUNCTION RecoverHandle(p: Ptr): Handle;FUNCTION NewPtr(byteCount: Size): Ptr;FUNCTION NewPtrSys(byteCount: Size): Ptr;FUNCTION NewPtrClear(byteCount: Size): Ptr;FUNCTION NewPtrSysClear(byteCount: Size): Ptr;FUNCTION PtrZone(p: Ptr): THz;FUNCTION GZSaveHnd: Handle;FUNCTION TopMem: Ptr;FUNCTION MaxBlock: LONGINT;FUNCTION MaxBlockSys: LONGINT;FUNCTION StackSpace: LONGINT;FUNCTION NewEmptyHandle: Handle;FUNCTION NewEmptyHandleSys: Handle;PROCEDURE HLock(h: Handle);PROCEDURE HUnlock(h: Handle);PROCEDURE HPurge(h: Handle);PROCEDURE HNoPurge(h: Handle);PROCEDURE HLockHi(h: Handle);FUNCTION StripAddress(theAddress: UNIV Ptr): Ptr;FUNCTION Translate24To32(addr24: UNIV Ptr): Ptr;FUNCTION TempNewHandle(logicalSize: Size;VAR resultCode: OSErr): Handle;FUNCTION TempMaxMem(VAR grow: Size): Size;FUNCTION TempFreeMem: LONGINT;PROCEDURE TempHLock(h: Handle;VAR resultCode: OSErr);PROCEDURE TempHUnlock(h: Handle;VAR resultCode: OSErr);PROCEDURE TempDisposeHandle(h: Handle;VAR resultCode: OSErr);FUNCTION TempTopMem: Ptr;FUNCTION MFMaxMem(VAR grow: Size): Size;FUNCTION MFFreeMem: LONGINT;FUNCTION MFTempNewHandle(logicalSize: Size;VAR resultCode: OSErr): Handle;PROCEDURE MFTempHLock(h: Handle;VAR resultCode: OSErr);PROCEDURE MFTempHUnlock(h: Handle;VAR resultCode: OSErr);PROCEDURE MFTempDisposHandle(h: Handle;VAR resultCode: OSErr);FUNCTION MFTopMem: Ptr;PROCEDURE InitApplZone;PROCEDURE InitZone(pgrowZone: ProcPtr;cmoreMasters: INTEGER;limitPtr: UNIV Ptr; startPtr: UNIV Ptr);PROCEDURE SetZone(hz: THz);FUNCTION CompactMem(cbNeeded: Size): Size;FUNCTION CompactMemSys(cbNeeded: Size): Size;PROCEDURE PurgeMem(cbNeeded: Size);PROCEDURE PurgeMemSys(cbNeeded: Size);FUNCTION FreeMem: LONGINT;FUNCTION FreeMemSys: LONGINT;PROCEDURE ResrvMem(cbNeeded: Size);PROCEDURE ReserveMem(cbNeeded: Size);PROCEDURE ReserveMemSys(cbNeeded: Size);FUNCTION MaxMem(VAR grow: Size): Size;FUNCTION MaxMemSys(VAR grow: Size): Size;PROCEDURE SetGrowZone(growZone: ProcPtr);PROCEDURE SetApplLimit(zoneLimit: UNIV Ptr);PROCEDURE MoveHHi(h: Handle);PROCEDURE DisposPtr(p: Ptr);PROCEDURE DisposePtr(p: Ptr);FUNCTION GetPtrSize(p: Ptr): Size;PROCEDURE SetPtrSize(p: Ptr;newSize: Size);PROCEDURE DisposHandle(h: Handle);PROCEDURE DisposeHandle(h: Handle);FUNCTION GetHandleSize(h: Handle): Size;PROCEDURE SetHandleSize(h: Handle;newSize: Size);PROCEDURE EmptyHandle(h: Handle);PROCEDURE ReallocHandle(h: Handle;byteCount: Size);PROCEDURE ReallocateHandle(h: Handle;byteCount: Size);PROCEDURE HSetRBit(h: Handle);PROCEDURE HClrRBit(h: Handle);PROCEDURE MoreMasters;PROCEDURE BlockMove(srcPtr: UNIV Ptr;destPtr: UNIV Ptr;byteCount: Size);PROCEDURE BlockMoveData(srcPtr: UNIV Ptr;destPtr: UNIV Ptr;byteCount: Size);FUNCTION MemError: OSErr;PROCEDURE PurgeSpace(VAR total: LONGINT;VAR contig: LONGINT);FUNCTION HGetState(h: Handle): SignedByte;PROCEDURE HSetState(h: Handle;flags: SignedByte);PROCEDURE SetApplBase(startPtr: UNIV Ptr);PROCEDURE MaxApplZone;FUNCTION HoldMemory(address: UNIV Ptr;count: LONGINT): OSErr;FUNCTION UnholdMemory(address: UNIV Ptr;count: LONGINT): OSErr;FUNCTION LockMemory(address: UNIV Ptr;count: LONGINT): OSErr;FUNCTION LockMemoryContiguous(address: UNIV Ptr;count: LONGINT): OSErr;FUNCTION UnlockMemory(address: UNIV Ptr;count: LONGINT): OSErr;FUNCTION GetPhysical(VAR addresses: LogicalToPhysicalTable;VAR physicalEntryCount: LONGINT): OSErr;FUNCTION DeferUserFn(userFunction: ProcPtr;argument: UNIV Ptr): OSErr;FUNCTION DebuggerGetMax: LONGINT;PROCEDURE DebuggerEnter;PROCEDURE DebuggerExit;PROCEDURE DebuggerPoll;FUNCTION GetPageState(address: UNIV Ptr): PageState;FUNCTION PageFaultFatal: BOOLEAN;FUNCTION DebuggerLockMemory(address: UNIV Ptr;count: LONGINT): OSErr;FUNCTION DebuggerUnlockMemory(address: UNIV Ptr;count: LONGINT): OSErr;FUNCTION EnterSupervisorMode: StatusRegisterContents;IMPLEMENTATIONFUNCTION GetApplLimit: Ptr; BEGIN GetApplLimit :=  new(Ptr) END;FUNCTION GetZone: THz; BEGIN GetZone :=  new(THz) END;FUNCTION SystemZone: THz; BEGIN SystemZone := new(THz) END;FUNCTION ApplicZone: THz; BEGIN ApplicZone := new(THz) END;FUNCTION ApplicationZone: THz; BEGIN ApplicationZone := new(THz) END;FUNCTION NewHandle(byteCount: Size): Handle;var  thePointer: pointer;BEGIN  Getmem(thePointer, byteCount);  NewHandle := @thePointer;END;FUNCTION NewHandleSys(byteCount: Size): Handle; BEGIN NewHandleSys := new(Handle) END;FUNCTION NewHandleClear(byteCount: Size): Handle; BEGIN NewHandleClear := new(Handle) END;FUNCTION NewHandleSysClear(byteCount: Size): Handle; BEGIN NewHandleSysClear := new(Handle) END;FUNCTION HandleZone(h: Handle): THz; BEGIN HandleZone := new(THz) END;FUNCTION RecoverHandle(p: Ptr): Handle; BEGIN  RecoverHandle:= new(Handle) END;FUNCTION NewPtr(byteCount: Size): Ptr; BEGIN  NewPtr:= new(Ptr) END;FUNCTION NewPtrSys(byteCount: Size): Ptr; BEGIN NewPtrSys := new(Ptr) END;FUNCTION NewPtrClear(byteCount: Size): Ptr; BEGIN NewPtrClear := new(Ptr) END;FUNCTION NewPtrSysClear(byteCount: Size): Ptr; BEGIN NewPtrSysClear := new(Ptr) END;FUNCTION PtrZone(p: Ptr): THz; BEGIN PtrZone := new(THz) END;FUNCTION GZSaveHnd: Handle; BEGIN  GZSaveHnd:= new(Handle) END;FUNCTION TopMem: Ptr; BEGIN TopMem := new(Ptr) END;FUNCTION MaxBlock: LONGINT; BEGIN MaxBlock := 0 END;FUNCTION MaxBlockSys: LONGINT; BEGIN MaxBlockSys := 0 END;FUNCTION StackSpace: LONGINT; BEGIN StackSpace := 0 END;FUNCTION NewEmptyHandle: Handle; BEGIN NewEmptyHandle := new(Handle) END;FUNCTION NewEmptyHandleSys: Handle; BEGIN NewEmptyHandleSys := new(Handle) END;PROCEDURE HLock(h: Handle); BEGIN END;PROCEDURE HUnlock(h: Handle); BEGIN END;PROCEDURE HPurge(h: Handle); BEGIN END;PROCEDURE HNoPurge(h: Handle); BEGIN END;PROCEDURE HLockHi(h: Handle); BEGIN END;FUNCTION StripAddress(theAddress: UNIV Ptr): Ptr; BEGIN StripAddress := new(Ptr) END;FUNCTION Translate24To32(addr24: UNIV Ptr): Ptr; BEGIN Translate24To32 := new(Ptr) END;FUNCTION TempNewHandle(logicalSize: Size;VAR resultCode: OSErr): Handle; BEGIN TempNewHandle := new(Handle) END;FUNCTION TempMaxMem(VAR grow: Size): Size; BEGIN TempMaxMem := 0 END;FUNCTION TempFreeMem: LONGINT; BEGIN TempFreeMem := 0 END;PROCEDURE TempHLock(h: Handle;VAR resultCode: OSErr); BEGIN END;PROCEDURE TempHUnlock(h: Handle;VAR resultCode: OSErr); BEGIN END;PROCEDURE TempDisposeHandle(h: Handle;VAR resultCode: OSErr); BEGIN END;FUNCTION TempTopMem: Ptr; BEGIN TempTopMem := new(Ptr) END;FUNCTION MFMaxMem(VAR grow: Size): Size; BEGIN MFMaxMem := 0 END;FUNCTION MFFreeMem: LONGINT; BEGIN  MFFreeMem:= 0 END;FUNCTION MFTempNewHandle(logicalSize: Size;VAR resultCode: OSErr): Handle; BEGIN MFTempNewHandle := new(Handle) END;PROCEDURE MFTempHLock(h: Handle;VAR resultCode: OSErr); BEGIN END;PROCEDURE MFTempHUnlock(h: Handle;VAR resultCode: OSErr); BEGIN END;PROCEDURE MFTempDisposHandle(h: Handle;VAR resultCode: OSErr); BEGIN END;FUNCTION MFTopMem: Ptr; BEGIN  MFTopMem:= new(Ptr) END;PROCEDURE InitApplZone; BEGIN END;PROCEDURE InitZone(pgrowZone: ProcPtr;cmoreMasters: INTEGER;limitPtr: UNIV Ptr; startPtr: UNIV Ptr); BEGIN END;PROCEDURE SetZone(hz: THz); BEGIN END;FUNCTION CompactMem(cbNeeded: Size): Size; BEGIN CompactMem := 0; END;FUNCTION CompactMemSys(cbNeeded: Size): Size; BEGIN CompactMemSys := 0; END;PROCEDURE PurgeMem(cbNeeded: Size); BEGIN END;PROCEDURE PurgeMemSys(cbNeeded: Size); BEGIN END;FUNCTION FreeMem: LONGINT; BEGIN FreeMem := 0 END;FUNCTION FreeMemSys: LONGINT; BEGIN FreeMemSys := 0 END;PROCEDURE ResrvMem(cbNeeded: Size); BEGIN END;PROCEDURE ReserveMem(cbNeeded: Size); BEGIN END;PROCEDURE ReserveMemSys(cbNeeded: Size); BEGIN END;FUNCTION MaxMem(VAR grow: Size): Size; BEGIN MaxMem := 0 END;FUNCTION MaxMemSys(VAR grow: Size): Size; BEGIN MaxMemSys := 0 END;PROCEDURE SetGrowZone(growZone: ProcPtr); BEGIN END;PROCEDURE SetApplLimit(zoneLimit: UNIV Ptr); BEGIN END;PROCEDURE MoveHHi(h: Handle); BEGIN END;PROCEDURE DisposPtr(p: Ptr); BEGIN END;PROCEDURE DisposePtr(p: Ptr); BEGIN END;FUNCTION GetPtrSize(p: Ptr): Size; BEGIN GetPtrSize := 0 END;PROCEDURE SetPtrSize(p: Ptr;newSize: Size); BEGIN END;PROCEDURE DisposHandle(h: Handle); BEGIN END;PROCEDURE DisposeHandle(h: Handle); BEGIN END;FUNCTION GetHandleSize(h: Handle): Size; BEGIN GetHandleSize := 0 END;PROCEDURE SetHandleSize(h: Handle;newSize: Size); BEGIN END;PROCEDURE EmptyHandle(h: Handle); BEGIN END;PROCEDURE ReallocHandle(h: Handle;byteCount: Size); BEGIN END;PROCEDURE ReallocateHandle(h: Handle;byteCount: Size); BEGIN END;PROCEDURE HSetRBit(h: Handle); BEGIN END;PROCEDURE HClrRBit(h: Handle); BEGIN END;PROCEDURE MoreMasters; BEGIN END;PROCEDURE BlockMove(srcPtr: UNIV Ptr;destPtr: UNIV Ptr;byteCount: Size); BEGIN END;PROCEDURE BlockMoveData(srcPtr: UNIV Ptr;destPtr: UNIV Ptr;byteCount: Size); BEGIN END;FUNCTION MemError: OSErr; BEGIN MemError := noErr END;PROCEDURE PurgeSpace(VAR total: LONGINT;VAR contig: LONGINT); BEGIN END;FUNCTION HGetState(h: Handle): SignedByte; BEGIN HGetState := 0; END;PROCEDURE HSetState(h: Handle;flags: SignedByte); BEGIN END;PROCEDURE SetApplBase(startPtr: UNIV Ptr); BEGIN END;PROCEDURE MaxApplZone; BEGIN END;FUNCTION HoldMemory(address: UNIV Ptr;count: LONGINT): OSErr; BEGIN HoldMemory := noErr END;FUNCTION UnholdMemory(address: UNIV Ptr;count: LONGINT): OSErr; BEGIN UnholdMemory := noErr END;FUNCTION LockMemory(address: UNIV Ptr;count: LONGINT): OSErr; BEGIN LockMemory := noErr END;FUNCTION LockMemoryContiguous(address: UNIV Ptr;count: LONGINT): OSErr; BEGIN LockMemoryContiguous := noErr END;FUNCTION UnlockMemory(address: UNIV Ptr;count: LONGINT): OSErr; BEGIN UnlockMemory := noErr END;FUNCTION GetPhysical(VAR addresses: LogicalToPhysicalTable;VAR physicalEntryCount: LONGINT): OSErr; BEGIN  GetPhysical:= noErr END;FUNCTION DeferUserFn(userFunction: ProcPtr;argument: UNIV Ptr): OSErr; BEGIN DeferUserFn := noErr END;FUNCTION DebuggerGetMax: LONGINT; BEGIN DebuggerGetMax := 0 END;PROCEDURE DebuggerEnter; BEGIN END;PROCEDURE DebuggerExit; BEGIN END;PROCEDURE DebuggerPoll; BEGIN END;FUNCTION GetPageState(address: UNIV Ptr): PageState; BEGIN GetPageState := 0 END;FUNCTION PageFaultFatal: BOOLEAN; BEGIN PageFaultFatal := false END;FUNCTION DebuggerLockMemory(address: UNIV Ptr;count: LONGINT): OSErr; BEGIN DebuggerLockMemory := noErr END;FUNCTION DebuggerUnlockMemory(address: UNIV Ptr;count: LONGINT): OSErr; BEGIN DebuggerUnlockMemory := noErr END;FUNCTION EnterSupervisorMode: StatusRegisterContents; BEGIN EnterSupervisorMode := 0 END; END.