unit unit_engineering;interface	uses{$IFC UNDEFINED THINK_Pascal}		Types,{$ENDC}		unit_snail_types, unit_globals;	procedure DoEngineer(prefs: SnailPreferencesHandle);	procedure DoSaltation(prefs: SnailPreferencesHandle);	procedure Manipulation (prefs: SnailPreferencesHandle;  MLoc: point);	function LeftRightPos (MLoc: Point; Box: Rect): HorizPos;	function Rung (Mloc: Point; Box: Rect): VertPos;implementation	uses  {$IFC UNDEFINED THINK_Pascal}		Quickdraw,  {$ENDC}		unit_miscellaneous, unit_biomorphs, unit_develop, unit_findthescale,  unit_snapshot;	procedure DoEngineer(prefs: SnailPreferencesHandle);	begin		prefs^^.TheMode := engineering;		EraseRect(prefs^^.Prect);		SetUpBoxes(prefs);		child[midbox] := child[special];		special := midbox;		Delayvelop(prefs, child[special], centre[MidBox]);		MakeGeneBox(prefs, child[special]);		StoreOffScreen(MainPtr^.PortRect, MyBitMap);	end; {DoEngineer}	function LeftRightPos (MLoc: Point; Box: Rect): HorizPos;	begin		with Box do			if MLoc.h < left + (right - left) div 3 then				LeftRightPos := LeftThird			else if Mloc.h > right - (right - left) div 3 then				LeftRightPos := RightThird			else				LeftRightPos := MidThird	end;	function Rung (Mloc: Point; Box: Rect): VertPos;	begin		with Box do			if MLoc.v < top + (bottom - top) div 3 then				Rung := TopRung			else if MLoc.v > bottom - (bottom - top) div 3 then				Rung := BottomRung			else				Rung := MidRung	end;	procedure SnapDevelop (prefs: SnailPreferencesHandle; Biomorph: person; Place: Point);		var			SnappyBox: Rect;			offsetPoint: Point;	begin    with prefs^^ do      begin		  DelayedDrawing := TRUE;		  SnappyBox := Margin;		  ZeroMargin := TRUE;		  offsetPoint := Develop(prefs, biomorph, Place);		  with Snappybox do			  begin				  if Margin.left < left then					  left := Margin.left;				  if Margin.right > right then					  right := Margin.right;				  if Margin.top < top then					  top := Margin.top;				  if Margin.bottom > bottom then					  bottom := Margin.bottom			  end;		  Grow(Snappybox, MyPenSize);		  Snapshot(prefs, Snappybox, Biomorph);    end;	end; {SnapDevelop}	procedure Manipulation (prefs: SnailPreferencesHandle; MLoc: point);		var			j, chosenbox: Integer;			Cent: Point;			swallowing, refrain: Boolean;			offsetPoint: Point;	begin		GlobalToLocal(Mloc);		ChosenBox := 0;		if Mloc.v < prefs^^.GeneBox[1].bottom then			for j := 1 to 16 do				if PtInRect(MLoc, prefs^^.GeneBox[j]) then					ChosenBox := j;		j := ChosenBox;		if ChosenBox = 0 then			SyringeMessage(prefs)		else			with child[special] do				begin					case ChosenBox of						1: 							case LeftRightPos(Mloc, prefs^^.GeneBox[j]) of								LeftThird: 									WOpening := Margarine(WOpening, -1);								RightThird: 									WOpening := Margarine(WOpening, 1);								MidThird: 									;							end; {pos cases}						2: 							case LeftRightPos(Mloc, prefs^^.GeneBox[j]) of								LeftThird: 									DDisplacement := DDisplacement - DMutSize;								RightThird: 									DDisplacement := DDisplacement + DMutSize;								MidThird: 									;							end; {pos cases}						3: 							case LeftRightPos(Mloc, prefs^^.GeneBox[j]) of								LeftThird: 									SShape := SShape - SMutSize;								RightThird: 									SShape := SShape + SMutSize;								MidThird: 									;							end; {pos cases}						4: 							case LeftRightPos(Mloc, prefs^^.GeneBox[j]) of								LeftThird: 									TTranslation := TTranslation - TMutSize;								RightThird: 									TTranslation := TTranslation + TMutSize;								MidThird: 									;							end; {pos cases}					end; {case ChosenBox}{IF WOpening < =0 then WOpening:=0;}					if DDisplacement < 0 then						DDisplacement := 0;					if DDisplacement > 100 then						DDisplacement := 100;				end;		EraseRect(prefs^^.Box[MidBox]);		ShowGeneBox(prefs, chosenbox, child[special]);		offsetPoint := Develop(prefs, child[special], centre[MidBox]);	end; {Manipulation}	function Randreal (Max: real): real;		var			rint: integer;			r: real;	begin		rint := abs(random);		r := rint / 32767;		randreal := r * max;	end; {randreal}	procedure DoSaltation(prefs: SnailPreferencesHandle);		var			j, maxgene, r: Integer;			factor: -1..1;			offsetPoint: Point;	begin		prefs^^.DelayedDrawing := FALSE;		special := MidBox;		with child[special] do			begin				WOpening := exp(randreal(4));				DDisplacement := randreal(1);				SShape := randreal(2);				TTranslation := randreal(4);				MutProb := 50;				GeneratingCurve := 0;				Handedness := Direction;				TranslationGradient := randreal(1.3);				CoarseGraininess := randint(4);				reach := Randint(4);			end;		EraseRect(prefs^^.Prect);		offsetPoint := Develop(prefs, child[special], centre[midBox]);{MakeGeneBox(child[MidBox]);}		prefs^^.TheMode := Randoming;	end; {DoSaltation}end.