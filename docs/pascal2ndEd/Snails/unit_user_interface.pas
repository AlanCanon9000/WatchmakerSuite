unit unit_user_interface;{******************************************************************************}{*															v1.1 Sept 1993.																*}{* 	Added Suspend/Resume events																								*}{*		Added command key handling																							*}{*		Split activate/deactivate event handling															  *}{*		New menu item -> hide windows in background															*}{*		Save screen if hiding windows, otherwise don't                          *}{*      - speed up context switching								                          *}{*		Enabled desk accessories																								*}{*		Added bad disk handling																									*}{*		Split up HandleMenu proc into several procedures - one per menu 				*}{*		Added named constants for menu items                                    *}{*      (so ordinary mortals like me can read this!)					                *}{*		All file operations converted to Mac file manager calls									*}{*		DLOGs for DireMessages changed to Alerts, conforming to Apple's HIG			*}{*		Removed Repeat/Until loops around save changes alerts									  *}{*		Removed many unused variables, and restricted USE of other units			  *}{*		Added auto positioning of dialogs and alerts under System 6 (urgh).     *}{*    Added auto position to resources for System 7                           *}{*																													                  *}{*		Saving files in same folder as file with same name now removes          *}{*      old file, even if open (not sure of the wisdom of this, though)   		*}{*																																						*}{------------------------------------------------------------------------------}{*																	TO DO																			*}{*		Check out other dialogs, some of them should be alerts	(done)					*}{*		Offscreen bitmaps:																											*}{*			1) Save only rect of dialog or alert																	*}{*			2) Don't save screen before switching out (makes response sluggish    *}{*        - Apple says don't do it)	                                          *}{*			3) Change DoUpdate so that it draws normally if no offscreen saved    *}{*			4) Remove spurious calls to StoreOffScreen														*}{*			5) Disentangle activate and update event handling											*}{*		Restrict window size, and allow users to change size. Option:           *}{*      leave space for disk icons				                                    *}{*		Add support for a least the required set of Apple Events 								*}{*																																						*}{******************************************************************************}interfaceuses{$IFC UNDEFINED THINK_Pascal}		Events,{$ENDC}   unit_snail_types;	procedure HandleEvent (prefs: SnailPreferencesHandle; theEvent: EventRecord);	procedure DoAnimalsMenuCommands (prefs: SnailPreferencesHandle; item: Integer);implementationuses{$IFC UNDEFINED THINK_Pascal}  Desk, Dialogs, DiskInit, Fonts, Menus, OSUtils, Quickdraw, ToolUtils,  Types, Windows, Files, Controls,{$ENDC}    unit_findthescale,		unit_miscellaneous, unit_develop, unit_album, unit_pedigree, unit_globals,    unit_snapshot, unit_biomorphs, unit_engineering, unit_triangle, unit_array;	procedure DoAbout(prefs: SnailPreferencesHandle);{}{    Purpose         bring up 'About...' box using a dialog box}{}		var			theItem: Integer;			AboutPtr: DialogPtr;	begin		if frontwindow = mainptr then			Storeoffscreen(MainPtr^.PortRect, MyBitMap);		SetCursor(prefs^^.CursList[CrossCursor]^^);      				{set to my cursor}  {ShowCursor; }                          { and turn it back on           }		if gSystem.systemVersion < $0700 then			PositionDialog('DLOG', 11271);		AboutPtr := GetNewDialog(11271, nil, Pointer(-1));    	{get dialog box}		ModalDialog(nil, theItem);             					{put dialog box up; get result }		DisposDialog(AboutPtr);               						{get rid of dialog box }		SetCursor(Arrow);	end; { of proc DoAbout }	procedure ToggleFlag (var Flag: Boolean; Mndx, Indx: Integer);{}{    purpose         checks or de-checks item Indx in menu Mndx}{    last update     20 Aug 86}{}		var			Ch: Char;	begin		Flag := not Flag;                     { toggle flag (for you)         }		if Flag then                               { if flag is True...            }			Ch := Chr(CheckMark)           {   then check item in menu     }		else			Ch := Chr(NoMark);             {   else clear any checkmark    }		SetItemMark(MenuList[Mndx], Indx, Ch)   { put char by item in menu      }	end; { of proc ToggleFlag }	procedure EnableMenus(prefs: SnailPreferencesHandle);		var			i: Integer;	begin		for i := 1 to MenuCnt do			EnableItem(MenuList[i], 0);		OwnEditMenu(prefs);		DrawMenuBar;	end;	procedure DisableMenus;		var			i: Integer;	begin		for i := 2 to MenuCnt do			DisableItem(MenuList[i], 0);		EnableItem(MenuList[3], 0);		for i := 1 to 6 do			EnableItem(MenuList[3], i);		for i := 7 to 10 do			DisableItem(MenuList[3], i);		DrawMenuBar;	end;	procedure DoDeskAcc (prefs: SnailPreferencesHandle; Item: Integer);{}{    purpose         start up desk accessory from Apple menu}{v1.1 DName was incorrectly declared as a STRING and some lines commented out. DAs now work correctly.}		var			SavePort: GrafPtr;			RefNum: Integer;			DName: Str255;	begin		if frontwindow = mainptr then			begin				if prefs^^.theMode = Albuming then					Danger := TRUE;				Storeoffscreen(MainPtr^.PortRect, MyBitMap);			end;		GetPort(SavePort);                    			{ save port before starting it  }		GetItem(MenuList[AM], Item, DName);		{ get name of desk accessory    }		refNum := OpenDeskAcc(DName);			{*This line was commented out! -Alun v1.1*}     										{ and start that sucker up!     }		SetPort(SavePort);                    			{ restore grafport and continue }		DAon := TRUE	end; { of proc DoDeskAcc }	procedure DoFileMenuCommands (prefs: SnailPreferencesHandle; menuItem: Integer);{v1.1 same as before, I have just split the very long proc into readable pieces}		var			verdict, StoreNRows, StoreNCols: Integer;			err: OSErr;	begin		StoreNRows := NRows;		StoreNCols := NCols;		case menuItem of			LoadAlbumItem: 				begin					NRows := AlbumNRows;					NCols := AlbumNCols;					SetUpBoxes(prefs);					LoadingFossils := FALSE;					DoLoad(prefs, TRUE);					NRows := StoreNRows;					NCols := StoreNCols;				end;			LoadFossilsItem: 				begin					if not FossilsExist then						ResetFossils					else						begin							DotheSave := FALSE;							DireMessage(prefs, kFossilsID, kResettingID, Verdict, true);							if Verdict = 1 then								SaveSlides(prefs); {Yes}                            {returns with DoTheSave}							if (Verdict = 1) and (DoTheSave) then								ResetFossils;							if Verdict = 2 then								ResetFossils {No}						end;					if verdict <> 3 then {3=cancel}						begin							Fossilizing := FALSE;  {Filetype := 'COLL';}							err := SetEOF(slides, 0);							LoadingFossils := TRUE;							ReadAnimals(prefs, ThisMenagerie); {Menagerie is dummy}                        {The next 3 lines are necessary for Spencer's manual but better out}                        (*ClosePlayBack;}{                        Fossilizing:=TRUE;}{                        DoBreed*)                        {Reset(slides);}{                        StartPlayBack;}						end; {Not cancelled}				end;{case 2}			SaveBiomorphItem: 				DoSave(prefs, 1);			SaveFossilsItem: 				SaveSlides(prefs);			SaveAlbumItem: 				if prefs^^.theMode = Moving then					DoSave(prefs, 2)				else					DoSave(prefs, 3);			CloseAlbumItem: 				DoClose(prefs);			QuitItem: 				Finished := True;   { Quit command              }		end;{case}	end;{DoFileMenuCommands}	procedure DoEditMenuCommands (prefs: SnailPreferencesHandle; item: Integer);		var			StoreNRows, StoreNCols: Integer;      systemeditresult: boolean;	begin		StoreNRows := NRows;		StoreNCols := NCols;		if Item <> CutItem then			prefs^^.ClipBoarding := FALSE;		if (Item >= AddBiomItem) then			begin				if prefs^^.TheMode <> Albuming then					StoreBreedingScreen(prefs);				NRows := AlbumNRows;				NCols := AlbumNCols;				prefs^^.TheMode := Albuming;				SetUpBoxes(prefs)			end;		case Item of			UndoItem: 				if not SystemEdit(0) then					Sysbeep(1);			2: 				;  {----------------}			CutItem: 				if not SystemEdit(2) then					Sysbeep(1);			Copyitem: 				if not SystemEdit(3) then					SendToClipBoard(prefs);			PasteItem: 				systemeditresult := SystemEdit(4);			ClearItem: 				systemeditresult := SystemEdit(5);			7: 				;  {----------------}			HighlightBiomItem: 				DoHighlight(prefs);			AddBiomItem: 				begin					AddToAlbum(prefs, child[special]);				end;{****}                    {Range check fails on special, gives bomb, when album emptied}			ShowAlbumItem: 				if Page > 1 then					Zoom(prefs)				else					begin						UncurtainPage(prefs, CurrentPage);						TakeCare(prefs, CurrentPage);						if OldSpecial = 0 then							begin								OldSpecial := Special;								InvertRect(prefs^^.Box[special])							end;					end;			ImportPICTItem: 				ImportPICT;		end; {Cases}		if Item >= HighlightBiomItem then			begin				NRows := StoreNRows;				NCols := StoreNCols;			end;	end;{DoEditMenuCommand}	procedure DoSpecMenuCommands (prefs: SnailPreferencesHandle; item: Integer);	begin		case Item of			ClosePlaybackItem: 				begin {Child[MidBox]:=FirstBiomorph;}					ClosePlayBack(prefs);				end;			BreedCurrentItem: 				begin					FirstBiomorph := TheBiomorph;					ClosePlayBack(prefs);					Fossilizing := FALSE;					DoBreed(prefs)				end;			QuitPlaybackItem: 				Finished := TRUE;		end;	end;{DoSpecMenuCommands}	procedure DoOperationMenuCommands (prefs: SnailPreferencesHandle; item: Integer);		var			verdict: Integer;			err: OSErr;	begin		prefs^^.ClipBoarding := FALSE;		case Item of              { Operation Menu          }			BreedItem: 				begin					NRows := BreedNRows;					NCols := BreedNCols;					NActiveBoxes := NBoxes;					DoBreed(prefs);				end;			DriftItem: 				begin					EraseRect(prefs^^.Prect);					prefs^^.TheMode := Drifting;					DriftOne := 0;					NActiveBoxes := 0;				end;			EngineeringItem: 				begin					DoEngineer(prefs)				end;			HopeMonsterItem: 				begin					DoSaltation(prefs);				end;			InitFossRecItem: 				begin					if not FossilsExist then						ResetFossils					else						begin							DotheSave := FALSE;							DireMessage(prefs, kFossilsID, kResettingID, Verdict, true);							if Verdict = 1 then								SaveSlides(prefs); {Yes}                            {returns with DoTheSave}							if (Verdict = 1) and (DoTheSave) then								ResetFossils;							if Verdict = 2 then								ResetFossils {No}						end;				end;			PlayFossilItem: 				begin					err := SetFPos(Slides, fsFromStart, 0);		{v1.1  was reset(Slides);} 																											{Only play back history made this time}					StartPlayBack(prefs);  {Play Back Fossil Record}				end;			RecordFossilItem: 				Fossilizing := not Fossilizing;			TriangleItem: 				begin					prefs^^.TheMode := triangling;					OldSpecial := 0;					MainTriangle(prefs)				end;			ArrayItem: 				begin					ArrayDialog(WDetails, DDetails, TDetails, Verdict);					case verdict of						1: 							DoArray(prefs, child[special], WDetails, DDetails, TDetails);						2: 							DoResources(prefs, child[special], WDetails, DDetails, TDetails);						otherwise					end; {ArrayDialog cases}				end;{ArrayItem}		end;	end;	procedure DoBoxMenuCommands (prefs: SnailPreferencesHandle; item: Integer);		var			verdict: Integer;			offsetPoint: Point;	begin		prefs^^.ClipBoarding := FALSE;		case Item of			MoreRowsItem: 				DoRowMore(prefs);			FewerRowsItem: 				DoRowLess(prefs);			MoreColumnsItem: 				DoColMore(prefs);			FewerColumnsItem: 				DoColLess(prefs);			SideViewItem: 				begin					prefs^^.SideView := not prefs^^.SideView;					CheckItem(MenuList[BM], Item, prefs^^.SideView);					EraseRect(prefs^^.Box[MidBox]);					offsetPoint := Develop(prefs, Child[special], centre[MidBox]);				end;			DriftSweepItem: 				begin					SweepOn := not SweepOn;					CheckItem(MenuList[BM], Item, SweepOn);                        {EraseRect(PRect);}					DriftOne := 0;                        {TheMode:=Drifting}				end;			TriangleTopItem: 				begin					if prefs^^.theMode = Triangling then						begin							SimpleMessage(prefs, 14234, Verdict);							if verdict = 1 then								begin									Topan := child[special];									MainTriangle(prefs)								end						end					else						Topan := child[special]				end;			TriangleLeftItem: 				begin					if prefs^^.theMode = Triangling then						begin							SimpleMessage(prefs, 14234, Verdict);							if verdict = 1 then								begin									Leftan := child[special];									MainTriangle(prefs)								end						end					else						Leftan := child[special]				end;			TriangleRightItem: 				begin					if prefs^^.theMode = Triangling then						begin							SimpleMessage(prefs, 14234, Verdict);							if verdict = 1 then								begin									Rightan := child[special];									MainTriangle(prefs)								end						end					else						Rightan := child[special]				end;			ViewPedigreeItem: 				ViewPedigree(prefs);		end;		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		BreedNRows := NRows;		BreedNCols := NCols;		BreedNBoxes := NBoxes;	end;	procedure DoAnimalsMenuCommands (prefs: SnailPreferencesHandle; item: Integer);		var			offsetPoint: Point;	begin		if (Item >= SnailItem) and (Item <= LightningItem) and (prefs^^.theMode = Engineering) then			EraseRect(prefs^^.Prect);		case Item of			CustomiseItem: 				if GenesDialog(prefs) then					begin						DoEngineer(prefs);					end;			SnailItem: 				begin					Child[special] := Snail;					EraseRect(prefs^^.Box[MidBox]);					offsetPoint := Develop(prefs, Child[special], centre[MidBox]);				end;			TurritellaItem: 				begin					Child[special] := Turritella;					EraseRect(prefs^^.Box[MidBox]);					offsetPoint := Develop(prefs, Child[special], centre[MidBox]);				end;			BivalveItem: 				begin					Child[special] := Bivalve;					EraseRect(prefs^^.Box[MidBox]);					offsetPoint := Develop(prefs, Child[special], centre[MidBox]);				end;			AmmoniteItem: 				begin					Child[special] := Ammonite;					EraseRect(prefs^^.Box[MidBox]);					offsetPoint := Develop(prefs, Child[special], centre[MidBox]);				end;			NautilusItem: 				begin					Child[special] := Nautilus;					EraseRect(prefs^^.Box[MidBox]);					offsetPoint := Develop(prefs, Child[special], centre[MidBox]);				end;			BrachiopodItem: 				begin					Child[special] := Brachiopod;					EraseRect(prefs^^.Box[MidBox]);					offsetPoint := Develop(prefs, Child[special], centre[MidBox]);				end;			ConeItem: 				begin					Child[special] := Cone;					EraseRect(prefs^^.Box[MidBox]);					offsetPoint := Develop(prefs, Child[special], centre[MidBox]);				end;			WhelkItem: 				begin					Child[special] := Whelk;					EraseRect(prefs^^.Box[MidBox]);					offsetPoint := Develop(prefs, Child[special], centre[MidBox]);				end;			ScallopItem: 				begin					Child[special] := Scallop;					EraseRect(prefs^^.Box[MidBox]);					offsetPoint := Develop(prefs, Child[special], centre[MidBox]);				end;			EloiseItem: 				begin					Child[special] := Eloise;					EraseRect(prefs^^.Box[MidBox]);					offsetPoint := Develop(prefs, Child[special], centre[MidBox]);				end;			GallaghersItem: 				begin					Child[special] := Gallaghers;					EraseRect(prefs^^.Box[MidBox]);					offsetPoint := Develop(prefs, Child[special], centre[MidBox]);				end;			RapaItem: 				begin					Child[special] := Rapa;					EraseRect(prefs^^.Box[MidBox]);					offsetPoint := Develop(prefs, Child[special], centre[MidBox]);				end;			LightningItem: 				begin					Child[special] := Lightning;					EraseRect(prefs^^.Box[MidBox]);					offsetPoint := Develop(prefs, Child[special], centre[MidBox]);				end;			SundialItem: 				begin					Child[special] := Sundial;					EraseRect(prefs^^.Box[MidBox]);					offsetPoint := Develop(prefs, Child[special], centre[MidBox]);				end;			FigItem: 				begin					Child[special] := Fig;					EraseRect(prefs^^.Box[MidBox]);					offsetPoint := Develop(prefs, Child[special], centre[MidBox]);				end;			TunItem: 				begin					Child[special] := Tun;					EraseRect(prefs^^.Box[MidBox]);					offsetPoint := Develop(prefs, Child[special], centre[MidBox]);				end;			RazorShellItem: 				begin					Child[special] := RazorShell;					EraseRect(prefs^^.Box[MidBox]);					offsetPoint := Develop(prefs, Child[special], centre[MidBox]);				end;			JapaneseWonderItem: 				begin					Child[special] := JapaneseWonder;					EraseRect(prefs^^.Box[MidBox]);					offsetPoint := Develop(prefs, Child[special], centre[MidBox]);				end;		end; {Cases}	end;	procedure DoPedigreeMenuCommands (prefs: SnailPreferencesHandle; item: Integer);	begin		case Item of			DisplayPedigreeItem: 				PhylogNew(prefs, Child[special]);			2: 				; {-------------------}			DrawOutItem: 				prefs^^.TheMode := Phyloging;			NoMirrorsItem: 				begin					Rays := 1;					CheckItem(MenuList[PM], 4, TRUE);					CheckItem(MenuList[PM], 5, FALSE);					CheckItem(MenuList[PM], 6, FALSE);				end;			SingleMirrorItem: 				begin					Rays := 2;					CheckItem(MenuList[PM], 5, TRUE);					CheckItem(MenuList[PM], 4, FALSE);					CheckItem(MenuList[PM], 6, FALSE);				end;			DoubleMirrorItem: 				begin					Rays := 4;					CheckItem(MenuList[PM], 6, TRUE);					CheckItem(MenuList[PM], 4, FALSE);					CheckItem(MenuList[PM], 5, FALSE);				end;			7: 				;{-------------------}			MoveItem: 				prefs^^.TheMode := Moving;			DetachItem: 				prefs^^.TheMode := Detaching;			KillItem: 				prefs^^.TheMode := Killing;		end;	end;{DoPedigreeMenuCommands}	procedure DoHelpMenuCommands (prefs: SnailPreferencesHandle; item: Integer);	begin		if prefs^^.ClipBoarding then			HelpMessage(prefs, 7699)		else			case Item of				HelpCurrentItem: 					case prefs^^.theMode of						Breeding: 							HelpMessage(prefs, 2630);						albuming: 							HelpMessage(prefs, 11506);						phyloging: 							HelpMessage(prefs, 12587);						killing: 							HelpMessage(prefs, 11150);						moving: 							HelpMessage(prefs, 4241);						detaching: 							HelpMessage(prefs, 16204);						randoming: 							HelpMessage(prefs, 26732);						engineering: 							HelpMessage(prefs, 8597);						drifting: 							HelpMessage(prefs, 8947);						highlighting: 							HelpMessage(prefs, 19866);						PlayingBack: 							HelpMessage(prefs, 11238);						triangling: 							HelpMessage(prefs, 17751);						sweeping: 							HelpMessage(prefs, 8947);					end; {Cases}				HelpMiscItem: 					HelpMessage(prefs, 21128);			end; {Help 2 cases}	end;{DoHelpMenuCommands}	procedure HandleMenu (prefs: SnailPreferencesHandle; MenuInfo: LongInt);{####)}{}{}{    purpose         decode MenuInfo and carry out command}{}		var			Menu: Integer;          { menu number that was selected     }			Item: Integer;	begin		if MenuInfo <> 0 then			begin				PenNormal;                      				{ set the pen back to normal}				Menu := HiWord(MenuInfo);       		{ find which menu the command is in }				Item := LoWord(MenuInfo);       			{ get the command number}				case Menu of					ApplMenu: 						begin							if Item = 1 then								DoAbout(prefs)            	{ bring up "About..." window}							else								DoDeskAcc(prefs, Item);   	{ start desk accessory}                     								{ and carry it out }						end;					FileMenu: 						DoFileMenuCommands(prefs, item);					EditMenu: 						DoEditMenuCommands(prefs, item);					SpecMenu: 						DoSpecMenuCommands(prefs, item);					OperMenu: 						DoOperationMenuCommands(prefs, item);					BoxMenu: 						DoBoxMenuCommands(prefs, item);					AnimalsMenu: 						DoAnimalsMenuCommands(prefs, item);					PedigreeMenu: 						DoPedigreeMenuCommands(prefs, item);					HelpMenu: 						DoHelpMenuCommands(prefs, item);					otherwise						Sysbeep(1);				end;{case of Menu}				HiliteMenu(0);                          { reset menu bar            }			end;	end; {of proc HandleMenu}	procedure DoUpdate (prefs: SnailPreferencesHandle; theEvent: EventRecord);{}{    purpose         handles window update event}{}		var			SavePort, theWindow: WindowPtr;	begin		theWindow := WindowPtr(theEvent.Message);     { find which window     }		if (theWindow = MainPtr) or (theWindow = PlayBackPtr) then			begin            { only update ours      }				SetCursor(prefs^^.CursList[watchCursor]^^);         { set cursor to watch   }				GetPort(SavePort);                          { save current grafport }				SetPort(theWindow);                         { set as current port   }				BeginUpdate(theWindow);                     { signal start of update}				if theWindow = MainPtr then					ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);  { and here's the update stuff! }				if theWindow = PlayBackPtr then					begin						PlayBackRect := PlayBackPtr^.PortRect;						EraseRect(PlayBackRect);						DrawGrowIcon(PlayBackPtr);                   { draw grow icon  }						DrawControls(PlayBackPtr);						with PlayBackRect do							begin								right := right - Scrollbarwidth - 1;								bottom := bottom - Scrollbarwidth - 1;							end;						if prefs^^.theMode = PlayingBack then							Snapshot(prefs, PlayBackRect, theBiomorph);					end;  { now, back to our program...}				EndUpdate(theWindow);                       { signal end of update  }				SetPort(SavePort);                          { restore grafport      }				SetCursor(Arrow)                            { restore cursor        }			end; {MainPtr}	end; { of proc DoUpdate }	procedure HandleClick (prefs: SnailPreferencesHandle; WPtr: WindowPtr; MLoc: Point);{}{    purpose         handle mouse click within window}{}		var			j, chosen: Integer;			MP: point;			ErrCode: OSErr;			Ticker: LongInt;			OnlyChild: Boolean;			SaveFull: Full;	begin		if (WPtr = MainPtr) or (WPtr = PlayBackPtr) then     { if this is our window...  }			begin				if WPtr <> frontw then             { and it's not in front...  }					begin						SelectWindow(WPtr);               { ...then make it active    }						frontw := MainPtr;						reStoreOffScreen(MainPtr^.PortRect, MyBitMap);             {DoUpdate(theEvent);}						enablemenus(prefs);					end				else if prefs^^.TheMode = triangling then					PlotTriangle(prefs, MLoc, TRUE)				else if prefs^^.TheMode = breeding then					begin						SetCursor(prefs^^.CursList[watchCursor]^^);						evolve(prefs, MLoc);						SetCursor(prefs^^.CursList[crossCursor]^^)					end				else if prefs^^.TheMode = randoming then					DoSaltation(prefs)				else if prefs^^.TheMode = PlayingBack then					begin						GlobalToLocal(MLoc);						if PtInRect(MLoc, MyControl^^.contrlRect) then							begin								DoPlayBack(prefs, MLoc)							end					end				else if (prefs^^.TheMode = Phyloging) then					begin						RunningFull := SpecialFull;						GetMouse(MP);						if MouseInBox(MP, RunningFull) then							DrawOutFrom(prefs, RunningFull);					end;				if prefs^^.TheMode = Moving then					begin						RunningFull := SpecialFull;						GetMouse(MP);						if MouseInBox(MP, RunningFull) then							FollowMouse(prefs, RunningFull)					end;				if prefs^^.TheMode = Detaching then					begin						RunningFull := SpecialFull;						GetMouse(MP);						if MouseInBox(MP, RunningFull) then							begin								if IsAnAdam(RunningFull) then									SysBeep(1)								else									Detach(prefs, RunningFull)							end					end;				if prefs^^.TheMode = Killing then					begin						RunningFull := SpecialFull;						GetMouse(MP);						if MouseInBox(MP, RunningFull) then							Shoot(prefs, RunningFull);					end;				if prefs^^.TheMode = engineering then					begin						Ticker := TickCount;						if FirstTime then							SetCursor(prefs^^.CursList[watchCursor]^^);						Manipulation(prefs, MLoc);						if FirstTime then							begin								FirstTime := FALSE;								repeat								until TickCount - Ticker > GetDblTime;							end;						if button then							ErrCode := PostEvent(MouseDown, 0)					end				else if prefs^^.TheMode = highlighting then					emphasize(prefs, MLoc);				if (prefs^^.TheMode = Albuming) and (not Zoomed) then					emphasize(prefs, MLoc);				Zoomed := FALSE;			end;	end; { of proc HandleClick }	procedure HandleGrow (WPtr: WindowPtr; MLoc: Point);{}{    purpose         handle mouse click in grow box}{}		type			GrowRec = record					case Integer of						0: (								Result: LongInt						);						1: (								Height, Width: Integer						)				end;		var			GrowInfo: GrowRec;	begin		if WPtr = PlayBackPtr then			with GrowInfo do  { if it's our window    }				begin					InvalRect(WPtr^.portRect);                   {   set up for update   }					Result := GrowWindow(WPtr, MLoc, GrowArea);   {   get amt of growth   }					SizeWindow(WPtr, Width, Height, True);         {   resize window       }					with PlayBackPtr^.PortRect do						begin							MoveControl(MyControl, right - (ScrollBarWidth - 1), top - 1);							SizeControl(MyControl, ScrollBarWidth, (bottom + 1) - (top - 1) - (ScrollBarWidth - 1))						end;{    PlayBackRect:=WPtr^.PortRect;}{    WITH PlayBackRect DO}{        BEGIN right:=right-Scrollbarwidth-1;}{        bottom:=bottom-Scrollbarwidth-1;}{        MidPoint.h:=(right-left) DIV 2;}{        MidPoint.v:=(bottom-top) DIV 2}{        END;}    {InvalRect(MainPtr^.PortRect);}				end;	end; { of proc HandleGrow }	procedure DoActivate (prefs: SnailPreferencesHandle; theEvent: EventRecord);{}{    purpose         handles window activation event}{}		var			theWindow: WindowPtr;	begin		with theEvent do			begin				theWindow := WindowPtr(Message);            { get the window        }				SetPort(theWindow);                       {   make it the port    }				frontw := theWindow;                  {   know it's in front  }				SelectWindow(theWindow);              { -- in place of the previous}                                             { -- line.   AG              }				if theWindow = MainPtr then					ReStoreOffScreen(MainPtr^.PortRect, MyBitMap)				else					begin						DrawGrowIcon(theWindow);					{v1.1 to ensure activating icon}						HiliteControl(myControl, 0);					{activate scrollbar}					end;				InvalRect(theWindow^.PortRect);				Enablemenus(prefs);				DAon := FALSE;                      { it must be our window }			end	end;	procedure DoDeactivate (theEvent: EventRecord);		var			theWindow: WindowPtr;	begin		with theEvent do			begin				theWindow := WindowPtr(Message);            { get the window        }				if theWindow = PlaybackPtr then					begin						child[special] := FirstBiomorph;						HiliteControl(myControl, 255);	{deactivate scrollbar}					end				else					Storeoffscreen(MainPtr^.PortRect, MyBitMap);				SetPort(ScreenPort);                      { else reassign port    }			end;                              {   update menu bar     }	end;	procedure DoSuspend (prefs: SnailPreferencesHandle; theEvent: EventRecord);{We have to do everything necessary (deactivate windows, copy local}{scrap to global, etc) before being switched out}{Set the flag to say we are in the background													}	begin		if frontw = PlaybackPtr then			begin				child[special] := FirstBiomorph;				HiliteControl(myControl, 255);	{deactivate scrollbar}			end;		if hideInBackGround then			begin				HideWindow(PlaybackPtr);				Storeoffscreen(MainPtr^.PortRect, MyBitMap);				HideWindow(MainPtr)			end;		InitCursor;						{Set arrow cursor for other programs}		DAOn := True;		RememberMode := prefs^^.theMode;	end;	procedure DoResume (prefs: SnailPreferencesHandle; theEvent: EventRecord);{Activate the front window}	begin		if hideInBackground then			begin				ShowWindow(MainPtr);				if frontw = playbackPtr then					ShowWindow(PlaybackPtr)				else					ReStoreOffScreen(MainPtr^.PortRect, MyBitMap)			end;{Enablemenus;}		DAon := FALSE;		SetCursor(theCursor);		prefs^^.theMode := RememberMode;		if prefs^^.theMode = Albuming then			OldSpecial := NActiveBoxes;	end;	procedure DoDiskEvent (macEvent: EventRecord); (* The disk event					*)		var			corner: Point; 	(* Location for Dialog box			*)			ignore: Integer;	begin		if (HiWord(macEvent.message) <> noErr) then			begin						(* Some sort of error occurred.		*)						(*   Check if user wants to format	*)						(*   the disk.						*)				SetPt(corner, 112, 80);						(* ??? Can dialog box be centered	*)						(*   There doesn't appear to be a	*)						(*   DLOG resource for this one.	*)						(*   Location (112,80) is the value	*)						(*   used by Finder 6.1. 			*)				ignore := DIBadMount(corner, macEvent.message);			end;	end;	procedure HandleGoAway (prefs: SnailPreferencesHandle; WPtr: WindowPtr; MLoc: Point);{}{    purpose         handle mouse click in go-away box}{}		var			WPeek: WindowPeek;           { for looking at windows    }	begin		if WPtr = frontw then{Indow}			begin          { if it's the active window }				WPeek := WindowPeek(WPtr);              { peek at the window        }				if TrackGoAway(WPtr, MLoc) then					begin    {   and the box is clicked  }						if WPeek^.WindowKind = PascalKind then       {     if it's our window    }							begin								child[special] := FirstBiomorph;								ClosePlayBack(prefs);							end						else							begin								DAon := FALSE;								Sysbeep(1);								CloseDeskAcc(WPeek^.WindowKind);{       else close DeskAcc  }								enablemenus(prefs);                   {   and re-enable menus     }								Sysbeep(1);								repeat								until not button;								repeat								until button;							end;					end			end		else			SelectWindow(WPtr)                   { else make it active       }	end; { of proc HandleGoAway }	procedure DoKeypress (KeyCh: Char);{If the user presses a key, we go into evolving the biomorph until the mouse is pressed.}	begin		min := 30000;{TargetEvolve(target);}	end; { of proc DoKeypress }	procedure KeyDownEvents (prefs: SnailPreferencesHandle; theEvent: EventRecord);{ A key was pressed.  Do something with incoming character.}		var			ch: CHAR;	begin		with theEvent do			begin				ch := CHR(BitAnd(message, charCodeMask));    		{Get character}				if BitAnd(modifiers, Cmdkey) <> 0 then     		{If command key pressed}					HandleMenu(prefs, MenuKey(ch))       						{  then execute command}				else					DoKeyPress(ch)											{else use character}			end {with}	end; {KeyDownEvents}	procedure DoOtherEvent (macEvent: EventRecord);{Things like network events.  We don't do anything with these, this is a place-holder for future enhancements}	begin	end;	procedure DoMouseDown (prefs: SnailPreferencesHandle; theEvent: EventRecord);{}{    purpose         identify where mouse was clicked and handle it}{}		var			Location: Integer;			theWindow: WindowPtr;			MLoc: Point;			WLoc: Integer;	begin		MLoc := theEvent.Where;              { get mouse position            }		WLoc := FindWindow(MLoc, theWindow);   { get window, loc in window     }		case WLoc of                          { handle window locations       }			InMenuBar: 				HandleMenu(prefs, MenuSelect(MLoc));     { in the menu       }			InContent: 				HandleClick(prefs, theWindow, MLoc);      { inside the window }			IngoAway: 				HandleGoAway(prefs, theWindow, MLoc);     { in the go away box}			InGrow: 				HandleGrow(theWindow, MLoc);       { in the grow box   }			InDrag: 				begin					DragWindow(theWindow, MLoc, DragArea); { in the drag bar}					with PlayBackPtr^.PortRect do						begin							MoveControl(MyControl, right - (ScrollBarWidth - 1), top - 1);							SizeControl(MyControl, ScrollBarWidth, (bottom + 1) - (top - 1) - (ScrollBarWidth - 1))						end;				end;			InSysWindow: 				begin					SystemClick(theEvent, theWindow);  { in a DA window    }                  { if frontwindow=mainptr then enablemenus;}{                   front}				end;		end	end; { of proc DoMouseDown }	procedure HandleEvent (prefs: SnailPreferencesHandle; theEvent: EventRecord);{}{    purpose         decodes event and handles it}{* v1.1 Sept 1993.  Added handling of suspend/resume events - Alun *}{}		const			MouseMovedEvt = $FA;		{ Mouse moved event code		}			SuspendResumeEvt = $01;		{ Suspend/Resume event code	}			ResumeEvtMask = $1;			{ Supend or Resume selector	}			ConvertScrapMask = $2;		{ Scrap conversion flag			}	begin		case theEvent.What of			mouseDown: 				DoMouseDown(prefs, theEvent);      		{ mouse button pushed   }			MouseUp: 				FirstTime := TRUE;			keyDown,								{ Key was pressed		}			keyUp, autoKey: 				KeyDownEvents(prefs, theEvent);			{ key pressed down      }			diskEvt: 				DoDiskEvent(theEvent);				{ Disk insertion Event	}			updateEvt: 				DoUpdate(prefs, theEvent);         				{ window need updating  }			activateEvt:				{ Activate or Deactivate a window	}								{   Check the modifiers field to		}								{   determine which one it is			}				if BitAnd(theEvent.modifiers, activeFlag) <> 0 then					DoActivate(prefs, theEvent)				else					DoDeactivate(theEvent);						{* MULTIFINDER EVENTS *}			app4Evt: 				case BAND(BSR(theEvent.message, 24), $FF) of								{ Event type is stored in the			}								{   high byte of the event message	}								{   Typecast to unsigned long so		}								{   we won't get sign extension		}								{   when the bits are shifted			}					MouseMovedEvt: 						;									{ Since we adjust the cursor shape }									{   before handling an event, we 	}									{   can just idle here. 				}{DoIdle(theEvent);	 We could do things like update cursor shape in a DoIdle proc, which is preferable,}{but this is done earlier at the moment. Alun}					SuspendResumeEvt: 		{ Context switch		}						if BAND(theEvent.message, ResumeEvtMask) <> 0 then							DoResume(prefs, theEvent)						else							DoSuspend(prefs, theEvent);				end;			otherwise						{ Some other event	}				DoOtherEvent(theEvent);		end	end; { of proc HandleEvent }end.