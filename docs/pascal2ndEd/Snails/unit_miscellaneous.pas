unit unit_miscellaneous;{******************************************************************************}{*												v1.1 Sept 1993														          *}{*																															              *}{*		Changed Message procs to use Alerts																      *}{*		Removed PictMessage (never called), change Message calls to DisplayError*}{*		Added positioning to alerts and dialogs															    *}{*		Alert now uses STR# for closing, quitting, etc		  										*}{*		Added several functions, for EOF and checking system (see below)			  *}{*     Validated the rect after RestoreOffscreen to prevent drawing twice			*}{******************************************************************************}interface	uses{$IFC UNDEFINED THINK_Pascal}		Types, Quickdraw, OSUtils, Resources, {$ENDC}		unit_snail_types, unit_globals, SANE;	const		MaxResources = 154;	procedure ImportPICT;	procedure MirrorBits (SourceBitmap: BitMap; RectOfInterest: Rect; var DestBitMap: BitMap);	function FossilsExist: Boolean;	procedure DireMessage (prefs: SnailPreferencesHandle; string1ID, string2ID: Integer; var Verdict: Integer; YesNo: Boolean);	procedure MemoryMessage (prefs: SnailPreferencesHandle; ID: Integer; InMessage: Str255; var Verdict: Integer); { 27291 for Fewer album screens, 27295 for Careful}	procedure SimpleMessage (prefs: SnailPreferencesHandle; ID: Integer; var Verdict: Integer);	procedure HelpMessage (prefs: SnailPreferencesHandle; StrID: Integer);	procedure ArrayDialog (var WDetails, DDetails, TDetails: MarchingOrders; var Verdict: integer);	function LayoutDialog (var HoldConstant, RowChap, ColChap: MarchingOrders; var NRows, NCols: Integer): boolean;	function GenesDialog(prefs: SnailPreferencesHandle): Boolean;	procedure SyringeMessage(prefs: SnailPreferencesHandle);	procedure Pause (Message: Str255);	procedure SetItemState (Mndx, Indx: Integer; Flag: Boolean);	function RandInt (Max: Integer): Integer;	function Odd (i: Integer): Boolean;	function RandSwell (Indgene: Swelltype): SwellType;	procedure EraseInnerRect (box: Rect);	procedure FrameOuterRect (box: Rect);	procedure FrameInnerRect (box: Rect);	procedure StoreOffScreen (box: Rect; var Snapshot: BitMap);	procedure RestoreOffScreen (box: Rect; Snapshot: BitMap);	procedure CleanUp;	procedure MakeOffScreen (box: Rect; var Snapshot: BitMap; var Burst: Boolean);	procedure DrawInt (i: Integer);	procedure Drawi (i: Integer);	procedure DrawReal (r: real);	procedure RealToString (r: real; var theString: str255);	procedure Grow (var Box: Rect; d: Integer);	procedure BoxesOnly(prefs: SnailPreferencesHandle);	procedure OwnEditMenu(prefs: SnailPreferencesHandle);	function DawkFilter (param: ParmBlkPtr): Boolean;	procedure SmallMenus(prefs: SnailPreferencesHandle);	procedure LargeMenus(prefs: SnailPreferencesHandle);	procedure BigFuncBox (Box: Rect; var Outbox: Rect);	procedure SmallFuncBox (Box: Rect; var Outbox: Rect; BoxSize: Integer);	procedure FuncBox (Box: Rect; var Outbox: Rect; BoxSize: Integer);	procedure Poop (n: Integer);	procedure StartDocuments (DocumentCount: Integer);	function TwoToThe (n: integer): integer;{*****  Procedures added for v1.1 ********}										{ Operating System utilities }	function TrapAvailable (theTrap: integer): Boolean;	function WNEIsImplemented: Boolean;	function TempMemCallsAvailable: Boolean;	procedure DeleteOldFile (volRefNum: Integer; dirID: LongInt; fileName: Str255);										{ Dialog Manager utilities		}	procedure PositionDialog (theType: ResType; theID: integer);	procedure FindDlogPosition (theType: ResType; theID: integer; var corner: Point);	function IsEOF (refNum: Integer; howClose: LongInt): Boolean;	function FileSize (refNum: Integer): LongInt;		{returns the number of bytes in the file. Same as}{	the toolbox function GetEOF, except this returns the size instead of an error code. It has this name to emulate the }{   Turbo routine, except this returns bytes (since we don't use pascal type-files now).}	function snail: person;	function Turritella: person;	function Bivalve: person;	function Ammonite: person;	function Nautilus: person;	function Brachiopod: person;	function Cone: person;	function Whelk: person;	function Scallop: person;	function Eloise: person;	function Gallaghers: person;	function Rapa: person;	function Lightning: person;	function Sundial: person;	function Fig: person;	function Tun: person;	function RazorShell: person;	function JapaneseWonder: person;implementation	uses {$IFC UNDEFINED THINK_Pascal}		think_pascal, SysEqu, Menus, StandardFile, ToolUtils, Files, Dialogs, TextUtils, Events, Windows, Controls, Memory, Segload, QuickdrawText, {$ENDC}		Script, Traps;{*	Operating System utilities	*}{****************************************************}{ TrapAvailable}{}{ 	Check whether a certain trap exists on this machine.  }{ this function uses the new approved method as per IM-VI}{	p. 3-8												}{}{****************************************************}	function snail: person;		var			theShell: person;	begin		with theShell do			begin				WOpening := 1.66;				DDisplacement := 0;				SShape := 1.2;				TTranslation := 2;				Coarsegraininess := 4;				reach := 5;				GeneratingCurve := 0;				Handedness := 1;				TranslationGradient := 1;			end;		snail := theShell;	end;	function Turritella: person;		var			theShell: person;	begin		with theShell do			begin				WOpening := 1.30;				DDisplacement := 0;				SShape := 1;				TTranslation := 8.2;				Coarsegraininess := 8;				reach := 10;				GeneratingCurve := 0;				Handedness := 1;				TranslationGradient := 1;			end;		Turritella := theShell;	end;	function Bivalve: person;		var			theShell: person;	begin		with theShell do			begin				WOpening := 1000;				DDisplacement := 0;				SShape := 1.2;				TTranslation := 0.5;				MutProb := 50;				Coarsegraininess := 2;				reach := 1;				GeneratingCurve := 0;				Handedness := 1;				TranslationGradient := 1;			end;		Bivalve := theShell;	end;	function Ammonite: person;		var			theShell: person;	begin		with theShell do			begin				WOpening := 2;				DDisplacement := 0;				SShape := 1;				TTranslation := 0;				Coarsegraininess := 8;				reach := 3;				GeneratingCurve := 0;				Handedness := 1;				TranslationGradient := 1;			end;		Ammonite := theShell;	end;	function Nautilus: person;		var			theShell: person;	begin		with theShell do			begin				WOpening := 3.4;				DDisplacement := 0;				SShape := 1.2;				TTranslation := 0;				Coarsegraininess := 8;				reach := 3;				GeneratingCurve := 0;				Handedness := 1;				TranslationGradient := 1;			end;		Nautilus := theShell;	end;	function Brachiopod: person;		var			theShell: person;	begin		with theShell do			begin				WOpening := 10000;				DDisplacement := 0;				SShape := 1;				TTranslation := 0;				Coarsegraininess := 2;				reach := 3;				GeneratingCurve := 0;				Handedness := 1;				TranslationGradient := 1;			end;		Brachiopod := theShell;	end;	function Cone: person;		var			theShell: person;	begin		with theShell do			begin				WOpening := 1.66;				DDisplacement := 0;				SShape := 3;				TTranslation := 3.5;				Coarsegraininess := 2;				reach := 3;				GeneratingCurve := 128;				Handedness := 1;				TranslationGradient := 1;			end;		Cone := theShell;	end;	function Whelk: person;		var			theShell: person;	begin		with theShell do			begin				WOpening := 1.7;				DDisplacement := 0;				SShape := 2;				TTranslation := 4;				Coarsegraininess := 2;				reach := 6;				GeneratingCurve := 128;				Handedness := 1;				TranslationGradient := 1;			end;		Whelk := theShell;	end;	function Scallop: person;		var			theShell: person;	begin		with theShell do			begin				WOpening := 10000;				DDisplacement := 0;				SShape := 1;				TTranslation := 0;				Coarsegraininess := 2;				reach := 3;				GeneratingCurve := 148;				Handedness := 1;				TranslationGradient := 1;			end;		Scallop := theShell;	end;	function Eloise: person;		var			theShell: person;	begin		with theShell do			begin				WOpening := 1.4;				DDisplacement := 0;				SShape := 1.7;				TTranslation := 3.5;				Coarsegraininess := 4;				reach := 6;				GeneratingCurve := 146;				Handedness := 1;				TranslationGradient := 1;			end;		Eloise := theShell;	end;	function Gallaghers: person;		var			theShell: person;	begin		with theShell do			begin				WOpening := 1.66;				DDisplacement := 0;				SShape := 1.8;				TTranslation := 5;				Coarsegraininess := 4;				reach := 6;				GeneratingCurve := 136;				Handedness := -1;				TranslationGradient := 1;			end;		Gallaghers := theShell;	end;	function Rapa: person;		var			theShell: person;	begin		with theShell do			begin				WOpening := 1.66;				DDisplacement := 0;				SShape := 2;				TTranslation := 2.2;				Coarsegraininess := 4;				reach := 9;				GeneratingCurve := 132;				Handedness := 1;				TranslationGradient := 1;			end;		Rapa := theShell;	end;	function Lightning: person;		var			theShell: person;	begin		with theShell do			begin				WOpening := 1.66;				DDisplacement := 0;				SShape := 3.5;				TTranslation := 4;				Coarsegraininess := 4;				reach := 6;				GeneratingCurve := 150;				Handedness := -1;				TranslationGradient := 0.9;			end;		Lightning := theShell;	end;	function Sundial: person;		var			theShell: person;	begin		with theShell do			begin				WOpening := 1.384;				DDisplacement := 0.261;				SShape := 0.618;				TTranslation := 1.055;				Coarsegraininess := 2;				reach := 10;				GeneratingCurve := 152;				Handedness := 1;				TranslationGradient := 1;			end;		Sundial := theShell;	end;	function Fig: person;		var			theShell: person;	begin		with theShell do			begin				WOpening := 2;				DDisplacement := 0;				SShape := 3;				TTranslation := 3.5;				Coarsegraininess := 2;				reach := 8;				GeneratingCurve := 134;				Handedness := 1;				TranslationGradient := 0.95;			end;		Fig := theShell;	end;	function Tun: person;		var			theShell: person;	begin		with theShell do			begin				WOpening := 2;				DDisplacement := 0;				SShape := 2;				TTranslation := 2.8;				Coarsegraininess := 2;				reach := 8;				GeneratingCurve := 134;				Handedness := 1;				TranslationGradient := 1;			end;		Tun := theShell;	end;	function RazorShell: person;		var			theShell: person;	begin		with theShell do			begin				WOpening := 1000;				DDisplacement := 0;				SShape := 8;				TTranslation := 6;				MutProb := 50;				Coarsegraininess := 2;				reach := 1;				GeneratingCurve := 138;				Handedness := 1;				TranslationGradient := 1;			end;		RazorShell := theShell;	end;	function JapaneseWonder: person;		var			theShell: person;	begin		with theShell do			begin				WOpening := 1.7;				DDisplacement := 0;				SShape := 1.3;				TTranslation := 4.2;				MutProb := 50;				Coarsegraininess := 2;				reach := 8;				GeneratingCurve := 130;				Handedness := 1;				TranslationGradient := 1;			end;		JapaneseWonder := theShell;	end;	procedure RealToString (r: real; var theString: str255);		var			f: DecForm;			s: DecStr;	begin		f.style := FixedDecimal;		f.digits := 2;		Num2Str(f, r, s);		theString := str255(s);	end;	function StringToReal (s: str255): real;	begin		StringToReal := Str2Num(DecStr(s));	end;	function TwoToThe (n: integer): integer;		var			t: integer;	begin		case n of			0: 				t := 1;			1: 				t := 2;			2: 				t := 4;			3: 				t := 8;			4: 				t := 16;			5: 				t := 32;			6: 				t := 64;			7: 				t := 128;			8: 				t := 256;			9: 				t := 512;			10: 				t := 1024;			11: 				t := 2048;			12: 				t := 4096;			otherwise				t := 8192		end; {cases}		TwoToThe := t	end; {TwoToThe}	function TrapAvailable (theTrap: Integer): Boolean;		var			tType: TrapType;			numToolBoxTraps: Integer;	begin 		(* first determine the trap type *)		if BAND(theTrap, $0800) > 0 then			tType := ToolTrap		else			tType := OSTrap; 		(* next find out how may traps there are *)		if NGetTrapAddress(_InitGraf, ToolTrap) = NGetTrapAddress($AA6E, ToolTrap) then			numToolBoxTraps := $200		else			numToolBoxTraps := $400; 		(* check if trap number is too big for current trap table *)		if tType = ToolTrap then			begin				theTrap := BAND(theTrap, $07FF);				if theTrap >= numToolBoxTraps then					theTrap := _Unimplemented;			end; 		(* the trap is implemented if its address is different 	*) 		(* from the unimplemented trap's address				*)		TrapAvailable := NGetTrapAddress(theTrap, tType) <> NGetTrapAddress(_Unimplemented, ToolTrap);	end;{****************************************************}{ WNEIsImplemented}{}{ 	See if WaitNextEvent is implemented }{}{****************************************************}	function WNEIsImplemented: Boolean;		const			_WaitNextEvent = $A860;					{ WaitNextEvent trap					}		var			theWorld: SysEnvRec;						{ System environment				}			errCode: OSErr;	begin		errCode := SysEnvirons(1, theWorld);		{ Check environment					}		if theWorld.machineType < 0 then 			{ Old ROMs, definitely not present	}			WNEIsImplemented := FALSE		else											{ Check for WNE trap					}			WNEIsImplemented := TrapAvailable(_WaitNextEvent)	end;{****************************************************}{ TempMemCallsAvailable}{}{ 	Check whether the MultiFinder temporary memory calls are available}{}{****************************************************}	function TempMemCallsAvailable: Boolean;		const			_OSDispatch = $A88F;						{ Temporary MF memory calls		}	begin						{ Check for the OSDispatch trap	}		TempMemCallsAvailable := TrapAvailable(_OSDispatch);	end;{*	Dialog Manager utilities	*}{****************************************************}{ PositionDialog}{}{		Center the bounding box of a dialog or alert in the upper third}{		of the screen.  This is the preferred location according to the}{		Human Interface Guidelines.}{}{****************************************************}	procedure PositionDialog (theType: ResType; theID: integer);		var			theRect: Rect;			theRectPtr: RectPtr;		{ Ptr to bounding box of dialog	}			theTemplate: Handle;		{ Handle to resource template	}			left,							{ Left side of centered rect		}			top: integer;				{ Top side of centered rect		}	begin		{ The first field of the resource template for DLOG's and ALRT's 	}		{ is its bounding box.  Get a pointer to this rectangle.  This   			}		{ handle dereferencing is safe since the remaining statements in 	}		{ this function do not move memory (assignment and simple math). 	}		theTemplate := GetResource(theType, theID);		if resError <> noErr then			Exit(PositionDialog);	{If we fail to load it, forget about positioning}		theRectPtr := RectPtr(theTemplate^);		theRect := theRectPtr^;		if (theRect.left >= theRect.right) or (theRect.top >= theRect.bottom) then			Exit(PositionDialog); {Position Dialog is creating problems that I don't understand.  RD}{e.g. theRect can have a left bigger than its right}		{ Center horizontally on screen	}		left := (screenBits.bounds.right - (theRect.right - theRect.left)) div 2;		{ Leave twice as much space as above	 }		top := (screenBits.bounds.bottom - (theRect.bottom - theRect.top)) div 3;		{ Don't put rect under menu bar	}		if top < GetMBarHeight + 7 then			top := GetMBarHeight + 7;		theRect.right := theRect.right + left - theRect.left;		theRect.left := left;		theRect.bottom := theRect.bottom + top - theRect.top;		theRect.top := top;		theRectPtr^ := theRect;	end;{****************************************************}{ FindDLOGPosition}{}{ 		Return the coordinates of the top left corner of a dialog or alert}{ 		which centers the box in the upper third of the main screen. This is}{ 		the preferred location according to the Human Interface Guidelines.}{}{****************************************************}	procedure FindDlogPosition (theType: ResType; theID: integer; var corner: Point);		type			RectPtr = ^Rect;			RectHandle = ^RectPtr;		var			theRect: Rect;		{ Bounding box of dialog				}			left, top: integer;	{ Left, top side of centered rect		}	begin		{ The first field of the resource template for DLOG's and ALRT's 	}		{ is its bounding box.  Access this rectangle.  This   					}		{ handle dereferencing is safe since the remaining statements in 	}		{ this function do not move memory (assignment and simple math). 	}		theRect := RectHandle(GetResource(theType, theID))^^;		{ Center horizontally on screen	}		corner.h := (screenBits.bounds.right - (theRect.right - theRect.left)) div 2;		{ Leave twice as much space as above	 }		corner.v := (screenBits.bounds.bottom - (theRect.bottom - theRect.top)) div 3;		{ Don't put rect under menu bar	}		if corner.v < GetMBarHeight + 7 then			corner.v := GetMBarHeight + 7;	end;	function PICTFilter (param: ParmBlkPtr): Boolean;		var			Wanted: Boolean;	begin		Wanted := (param^.ioFlFndrInfo.fdCreator = 'SCRN');		PICTFilter := Wanted	end;	procedure ImportPICT;		var			PICTFileNum: Integer;			j: Integer;			ErrorCode, readErr: OSErr;			TheBiomorph: Person;			MyReply: SFReply;			myFileTypes: SFTypeList;			MyPoint: Point;			VRefNum: Integer;			dirID, procID: LongInt;			bytesToRead: LongInt;			thePict: PicHandle;	begin		FindDlogPosition('DLOG', sfGetDialogID, MyPoint);			{Calculate the position on screen}		MyFileTypes[0] := 'PICT';		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		SFGetFile(MyPoint, '', @PICTFilter, -1, myFileTypes, nil, MyReply);		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		if (MyReply.good) then			begin				PICTFileNum := OpenResFile(MyReply.fName);				thePict := GetPicture(0);				bytestoread := sizeof(thePict^^);				DrawPicture(thePict, thePict^^.PicFrame);			end	end;	procedure DeleteOldFile (volRefNum: Integer; dirID: LongInt; fileName: Str255);{If there was a crash, the fossil file may be present but busy. We need to convince the }{finder that it is okay to delete it}		var			info: CInfoPBRec;			info2: ParamBlockRec;			err: OSErr;	begin		with info do			begin				ioCompletion := nil;				ioNamePtr := @fileName;				ioDirID := dirID;				ioVRefNum := volRefNum;				ioFDirIndex := 0;				err := PBGetCatInfo(@info, FALSE);				if err = noErr then		{if it exists}					begin						if ioFRefNum <> 0 then   {File has been left open}							begin								info2.ioCompletion := nil;								info2.ioRefNum := ioFRefNum;								err := PBClose(@info2, FALSE);							end;						err := HDelete(volRefNum, dirID, fileName);					end;{if}			end;{with}	end;{DeleteOldFile}	function IsEOF (refNum: Integer; howClose: LongInt): Boolean;{Acts like Pascal's eof() function, but in addition you can specify how close to the end of the file}{you are allowed to be (takes care of truncated files)}		var			err: OSErr;			eof, positionNow: LongInt;	begin		IsEOF := TRUE;		err := GetFPos(refNum, positionNow);		err := GetEOF(refNum, eof);		if err <> noErr then			Exit(IsEOF);		{If something went wrong, we should stop reading}		IsEOF := (eof - positionNow) < howClose	end;	function FileSize (refNum: Integer): LongInt;		var			err: OSErr;			numBytes: LongInt;	begin		err := GetEOF(refnum, numBytes);		if err <> noErr then			numBytes := 0;	{Problem with the file, should signal an exception here.}		FileSize := numBytes;	end;{***** End of v1.1 additions*****}	function FossilsExist: Boolean;{replace, but not precisely mimic, Turbo's built-in function}		var			Err: OSErr;			filePos: LongInt;	begin		Err := GetFPos(slides, FilePos);		FossilsExist := FilePos > 0	end; {FossilsExist}	procedure DireMessage (prefs: SnailPreferencesHandle; string1ID, string2ID: Integer; var Verdict: Integer; YesNo: Boolean);{v1.1 changed DLOGs to ALRTs.}{}		var			theItem: Integer;			MessagePtr: DialogPtr;			string1, string2: Str255;	begin		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		GetIndString(string1, kAlertStringsID, string1ID);		GetIndString(string2, kAlertStringsID, string2ID);		ParamText(string1, string2, '', '');		if YesNo then			begin				if gSystem.systemVersion < $0700 then		{added v1.1}					PositionDialog('ALRT', 151);					{Save changes alert. YesNo?}				theItem := CautionAlert(151, nil);			end		else			begin				if gSystem.systemVersion < $0700 then		{added v1.1}					PositionDialog('ALRT', 17089);				theItem := CautionAlert(17089, nil);			end; { get dialog box}		Verdict := theItem;		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		FlushEvents(EveryEvent, 0);		ValidRect(prefs^^.Prect);	end; { of proc DireMessage }	procedure MemoryMessage (prefs: SnailPreferencesHandle; ID: Integer; InMessage: Str255; var Verdict: Integer); {27291 for Fewer album screens, 27295 for Careful}{*** Change this to handle appropriate type alerts with strings from STR# ***}{ v1.1 changed to alerts, position correctly on screen,}{ ID 4405 (got to quit) message changed to DisplayError call}		var			theItem: Integer;			MessagePtr: DialogPtr;	begin		SetCursor(prefs^^.CursList[CrossCursor]^^);		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		if (ID = 27295) then			InMessage := '';		ParamText('', InMessage, '', '');		if gSystem.systemVersion < $0700 then		{added v1.1}			PositionDialog('ALRT', ID);		theItem := CautionAlert(ID, nil);		Verdict := theItem;		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		FlushEvents(EveryEvent, 0);		ValidRect(prefs^^.Prect);	end; {MemoryMessage}	procedure SimpleMessage (prefs: SnailPreferencesHandle; ID: Integer; var Verdict: Integer);{v1.1 redesigned the alert slightly and made it a Caution Alert. This procedure}{seems to be always called with the same string ID. If more are added, the alert}{may need to be made less specific}		var			S: Stringhandle;	begin		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		S := GetString(ID);		ParamText(S^^, '', '', '');		if gSystem.systemVersion < $0700 then		{added v1.1}			PositionDialog('ALRT', 17089);		verdict := CautionAlert(17089, nil);	{changed v1.1}		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		FlushEvents(EveryEvent, 0);		ValidRect(prefs^^.Prect);	end; {SimpleMessage}	procedure HelpMessage (prefs: SnailPreferencesHandle; StrID: Integer);		var			HelpPtr: dialogPtr;			theItem, v: Integer;			S1, S2, S3, S4: Str255;	begin		GetIndString(S1, StrID, 1);		GetIndString(S2, StrID, 2);		GetIndString(S3, StrID, 3);		GetIndString(S4, StrID, 4);		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		ParamText(S1, S2, S3, S4);		if gSystem.systemVersion < $0700 then		{added v1.1}			PositionDialog('DLOG', 2000);		HelpPtr := GetNewDialog(2000, nil, Pointer(-1));		ModalDialog(nil, theItem);             { put dialog box up; get result }		DisposDialog(HelpPtr);               { get rid of dialog box         }  {ReStoreOffScreen(MainPtr^.PortRect,MyBitMap);}		FlushEvents(EveryEvent, 0);		ValidRect(prefs^^.Prect);	end; { of proc HelpMessage }	function stripped (s: str255): str255;{removes  spaces after number, for StringToNum}		var			j, n: integer;	begin		n := length(s);		j := pos(' ', s);		if j = 0 then			stripped := s		else			begin				delete(s, j, 1);				stripped := stripped(s)			end;	end; {stripped}	function LayoutDialog (var HoldConstant, RowChap, ColChap: MarchingOrders; var NRows, NCols: Integer): boolean;		const			LayoutDLogID = 135;		type			placetype = (row, col);		var			theDialog: dialogPtr;			theItem, v: Integer;			S1, S2, S3, S4: Str255;			tempRect: Rect;   												{Temporary rectangle}			DType: Integer;    												{Type of dialog item}			Index: Integer;     												{For looping}			DItem: Handle;     												{Handle to the dialog item}			CItem, CTempItem, PItem: controlhandle; 							{Control handle}			sTemp: Str255;   												{Get text entered, temp holding}			itemHit: Integer;  												{Get selection}			temp: Integer; 													{Get selection, temp holding}			ExitCondition: Boolean;			SmallPicture: PicHandle;			SavePort: WindowPtr;			rChap, cChap, hChap, WChap, DChap, TChap: MarchingOrders;		procedure Deposit (contents: integer; DITLNo: integer);		begin			GetDItem(theDialog, DITLNo, DType, DItem, tempRect);{Get item handle}			NumToString(contents, sTemp);			SetIText(DItem, sTemp);		end;		procedure DepositString (contents: str255; DITLNo: integer);		begin			GetDItem(theDialog, DITLNo, DType, DItem, tempRect);{Get item handle}			SetIText(DItem, contents);		end;		procedure Advance (place: placetype; var theChap: MarchingOrders);			var				s: str255;				theTill: real;				outchap: MarchingOrders;		begin			with theChap do				case kind of					Wop: 						begin							outChap := DChap;							s := 'D';							theTill := 1 + DDetails.till / DDetails.by;						end;					Dis: 						begin							outChap := TChap;							s := 'T';							theTill := 1 + TDetails.till / TDetails.by;						end;					Trans: 						begin							outChap := WChap;							s := 'W';							theTill := WDetails.till;						end;				end; {cases}			theChap := outChap;			case place of				row: 					begin						DepositString(s, 10);						Deposit(round(theTill), 12);					end;				col: 					begin						DepositString(s, 9);						Deposit(round(theTill), 8);					end;			end; {cases}		end; {advance}		procedure RefreshDialogue;		begin     												{Start of Refresh dialog}			DChap := HoldConstant;			WChap := RowChap;			TChap := colChap;			hChap := HoldConstant;			rChap := rowChap;			cChap := colChap;			advance(row, rchap);			advance(row, rchap);			advance(row, rchap);			advance(col, cChap);			advance(col, cChap);			advance(col, cChap);			DepositString('D', 14);		end; {RefreshDialog}   															{End of procedure}		procedure ExitDialogue;			var				tempRect: Rect;   												{Temporary rectangle}				DType: Integer;    												{Type of dialog item}				Index: Integer;     												{For looping}				DItem: Handle;     												{Handle to the dialog item}				CItem, CTempItem: controlhandle; 							{Control handle}				sTemp: Str255;   												{Get text entered, temp holding}				itemHit: Integer;  												{Get selection}				temp: Integer; 													{Get selection, temp holding}				LI: LongInt;			function fetch (DITLNo: integer): integer;				var					f: LongInt;			begin				GetDItem(theDialog, DITLNo, DType, DItem, tempRect);{Get item handle}				GetIText(DItem, sTemp);    							{Get the text entered}				sTemp := stripped(sTemp);				StringToNum(sTemp, f);				fetch := f;			end;		begin			rowChap := rChap;			colChap := cChap;			NRows := fetch(12);			NCols := Fetch(8);			case rowChap.kind of				Wop: 					case colChap.kind of						Dis: 							HoldConstant.Kind := Trans;						Trans: 							HoldConstant.Kind := Dis;					end;				Dis: 					case colChap.kind of						Wop: 							HoldConstant.Kind := Trans;						Trans: 							HoldConstant.Kind := Wop;					end;				Trans: 					case colChap.kind of						Wop: 							HoldConstant.Kind := Dis;						Dis: 							HoldConstant.Kind := Wop;					end;			end; {cases}		end; {ExitDialogue}	begin {Main LayoutDialog}		if gSystem.systemVersion < $0700 then		{added v1.1}			PositionDialog('DLOG', LayoutDLogID);		theDialog := GetNewDialog(LayoutDLogID, nil, Pointer(-1));		RefreshDialogue;		ExitCondition := false;		repeat			ModalDialog(nil, ItemHit);             { put dialog box up; get result }			ExitCondition := (ItemHit = 1) or (ItemHit = 2);			if ItemHit = 5 then				Advance(col, cChap);			if ItemHit = 6 then				Advance(row, rChap);			if cChap.kind = rChap.kind then				DepositString('', 14)			else				begin					case rChap.kind of						Wop: 							case cChap.kind of								Dis: 									DepositString('T', 14);								Trans: 									DepositString('D', 14);							end; {cases}						Dis: 							case cChap.kind of								Wop: 									DepositString('T', 14);								Trans: 									DepositString('W', 14);							end; {cases}						Trans: 							case cChap.kind of								Wop: 									DepositString('D', 14);								Dis: 									DepositString('W', 14);							end; {cases}					end; {cases}				end;			if (ItemHit = 1) and (cChap.kind = rChap.kind) then				begin					ExitCondition := false;				end;		until ExitCondition;		if ItemHit = 1 then			ExitDialogue;		DisposDialog(theDialog);               { get rid of dialog box         }		FlushEvents(EveryEvent, 0);		LayoutDialog := (ItemHit = 1);	end; {LayoutDialog}	function GenesDialog(prefs: SnailPreferencesHandle): Boolean;		var			GenesDlogPtr: dialogPtr;			theItem, v: Integer;			S1, S2, S3, S4: Str255;			tempRect: Rect;   												{Temporary rectangle}			DType: Integer;    												{Type of dialog item}			Index: Integer;     												{For looping}			DItem: Handle;     												{Handle to the dialog item}			CItem, CTempItem, PItem: controlhandle; 							{Control handle}			sTemp: Str255;   												{Get text entered, temp holding}			itemHit: Integer;  												{Get selection}			temp: Integer; 													{Get selection, temp holding}			ExitDialog: Boolean;			SmallPicture: PicHandle;			SavePort: WindowPtr;			GenCurve: integer;		procedure D_Refresh_Timing_Dialogue (theDialog: DialogPtr);			var				tempRect: Rect;   												{Temporary rectangle}				DType: Integer;    												{Type of dialog item}				Index: Integer;     												{For looping}				DItem: Handle;     												{Handle to the dialog item}				CItem, CTempItem: controlhandle; 							{Control handle}				sTemp: Str255;   												{Get text entered, temp holding}				itemHit: Integer;  												{Get selection}				temp: Integer; 													{Get selection, temp holding}				SavePort: WindowPtr;				SmallPicture: PicHandle;		begin     												{Start of Refresh dialog}			with child[special] do				begin					GetDItem(theDialog, 3, DType, DItem, tempRect);{Get item handle}					RealToString(WOpening, sTemp);					SetIText(DItem, sTemp);					GetDItem(theDialog, 4, DType, DItem, tempRect);{Get item handle}					RealToString(DDisplacement, sTemp);					SetIText(DItem, sTemp);					GetDItem(theDialog, 5, DType, DItem, tempRect);{Get item handle}					RealToString(SShape, sTemp);					SetIText(DItem, sTemp);					GetDItem(theDialog, 6, DType, DItem, tempRect);{Get item handle}					RealToString(TTranslation, sTemp);					SetIText(DItem, sTemp);					GetDItem(theDialog, 8, DType, DItem, tempRect);{Get item handle}					NumToString(CoarseGraininess, sTemp);					SetIText(DItem, sTemp);					GetDItem(theDialog, 9, DType, DItem, tempRect);{Get item handle}					NumToString(reach, sTemp);					SetIText(DItem, sTemp);					GetDItem(theDialog, 10, DType, DItem, tempRect);{Get item handle}					RealToString(TranslationGradient, sTemp);					SetIText(DItem, sTemp);					GetDItem(theDialog, 21, DType, DItem, tempRect);{Get item handle}					RealToString(MutProb, sTemp);					SetIText(DItem, sTemp);					if GeneratingCurve > 0 then						SmallPicture := GetPicture(GeneratingCurve);					GetDItem(theDialog, 25, DType, DItem, temprect);					GetPort(SavePort);					SetPort(theDialog);					EraseRect(Temprect);					if GeneratingCurve > 0 then						DrawPicture(SmallPicture, temprect)					else						FrameOval(temprect);					SetPort(SavePort);					GetDItem(theDialog, 27, DType, DItem, tempRect);{Get item handle}					NumToString(prefs^^.Threshold, sTemp);					SetIText(DItem, sTemp);{Now set radio buttons appropriately}					GetDitem(theDialog, 18, Dtype, DItem, temprect);					CItem := Pointer(DItem);					if Handedness = -1 then						SetCtlValue(Citem, 1)					else						SetCtlValue(Citem, 0);					GetDitem(theDialog, 19, Dtype, DItem, temprect);					CItem := Pointer(DItem);					if Handedness = 1 then						SetCtlValue(Citem, 1)					else						SetCtlValue(Citem, 0);				end;		end;   															{End of procedure}		procedure D_Exit_Timing_Dialogue (theDialog: DialogPtr; GenCurve: integer);			var				tempRect: Rect;   												{Temporary rectangle}				DType: Integer;    												{Type of dialog item}				Index: Integer;     												{For looping}				DItem: Handle;     												{Handle to the dialog item}				CItem, CTempItem: controlhandle; 							{Control handle}				sTemp: Str255;   												{Get text entered, temp holding}				itemHit: Integer;  												{Get selection}				temp: Integer; 													{Get selection, temp holding}				LI: LongInt;		begin     												{Start of Exit dialog}			with child[special] do				begin					GetDItem(theDialog, 3, DType, DItem, tempRect);{Get item handle}					GetIText(DItem, sTemp);    							{Get the text entered}					sTemp := stripped(sTemp);					WOpening := StringToReal(sTemp);					GetDItem(theDialog, 4, DType, DItem, tempRect);{Get item handle}					GetIText(DItem, sTemp);    							{Get the text entered}					sTemp := stripped(sTemp);					DDisplacement := StringToReal(sTemp);					if DDisplacement > 1 then						DDisplacement := 1;					if DDisplacement < 0 then						DDisplacement := 0;					GetDItem(theDialog, 5, DType, DItem, tempRect);{Get item handle}					GetIText(DItem, sTemp);    							{Get the text entered}					sTemp := stripped(sTemp);					SShape := StringToReal(sTemp);					GetDItem(theDialog, 6, DType, DItem, tempRect);{Get item handle}					GetIText(DItem, sTemp);    							{Get the text entered}					sTemp := stripped(sTemp);					TTranslation := StringToReal(sTemp);					GetDItem(theDialog, 8, DType, DItem, tempRect);{Get item handle}					GetIText(DItem, sTemp);    							{Get the text entered}					sTemp := stripped(sTemp);					CoarseGraininess := round(StringToReal(sTemp));					GetDItem(theDialog, 9, DType, DItem, tempRect);{Get item handle}					GetIText(DItem, sTemp);    							{Get the text entered}					sTemp := stripped(sTemp);					reach := round(StringToReal(sTemp));					GeneratingCurve := Gencurve;					if GeneratingCurve < 128 then						GeneratingCurve := 0;					GetDItem(theDialog, 10, DType, DItem, tempRect);{Get item handle}					GetIText(DItem, sTemp);    							{Get the text entered}					sTemp := stripped(sTemp);					TranslationGradient := StringToReal(sTemp);{IF TranslationGradient < 0 THEN}{TranslationGradient := 0;}					GetDItem(theDialog, 21, DType, DItem, tempRect);{Get item handle}					GetIText(DItem, sTemp);    							{Get the text entered}					sTemp := stripped(sTemp);					MutProb := StringToReal(sTemp);					if MutProb <= 0 then						MutProb := 0;					if MutProb >= 100 then						MutProb := 100;					GetDItem(theDialog, 27, DType, DItem, tempRect);{Get item handle}					GetIText(DItem, sTemp);    							{Get the text entered}					sTemp := stripped(sTemp);					prefs^^.Threshold := round(StringToReal(sTemp));{Now register state of radio buttons}					GetDitem(theDialog, 18, Dtype, DItem, temprect);					CItem := Pointer(DItem);					if GetCtlValue(CItem) = 1 then						Handedness := -1					else						Handedness := 1; {Only need to look at one radio button as the other must be opposite}				end;		end; 													{End of procedure}		procedure DrawTheIcon;		begin			SmallPicture := GetPicture(GenCurve);			GetDItem(GenesDLogPtr, 25, DType, DItem, temprect);			GetPort(SavePort);			SetPort(GenesDLogPtr);			EraseRect(Temprect);			if GenCurve = 0 then				FrameOval(TempRect)			else				DrawPicture(SmallPicture, temprect);			SetPort(SavePort);		end;	begin		if gSystem.systemVersion < $0700 then		{added v1.1}			PositionDialog('DLOG', GenesDLogID);		GenesDlogPtr := GetNewDialog(GenesDLogID, nil, Pointer(-1));		D_Refresh_Timing_Dialogue(GenesDLogPtr);		ExitDialog := false;		GenCurve := child[special].GeneratingCurve;		repeat			ModalDialog(nil, ItemHit);             { put dialog box up; get result }{Have we hit OK or a Radio Button?}			if (ItemHit = 1) or (ItemHit = 24) then {OK or Cancel}				ExitDialog := true;			if ItemHit = 29 then {increase Generating Curve}				begin					if GenCurve = 0 then						GenCurve := 126; {2 less than 128}					GenCurve := Gencurve + 2; {advance to next non-mirrored PICT ID}					if GenCurve > MaxResources then						GenCurve := 0;					DrawTheIcon;				end;			if ItemHit = 28 then {decrease Generating Curve}				begin					if GenCurve = 0 then						GenCurve := MaxResources + 2; {2 more than 128}					GenCurve := Gencurve - 2; {advance to next non-mirrored PICT ID}					if GenCurve < 128 then						GenCurve := 0;					DrawTheIcon;				end;			GetDItem(GenesDLogPtr, ItemHit, DType, DItem, temprect);			CItem := Pointer(DItem);			if ItemHit = 18 then {left-handed}				begin					SetCtlValue(CItem, 1);					GetDItem(GenesDLogPtr, 19, DType, DItem, temprect);					CItem := Pointer(DItem);					SetCtlValue(CItem, 0);				end;			if ItemHit = 19 then {right-handed}				begin					SetCtlValue(CItem, 1);					GetDItem(GenesDLogPtr, 18, DType, DItem, temprect);					CItem := Pointer(DItem);					SetCtlValue(CItem, 0);				end;		until ExitDialog;		if ItemHit = 1 then			D_Exit_Timing_Dialogue(GenesDLogPtr, Gencurve);		DisposDialog(GenesDlogPtr);               { get rid of dialog box         }		FlushEvents(EveryEvent, 0);		GenesDialog := ItemHit = 1;	end; {GenesDialog}	procedure SyringeMessage(prefs: SnailPreferencesHandle);{v1.1 Changed to alert, and set the first two alert stages to simple beeps}		var			SyrPtr: dialogPtr;			theItem: Integer;	begin		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		if gSystem.systemVersion < $0700 then		{added v1.1}			PositionDialog('ALRT', 30130);		theItem := Alert(30130, nil);		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		FlushEvents(EveryEvent, 0);		ValidRect(prefs^^.Prect);	end; { of proc SyringeMessage }	procedure ArrayDialog (var WDetails, DDetails, TDetails: MarchingOrders; var Verdict: integer);		const			ArrayDLogID = 134;		var			theDialog: dialogPtr;			theItem, v: Integer;			S1, S2, S3, S4: Str255;			tempRect: Rect;   												{Temporary rectangle}			DType: Integer;    												{Type of dialog item}			Index: Integer;     												{For looping}			DItem: Handle;     												{Handle to the dialog item}			CItem, CTempItem, PItem: controlhandle; 							{Control handle}			sTemp: Str255;   												{Get text entered, temp holding}			itemHit: Integer;  												{Get selection}			temp: Integer; 													{Get selection, temp holding}			ExitDialog: Boolean;			SmallPicture: PicHandle;			SavePort: WindowPtr;			GenCurve: integer;		procedure RefreshDialogue;			var				tempRect: Rect;   												{Temporary rectangle}				DType: Integer;    												{Type of dialog item}				Index: Integer;     												{For looping}				DItem: Handle;     												{Handle to the dialog item}				CItem, CTempItem: controlhandle; 							{Control handle}				sTemp: Str255;   												{Get text entered, temp holding}				itemHit: Integer;  												{Get selection}				temp: Integer; 													{Get selection, temp holding}				SavePort: WindowPtr;				SmallPicture: PicHandle;			procedure Deposit (contents: real; DITLNo: integer);			begin				GetDItem(theDialog, DITLNo, DType, DItem, tempRect);{Get item handle}				RealToString(contents, sTemp);				SetIText(DItem, sTemp);			end;		begin     												{Start of Refresh dialog}			with WDetails do				begin					deposit(start, 3);					deposit(till, 4);					deposit(by, 5);				end;			with DDetails do				begin					deposit(start, 9);					deposit(till, 10);					deposit(by, 11);				end;			with TDetails do				begin					deposit(start, 15);					deposit(till, 16);					deposit(by, 17);				end;		end; {RefreshDialogue}   															{End of procedure}		procedure ExitDialogue;			var				tempRect: Rect;   												{Temporary rectangle}				DType: Integer;    												{Type of dialog item}				Index: Integer;     												{For looping}				DItem: Handle;     												{Handle to the dialog item}				CItem, CTempItem: controlhandle; 							{Control handle}				sTemp: Str255;   												{Get text entered, temp holding}				itemHit: Integer;  												{Get selection}				temp: Integer; 													{Get selection, temp holding}				LI: LongInt;			function fetch (DITLNo: integer): real;			begin				GetDItem(theDialog, DITLNo, DType, DItem, tempRect);{Get item handle}				GetIText(DItem, sTemp);    							{Get the text entered}				sTemp := stripped(sTemp);				Fetch := StringToReal(sTemp);			end;		begin     												{Start of Exit dialog}			with WDetails do				begin					start := fetch(3);					till := fetch(4);					by := fetch(5);					kind := Wop;				end;			with DDetails do				begin					start := fetch(9);					till := fetch(10);					by := fetch(11);					kind := Dis;				end;			with TDetails do				begin					start := fetch(15);					till := fetch(16);					by := fetch(17);					kind := Trans;				end;		end; {ExitDialogue} 													{End of procedure}	begin		if gSystem.systemVersion < $0700 then		{added v1.1}			PositionDialog('DLOG', ArrayDLogID);		theDialog := GetNewDialog(ArrayDLogID, nil, Pointer(-1));		RefreshDialogue;		repeat			ModalDialog(nil, ItemHit);             { put dialog box up; get result }		until (ItemHit = 1) or (ItemHit = 2) or (ItemHit = 21);		if ItemHit <= 2 then			ExitDialogue;		DisposDialog(theDialog);               { get rid of dialog box         }		FlushEvents(EveryEvent, 0);		Verdict := ItemHit;	end; {ArrayDialog}	procedure Pause (Message: Str255);	begin		if Button then			repeat			until not Button; {Gotoxy(5,5); Writeln(message);}		repeat		until Button	end;	procedure SetItemState (Mndx, Indx: Integer; Flag: Boolean);{}{    purpose         if true, enables item Indx of menu Mndx; else disables}{    last update     22 Aug 86}{}	begin		if Flag then			EnableItem(MenuList[Mndx], Indx)		else			DisableItem(MenuList[Mndx], Indx)	end; { of proc SetItemState }	function RandInt (Max: Integer): Integer;	begin		randint := 1 + (abs(random) mod max);	end; {randint}	function Odd (i: Integer): Boolean;	begin		Odd := 2 * (i div 2) <> i	end;	function RandSwell (Indgene: Swelltype): SwellType;		var			r: 1..3;	begin		case Indgene of			Shrink: 				Randswell := Same;			Same: 				if randint(2) = 1 then					Randswell := Shrink				else					Randswell := Swell;			Swell: 				RandSwell := Same		end {Cases}	end; {RandSwell}	procedure EraseInnerRect (box: Rect);		var			InnerRect: Rect;	begin		with InnerRect do			begin				left := box.left + 1;				right := box.right - 1;				top := box.top + 1;				bottom := box.bottom - 1			end;		EraseRect(InnerRect)	end; {EraseInnerRect}	procedure FrameOuterRect (box: Rect);		var			OuterRect: Rect;	begin		with OuterRect do			begin				left := box.left - 1;				right := box.right + 1;				top := box.top - 1;				bottom := box.bottom + 1			end;		FrameRect(OuterRect)	end; {FrameOuterRect}	procedure FrameInnerRect (box: Rect);		var			InnerRect: Rect;	begin		with InnerRect do			begin				left := box.left + 1;				right := box.right - 1;				top := box.top + 1;				bottom := box.bottom - 1			end;		FrameRect(InnerRect)	end; {FrameInnerRect}	procedure StoreOffScreen (box: Rect; var Snapshot: BitMap);	begin		if FrontWindow = MainPtr then			CopyBits(MainPtr^.PortBits, Snapshot, box, box, srcCopy, nil);	end; {StoreOffScreen}	procedure RestoreOffScreen (box: Rect; Snapshot: BitMap);	begin {IF FrontWindow=MainPtr THEN}		CopyBits(Snapshot, MainPtr^.PortBits, box, box, srcCopy, nil);		ValidRect(box);			{**v1.1 since we have redrawn it already, }{we can stop the update event which would cause the window to be redrawn twice}	end; {RestoreOffScreen}	procedure CleanUp;{}{    purpose         to do whatever's needed before returning to Finder}{}		var			err: OSErr;	begin		err := FSClose(Slides);		err := HDelete(volRefNum, dirID, fileName);	end; { of proc CleanUp }	procedure MakeOffScreen (box: Rect; var Snapshot: BitMap; var Burst: Boolean);{From system 6 onwards we can use GWorlds instead of writing our own here - Alun}		var			bitsRowBytes, height: Integer;			ZeroRect: Rect;			tempPtr: Ptr;			SizeNeeded: LONGINT;	begin		with box do			begin				height := bottom - top;				bitsRowBytes := (((right - left - 1) div 16) + 1) * 2;			end;		with ZeroRect do			begin				left := 0;				right := box.right - box.left;				top := 0;				bottom := height			end;		SizeNeeded := LONGINT(bitsRowBytes) * LONGINT(height);		if (Memavail - SizeNeeded) < SafetyValve then			Burst := TRUE		else			begin				tempPtr := NewPtr(SizeNeeded);				if MemError <> noErr then					begin						Sysbeep(1);						ExitToShell;					end;   {No memory available}				Snapshot.baseaddr := tempPtr;				Snapshot.bounds := zerorect;				Snapshot.rowBytes := bitsRowBytes;				Burst := FALSE;			end;	end;{MakeOffScreen}	procedure MirrorBits (SourceBitmap: BitMap; RectOfInterest: Rect; var DestBitMap: BitMap);{Delivers a BitMap whose RectOfInterest is the left-right mirror image of the same rect in SourceBitmap}{Assumes that the two bitmaps have already had space assigned to them and have the same dimensions but different pointers}		var			row, ColBit, ReverseColbit, nrows, RowOffset: integer;			BitsAcross: Longint;{needs to be Longint because of BitTst}			SourceBit: Boolean;			SrcRowBaseAddr, DstRowBaseAddr: Ptr;	begin		with SourceBitMap do			begin				NRows := RectOfInterest.bottom - RectOfInterest.top;				BitsAcross := RectOfInterest.right - RectOfInterest.left;				for row := 1 to NRows do					begin						RowOffset := rowbytes * (row - 1);						SrcRowBaseAddr := Ptr(Longint(BaseAddr) + RowOffset);						DstRowBaseAddr := Ptr(Longint(DestBitMap.BaseAddr) + RowOffset);						for colbit := 0 to BitsAcross do							begin								ReverseColBit := BitsAcross - ColBit - 1;								SourceBit := BitTst(SrcRowBaseAddr, ColBit);								if SourceBit then									BitSet(DstRowBaseAddr, ReverseColBit)								else									BitClr(DstRowBaseAddr, ReverseColBit);							end;					end;			end	end; {MirrorBits}	procedure DrawInt (i: Integer);		procedure Drawi (i: Integer);			var				l, r: Integer;		begin			if i <= 9 then				drawchar(chr(ord('0') + i))			else				begin					l := i div 10;					r := i - 10 * l;					drawi(l);					drawi(r);				end;		end; {drawi}	begin {drawint proper}		if i < 0 then			begin				drawchar('-');				i := abs(i);			end		else			Drawchar('+');		drawi(i);	end; {drawint}	procedure DrawNumber (n: LongInt);		var			s: str255;	begin		NumToString(n, s);		Drawstring(s);	end;	procedure DrawReal (r: real);		var			numerator, remainder, den1, den2: LongInt;			theString: str255;	begin		if r < 0 then			begin				DrawString('-');				r := -r			end;		numerator := trunc(r);		DrawNumber(numerator);		remainder := round(100 * (r - numerator));		Drawstring('.');		if remainder < 10 then			begin				den1 := 0;				den2 := remainder			end		else			begin				den1 := remainder div 10;				den2 := remainder - 10 * den1			end;		DrawNumber(den1);		DrawNumber(den2);	end;	procedure Grow (var Box: Rect; d: Integer);	begin		with box do			begin				left := left - d;				right := right + d;				top := top - d;				bottom := bottom + d;			end;	end; {grow}	procedure BoxesOnly(prefs: SnailPreferencesHandle);		var			j: Integer;	begin		for j := 1 to NBoxes do			FrameRect(prefs^^.box[j]);		prefs^^.theMode := preliminary;	end; {BoxesOnly}{PROCEDURE DrawNum(n:Integer);}{VAR s,c:CHAR;}{BEGIN IF n<0 THEN s:='-' ELSE s:='+';}{n:=abs(n); c:=chr(n+48);}{DrawChar(s); DrawChar(c)}{END} {DrawNum;} {This is where frillsegment used to begin}	procedure OwnEditMenu(prefs: SnailPreferencesHandle);	begin		SetItemState(EM, 1, FALSE);		SetItemState(EM, 2, FALSE);		SetItemState(EM, 3, FALSE);		SetItemState(EM, 4, (Special > 0) and ((prefs^^.TheMode = Highlighting) or (prefs^^.TheMode = Albuming)));		SetItemState(EM, 5, FALSE);		SetItemState(EM, 6, FALSE);	end; {OwnEditMenu}	function DawkFilter (param: ParmBlkPtr): Boolean;		var			Wanted: Boolean;	begin		Wanted := (param^.ioFlFndrInfo.fdCreator = 'SNAW') and (param^.ioFlFndrInfo.fdType <> 'APPL') and (param^.ioFlFndrInfo.fdType <> 'FOSS');		DawkFilter := not Wanted	end;	procedure SmallMenus;		var			Indx: Integer;	begin		ClearMenuBar;		InsertMenu(MenuList[AM], 0);			 {This was commented out - Alun}		InsertMenu(SpecialBreedMenu, 0);		InsertMenu(MenuList[HM], 0);		DrawMenuBar;                   { draw updated menu bar to screen   }	end; {SmallMenus}	procedure LargeMenus(prefs: SnailPreferencesHandle);		var			indx: Integer;	begin		ClearMenuBar;		for Indx := 1 to MenuCnt do       { place menus in menu bar           }			InsertMenu(MenuList[Indx], 0);		OwnEditMenu(prefs);		DrawMenuBar;                   { draw updated menu bar to screen   }	end; {LargeMenus}	procedure BigFuncBox (Box: Rect; var Outbox: Rect);	begin		Outbox := box;		with Box do			begin				if Bottom - Top > Right - Left then					begin						Outbox.right := (Right + Left + Bottom - Top) div 2;						Outbox.left := outbox.right - (bottom - top)					end				else					begin						Outbox.bottom := (Top + Bottom + Right - Left) div 2;						Outbox.Top := Outbox.bottom - (right - left)					end			end;	end; {FuncBox}	procedure SmallFuncBox (Box: Rect; var Outbox: Rect; BoxSize: Integer);	begin		Outbox := box;		with Box do			begin				Outbox.Right := (Left + Right + BoxSize) div 2;				Outbox.left := Outbox.right - BoxSize;				Outbox.bottom := (top + bottom + Boxsize) div 2;				Outbox.top := Outbox.bottom - Boxsize			end;	end; {SmallFuncBox}	procedure FuncBox (Box: Rect; var Outbox: Rect; BoxSize: Integer);	begin		with Box do			if ((Right - Left) > BoxSize) or ((Bottom - Top) > Boxsize) then				BigFuncBox(Box, Outbox)			else				SmallFuncBox(Box, Outbox, Boxsize);		with Outbox do			begin				right := right + 1;				bottom := bottom + 1;			end;	end;	procedure Poop (n: Integer);		var			j: Integer;	begin {FOR j:=1 TO N DO Sysbeep(1)}	end; {poop}	procedure StartDocuments (DocumentCount: Integer);{v1.1 The original procedure would fail if you double click on a colour biomorph file,}{because those files have the same creator signiture but different file formats.}{Added check of file format - Alun}		var			j, k, volume, PersFile: Integer;			theFile: AppFile;			errorCode: OSErr;			dirID, procID, bytesToRead: LongInt;	begin		j := 0;		for k := 1 to DocumentCount do			begin				GetAppFiles(k, theFile);				with theFile do					if (fType = 'APPL') | not ((fType = 'RAUP') | (fType = 'RALB')) then						SysBeep(1)					else						begin							errorCode := GetWDInfo(vRefNum, volume, dirID, procID);							errorCode := HOpen(volume, dirID, fName, fsRdPerm, persFile);							if errorCode <> noErr then								SysBeep(1)							else								begin									while not ((IsEOF(PersFile, SizeOfPerson)) or (j >= MaxAlbum)) do										begin											j := succ(j);											bytesToRead := SizeOfPerson;											errorCode := FSRead(persFile, bytesToRead, @ThisMenagerie.Member[j]);											if errorCode <> noErr then												j := j - 1;										end;									errorCode := FSClose(PersFile)								end						end			end;		ThisMenagerie.Size := j;	end; {StartDocuments}{   *********   event handling routines   *********** }end.