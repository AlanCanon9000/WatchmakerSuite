unit unit_biomorphs;{token change}interface	uses{$IFC UNDEFINED THINK_Pascal}		Types,  {$ENDC}		unit_snail_types, unit_globals, unit_error, unit_miscellaneous;	var		min: Integer;	procedure Delayvelop (prefs: SnailPreferencesHandle; var Biomorph: Person;    Here: Point);	procedure SendToClipBoard(prefs: SnailPreferencesHandle);	procedure DoHighlight(prefs: SnailPreferencesHandle);	procedure DoBreed(prefs: SnailPreferencesHandle);	procedure DoRowMore(prefs: SnailPreferencesHandle);	procedure DoRowLess(prefs: SnailPreferencesHandle);	procedure DoColMore(prefs: SnailPreferencesHandle);	procedure DoColLess(prefs: SnailPreferencesHandle);	procedure Evolve (prefs: SnailPreferencesHandle; MLoc: point);	procedure DoResources (prefs: SnailPreferencesHandle; theBiomorph:    Person; WDetails, DDetails, TDetails: MarchingOrders);implementationuses{$IFC UNDEFINED THINK_Pascal}  Quickdraw, QuickdrawText, Events, SegLoad, Memory, ToolUtils, Files,  Scrap, OSUtils, TextUtils, StandardFile, Resources,{$ENDC}    unit_develop, unit_snapshot, unit_findthescale;	procedure Delayvelop (prefs: SnailPreferencesHandle; var Biomorph:    Person; Here: Point);		var			OffCentre: Point;	begin		prefs^^.Zeromargin := TRUE;		prefs^^.DelayedDrawing := false;		offCentre := develop(prefs, Biomorph, Here);	end; {Delayvelop}  procedure GrowChild (prefs: SnailPreferencesHandle; j: Integer);			var				k: LONGINT;		begin			Cliprect(prefs^^.Prect);			PenMode(PatXor);			MoveTo(Centre[Midbox].h, Centre[Midbox].v);			LineTo(Centre[j].h, Centre[j].v);			k := TickCount;			repeat			until TickCount >= k + 2;			MoveTo(Centre[Midbox].h, Centre[Midbox].v);			LineTo(Centre[j].h, Centre[j].v);			PenMode(PatCopy);			reproduce(prefs, child[MidBox], child[j]);			ClipRect(prefs^^.Box[j]);			delayvelop(prefs, Child[j], Centre[j]);		end;	procedure Evolve (prefs: SnailPreferencesHandle; MLoc: point);		var			j: Integer;			bytesToSave: LongInt;			err: OSErr;	begin		GlobalToLocal(Mloc);		j := 0;		repeat			j := j + 1		until (PtInRect(Mloc, prefs^^.box[j])) or (j > NBoxes);		if j <= NBoxes then			special := j		else			special := 0;		if special > 0 then			begin				ObscureCursor;				for j := 1 to NBoxes do					if j <> special then						EraseRect(prefs^^.box[j]);				PenPat(white);				Framerect(prefs^^.box[special]);				PenPat(MyPat);				Slide(prefs^^.box[special], prefs^^.box[MidBox]);				child[MidBox] := child[special];				SetUpBoxes(prefs);    {delayvelop(Child[MidBox],Centre[MidBox]);}				for j := 1 to MidBox - 1 do					Growchild(prefs, j);				for j := MidBox + 1 to NBoxes do					Growchild(prefs, j);			end;		ClipRect(prefs^^.Prect);		special := MidBox;		if fossilizing then			begin				bytesToSave := SizeOfPerson;				err := FSWrite(Slides, bytesToSave, @child[MidBox]);				FossilsToSave := TRUE			end;{****}	end; {evolve}	procedure DoRowMore(prefs: SnailPreferencesHandle);	begin		Nrows := Nrows + 2;		if NRows * Ncols > MaxBoxes then			NRows := NRows - 2;		EraseRect(prefs^^.Prect);		DoShowBoxes(prefs);		if special > 0 then			Delayvelop(prefs, Child[Special], Centre[MidBox]);		OldSpecial := 0;	end; {DoRowMore}	procedure DoRowLess(prefs: SnailPreferencesHandle);	begin		if Nrows > 1 then			Nrows := Nrows - 2;		EraseRect(prefs^^.Prect);		DoShowBoxes(prefs);		if special > 0 then			Delayvelop(prefs, Child[Special], Centre[MidBox]);		OldSpecial := 0;	end; {DoRowLess}	procedure DoColMore(prefs: SnailPreferencesHandle);	begin		Ncols := Ncols + 2;		if NRows * Ncols > MaxBoxes then			NCols := NCols - 2;		EraseRect(prefs^^.Prect);		DoShowBoxes(prefs);		if special > 0 then			Delayvelop(prefs, Child[Special], Centre[MidBox]);		OldSpecial := 0;	end; {DoColMore}	procedure DoColLess(prefs: SnailPreferencesHandle);	begin		if NCols > 1 then			NCols := Ncols - 2;		EraseRect(prefs^^.Prect);		DoShowBoxes(prefs);		if special > 0 then			Delayvelop(prefs, Child[Special], Centre[MidBox]);		OldSpecial := 0;	end; {DoColLess}	procedure DoBreed(prefs: SnailPreferencesHandle);		var			p: point;	begin		prefs^^.TheMode := breeding;		OldBox := special;		EraseRect(prefs^^.PRect);{IF Margin.bottom - Margin.top > Box[MidBox].bottom - Box[Midbox].top THEN}{NRows := 1;}		SetUpBoxes(prefs);		OldSpecial := 0;		SetCursor(prefs^^.CursList[watchCursor]^^);		Child[MidBox] := child[special];		Special := MidBox;		MakeGeneBox(prefs, Child[special]);		Delayvelop(prefs, Child[Special], Centre[MidBox]);		p := centre[MidBox];		p.v := prefs^^.box[MidBox].bottom - 1;		Evolve(prefs, p);		StoreOffScreen(MainPtr^.PortRect, MyBitMap);	end; {DoBreed}	procedure DoHighlight(prefs: SnailPreferencesHandle);		var			j: Integer;			Ticking: Boolean;			TickValue: LongInt;	begin		Ticking := FALSE;    with prefs^^ do      begin		    if (TheMode = Phyloging) or (TheMode = Moving)        or (TheMode = Detaching) or (TheMode = Killing) then {OR (theMode=Noahing)}			    begin				    InvertRect(SpecialFull^^.Surround);				    TickValue := TickCount;				    Ticking := TRUE;			    end;		    if (theMode = breeding) or (TheMode = Drifting) then			    begin				    OldSpecial := Special;				    InvertRect(box[Special]);				    TheMode := Highlighting;				    MakeGeneBox(prefs, child[special]);			    end;		    if theMode = Albuming then			    OldSpecial := Special;      end;		if Ticking then			begin				repeat				until TickCount - TickValue >= 30;				InvertRect(SpecialFull^^.Surround);			end	end; {DoHighlighting}	procedure PictureToScrap(prefs: SnailPreferencesHandle);		var			LENGTH: LongInt;	begin		if ZeroScrap <> NoErr then			begin				Sysbeep(1); {write('ZeroScrap Error')}			end		else			begin				HLock(handle(MyPicture));				Length := MyPicture^^.PicSize;				if PutScrap(Length, 'PICT', Ptr(MyPicture^)) <> NoErr then					ExitToShell;				HUnlock(handle(MyPicture));			end;		prefs^^.ClipBoarding := TRUE;	end;	procedure SendToClipBoard(prefs: SnailPreferencesHandle);		var			HS: Integer;			errString, helpString: Str255;	begin		MyPicture := OpenPicture(prefs^^.Box[MidBox]);		Delayvelop(prefs, Child[Special], Centre[MidBox]);		CopiedAnimal := Child[special];		ClosePicture;		HS := GetHandleSize(Handle(MyPicture));		if (HS = 0) or (HS > 32000) then			begin				errString := GetString(131)^^;				helpString := GetString(132)^^;				DisplayError(0, errString, helpString, StopError);{was: (uses Help dialog! ) Message(GetString(TooLargeString))}			end		else			PictureToScrap(prefs);		KillPicture(MyPicture);	end; {SendToClipBoard}	procedure DoResources (prefs: SnailPreferencesHandle; theBiomorph: Person;    WDetails, DDetails, TDetails: MarchingOrders);		var			maxy, y, theID, ErrorMessage,        ShellFileNumber, MainFileNumber: integer;			W, D, T: real;			thePicture: PicHandle;			s1, s2, s3, theString: str255;			HSize: LongInt;			MyHandle: Handle;			MyReply: SFReply;			MyPoint: Point;			offsetPoint: Point;		procedure theDeed;		begin			with theBiomorph do				begin					DDisplacement := D;					WOpening := W;					TTranslation := T;					ClipRect(prefs^^.Prect);					EraseRect(prefs^^.Prect);					thePicture := OpenPicture(prefs^^.Box[MidBox]);					ShowPen;					offsetPoint := Develop(prefs, theBiomorph, Centre[MidBox]);					with prefs^^.Box[Midbox] do						begin							MoveTo(left + 2, bottom - 2);							RealToString(WOpening, s1);							RealToString(DDisplacement, s2);							RealToString(TTranslation, s3);							theString := concat('W=', s1, ' ', 'D=', s2, ' ', 'T=', s3);							DrawString(theString);						end;					ClosePicture;					repeat						theID := UniqueID('PICT')					until theID >= 128;					MyHandle := handle(thePicture);					HSize := SizeOf(thePicture);					if HSize > 32000 then						sysbeep(1)					else						begin							ShellFileNumber := OpenResFile(MyReply.fname);							UseResFile(ShellFileNumber);							AddResource(MyHandle, 'PICT', theID, theString);							ErrorMessage := ResError;							if ErrorMessage = NoErr then								WriteResource(MyHandle)							else								ErrorMessage := ErrorMessage;						end;					CloseResFile(ShellFileNumber);					KillPicture(thePicture);					UseResFile(MainFileNumber);				end; {with biomorph}		end;{theDeed}	begin		prefs^^.theMode := arraying;		MainFileNumber := CurResFile;		FindDlogPosition('DLOG', PutDlgID, MyPoint);		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		SFPutFile(MyPoint, '', '', nil, MyReply);		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		if MyReply.good then			begin				CreateResFile(MyReply.fname);				W := WDetails.start;				Maxy := round(Wdetails.till);				for y := 1 to maxy do					begin						D := DDetails.start;						while D < DDetails.till do							begin								T := TDetails.start;								while T < TDetails.till do									begin										theDeed;										T := T + TDetails.by;									end; {x loop}								D := D + DDetails.by							end; {D loop}						w := w * WDetails.By;					end;{W loop}			end; {my reply good}	end; {DoResources}end.