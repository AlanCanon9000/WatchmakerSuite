unit unit_album;{******************************************}{*						v1.1 Sept 1993													 *}{*		Changed file commands to Mac File manager					 	 *}{*		Removed Repeat/Until loop in DoClose								 *}{******************************************}interface	uses   {$IFC UNDEFINED THINK_Pascal}		Types, ErrorsMac,  {$ENDC}   unit_snail_types, unit_globals, unit_engineering, unit_biomorphs,   unit_snapshot, unit_error, unit_develop;	procedure DoLoad (prefs: SnailPreferencesHandle; WithDialogue: Boolean);	procedure SaveSlides(prefs: SnailPreferencesHandle);	procedure ResetFossils;	procedure ReadAnimals (prefs: SnailPreferencesHandle; var ThisMenagerie: Menagerie);	procedure DoSave (prefs: SnailPreferencesHandle; HowMuch: Integer);	procedure GracefulDeath(prefs: SnailPreferencesHandle);	procedure DoClose(prefs: SnailPreferencesHandle);	procedure StoreBreedingScreen(prefs: SnailPreferencesHandle);	procedure AddToAlbum (prefs: SnailPreferencesHandle; Biomorph: Person);	procedure Emphasize (prefs: SnailPreferencesHandle; MLoc: point);	procedure Zoom(prefs: SnailPreferencesHandle);	procedure UnCurtainPage (prefs: SnailPreferencesHandle; p: Integer);	procedure TakeCare (prefs: SnailPreferencesHandle; Page: Integer);	procedure ClosePlayBack(prefs: SnailPreferencesHandle);	procedure StartPlayBack(prefs: SnailPreferencesHandle);	procedure SaveAnimals (prefs: SnailPreferencesHandle; ThisMenagerie: Menagerie; Foss: Boolean);	procedure DoPlayBack (prefs: SnailPreferencesHandle; MLoc: Point);	function AlbumFull: Boolean;implementationuses{$IFC UNDEFINED THINK_Pascal}	Controls, Files, Quickdraw, Windows, Events, StandardFile, TextUtils,  ToolUtils, OSUtils, QuickdrawText, Dialogs, SegLoad, {Errors}{$ENDC}		unit_miscellaneous, unit_findthescale;	var		StoreMode: Mode;		StoreOldSpecial: Integer;{moved from globals, used only in StoreBreedingScreen and RestoreBreedingScreen}	procedure MyAction (prefs: SnailPreferencesHandle; MyControl: ControlHandle; PartCode: Integer);		var			p: longint;			err: OSErr;			bytesToRead: LongInt;			offsetPoint: Point;	begin		case PartCode of			0: 				; {SysBeep(1)}			inUpButton: 				begin					FossilCounter := FossilCounter - 1;					if FossilCounter < 0 then						FossilCounter := 0;				end;			inDownButton: 				begin					FossilCounter := FossilCounter + 1;					if FossilCounter > NumberinFile then						FossilCounter := NumberinFile				end;			inPageUp: 				begin					FossilCounter := FossilCounter - 1;					if FossilCounter < 0 then						FossilCounter := 0;				end;			inPageDown: 				begin					FossilCounter := FossilCounter + 1;					if FossilCounter > NumberinFile then						FossilCounter := NumberinFile				end;			inThumb: 				begin					FossilCounter := GetCtlValue(myControl)				end;			otherwise   {SysBeep(1)}		end; {Cases}		if PartCode <> 0 then			begin				SetCtlValue(myControl, FossilCounter);				err := SetFPos(Slides, fsFromStart, 0);				p := 0;				repeat					bytesToRead := SizeOfPerson;					err := FSRead(slides, bytesToRead, @theBiomorph);	{??? It looks as if this reads only the last biomorph}					p := p + 1				until (err = eofErr) or (p = 1 + NumberinFile - FossilCounter);				eraserect(PlayBackRect);				offsetPoint := Develop(prefs, theBiomorph, MidPoint);			end;{IF NOT Fossilizing THEN}		Child[special] := theBiomorph;	end; {MyAction}	procedure DoPlayBack (prefs: SnailPreferencesHandle; MLoc: Point);		var			thePart: Integer;			theControl: ControlHandle;	begin {DoPlayBack}		PlayBackRect := PlayBackPtr^.PortRect;		with PlayBackRect do			begin				right := right - Scrollbarwidth - 1;				bottom := bottom - Scrollbarwidth - 1;				MidPoint.h := (right - left) div 2;				MidPoint.v := (bottom - top) div 2			end;		if NumberInFile >= 1 then			begin				thePart := FindControl(MLoc, PlayBackPtr, theControl);				if thePart = inThumb then					begin						thePart := TrackControl(theControl, MLoc, nil);						MyAction(prefs, theControl, thePart)					end				else					thePart := TrackControl(theControl, MLoc, @MyAction);			end;{InvalRect(TheControl^^.ContrlRect);}	end; {DoPlayBack}	procedure StartPlayBack(prefs: SnailPreferencesHandle);		var			bytesRead: LongInt;			err: OSErr;			offsetPoint: Point;	begin		SmallMenus(prefs);		if FrontWindow = MainPtr then			StoreOffScreen(MainPtr^.PortRect, MyBitMap);		NumberInFile := 0;		err := SetFPos(Slides, fsFromStart, 0);		err := GetEOF(slides, bytesRead);		if bytesRead >= SizeOf(Person) then			repeat		{??? This reading is done twice in the procedure}				NumberInFile := NumberInFile + 1;				bytesRead := SizeOfPerson;				err := FSRead(Slides, bytesRead, @theBiomorph);			until err = eofErr;		err := SetFPos(Slides, fsFromStart, 0);		{v1.1  was reset(Slides);}		NumberInFile := NumberInFile - 1;		SetUpBoxes(prefs);		SelectWindow(PlayBackPtr);		SetPort(PlayBackPtr);		ShowWindow(PlayBackPtr);		frontw := PlayBackPtr;		SetCtlMax(MyControl, NumberInFile);		SetCtlMin(MyControl, 0);		SetCtlValue(MyControl, 0);		DrawControls(PlayBackPtr);		DrawGrowIcon(PlayBackPtr);		SaveMode := prefs^^.theMode;		prefs^^.TheMode := PlayingBack;		FossilCounter := 0;		PlayBackRect := PlayBackPtr^.PortRect;		with PlayBackRect do			begin				right := right - Scrollbarwidth - 1;				bottom := bottom - Scrollbarwidth - 1;				MidPoint.h := (right - left) div 2;				MidPoint.v := (bottom - top) div 2			end;		FirstBiomorph := theBiomorph;		Child[special] := theBiomorph;		offsetPoint := Develop(prefs, theBiomorph, MidPoint);	end; {StartPlayBack}	procedure ClosePlayBack(prefs: SnailPreferencesHandle);{NB this didn't really close the window, it doesn't even hide it, it just moves it behind the main window}{v1.1 changed it to hide the window instead (caused problems when I hide the main window in bg)}	begin		HideWindow(playbackPtr);		SelectWindow(MainPtr);		Frontw := MainPtr;		SetPort(MainPtr);		prefs^^.TheMode := SaveMode;		FlushEvents(EveryEvent, 0);{ValidRect(Prect);}		LargeMenus(prefs);	end; {ClosePlayBack}	procedure SaveAnimals (prefs: SnailPreferencesHandle; ThisMenagerie: Menagerie; Foss: Boolean);		{In the case of a single biomorph, Child[special] has already been}{		placed in ThisMenagerie [ 1 ] }		var			ThisFile: Integer;			OurPrompt: Str255;			thePrompt: StringHandle;			j: Integer;			ErrorCode: OSErr;			MyReply: SFReply;			MyPoint: Point;			MyFileType: OSType;			VRefNum: Integer;			dirID, procID: LongInt;			bytesToSave: Longint;	begin		DotheSave := FALSE;		FindDlogPosition('DLOG', PutDlgID, MyPoint);{v1.1 originally called sfPutDialogID, but this resource only exists under system 7! putDlgID is the old style box}		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		if Foss then			ThePrompt := GetString(9520)		else			begin				if ThisMenagerie.Size = 1 then					ThePrompt := GetString(3866)				else					ThePrompt := GetString(10281)			end;		OurPrompt := ThePrompt^^;{ThePrompt := GetString(AsString);   - Don't think this does anything - Alun}		SFPutFile(MyPoint, OurPrompt, LastPutFileName, nil, MyReply);		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		if ThisMenagerie.Size = 1 then			MyFiletype := 'RAUP'		else			MyFiletype := 'RALB';		if MyReply.good then			begin				LastPutFileName := MyReply.fname;				SetCursor(prefs^^.CursList[WatchCursor]^^);				ErrorCode := GetWDInfo(myreply.vrefnum, vRefNum, dirID, procID);				DeleteOldFile(vRefNum, dirID, myReply.fname);				errorCode := HCreate(vrefnum, dirID, myreply.fname, 'SNAW', MyFileType);				if errorCode <> noErr then					begin  {Use the offscreen bitmap procs if applicable}						IOError(errorCode, 'Check disk and try again');						Exit(SaveAnimals)					end;				errorCode := HOpen(myreply.vrefnum, dirID, myreply.fname, fsRdWrPerm, ThisFile);				if errorCode <> noErr then					begin						IOError(errorCode, 'Check disk and try again');						Exit(SaveAnimals)					end;				if foss then					FossilsToSave := FALSE;				with ThisMenagerie do					for j := 1 to Size do						begin							bytesToSave := SizeOfPerson;							errorCode := FSWrite(ThisFile, bytesToSave, @Member[j]);							if errorCode <> noErr then								begin									IOError(errorCode, 'Check disk and try again');									errorCode := FSClose(thisFile);									Exit(SaveAnimals)								end;						end;				errorCode := FSClose(ThisFile);			end		else			Finished := FALSE;		LastPutFileName := MyReply.fname;		if prefs^^.theMode = Engineering then			Delayvelop(prefs, child[special], centre[MidBox]); {Correct displacement bug}		FlushEvents(EveryEvent, 0);		ValidRect(prefs^^.Prect);	end; {Save Animals}	procedure SaveSlides(prefs: SnailPreferencesHandle);		var			ThisMenagerie: Menagerie;			aFossil: Person;			err: OSErr;			bytesToRead: LongInt;	begin		DotheSave := FALSE;	{put it here in case we don't need to call SaveAnimals}		ThisMenagerie.Size := 0;		err := SetFPos(Slides, fsFromStart, 0);		{v1.1  was reset(Slides);}{Check to see if at least one fossil is in slides}		err := GetEOF(slides, bytesToRead);{IF bytesToRead < SizeOfPerson THEN Exit(SaveSlides);}		while not IsEOF(slides, SizeOfPerson) do			begin				bytesToRead := SizeOfPerson;				err := FSRead(slides, bytesToRead, @aFossil);				ThisMenagerie.Size := ThisMenagerie.Size + 1;				ThisMenagerie.Member[ThisMenagerie.Size] := aFossil			end; {while}		SaveAnimals(prefs, ThisMenagerie, TRUE);	end; {SaveSlides}	procedure ResetFossils;		var			err: OSErr;	begin		Fossilizing := TRUE; 	{Reset Fossil Record}		err := SetEOF(slides, 0);	end; {ResetFossils}	procedure ShowAlbumPage (prefs: SnailPreferencesHandle; p: Integer);	begin {StoreOffScreen(MainPtr^.PortRect,MyBitMap);}		if OldSpecial > 0 then			InvertRect(prefs^^.Box[OldSpecial]);		OldSpecial := 0;		CopyBits(AlbumBitMap[p], MainPtr^.PortBits, MainPtr^.PortBits.Bounds, MainPtr^.PortBits.Bounds, srcCopy, nil);{ReStoreOffScreen(MainPtr^.PortRect,MyBitMap);}	end; {ShowAlbumPage}	procedure ReadAnimals (prefs: SnailPreferencesHandle; var ThisMenagerie: Menagerie);		var			ThisFile: Integer;			j: Integer;			ErrorCode, readErr: OSErr;			TheBiomorph: Person;			MyReply: SFReply;			myFileTypes: SFTypeList;			MyPoint: Point;			VRefNum: Integer;			dirID, procID: LongInt;			bytesToRead: LongInt;	begin		FindDlogPosition('DLOG', sfGetDialogID, MyPoint);			{Calculate the position on screen}		MyFileTypes[0] := 'RAUP';		MyFileTypes[1] := 'RALB'; {****}		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		SFGetFile(MyPoint, '', @DawkFilter, -1, myFileTypes, nil, MyReply);		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		if (MyReply.good) then{AND (ErrorCode = NoErr) }			begin				errorCode := GetWDInfo(myReply.vRefNum, vRefNum, dirID, procID);				if Album.Size > 0 then					AlbumChanged := TRUE;				with myReply do					errorCode := HOpen(vRefNum, dirID, fname, fsRdWrPerm, thisFile);				if LoadingFossils then					errorCode := SetEOF(slides, 0);	{was Rewrite(slides);	}				j := 0;				while not ((IsEOF(ThisFile, sizeOfPerson)) or (j >= MaxAlbum)) do					begin						j := j + 1;						if not LoadingFossils then							begin								bytesToRead := SizeOfPerson;								readErr := FSRead(thisFile, bytesToRead, @ThisMenagerie.member[j])							end						else							begin								bytesToRead := SizeOfPerson;								readErr := FSRead(ThisFile, bytesToRead, @TheBiomorph);								errorCode := FSWrite(Slides, bytesToRead, @TheBiomorph);							end;					end;    {while}				errorCode := FSClose(ThisFile);				if not LoadingFossils then					begin						ThisMenagerie.Size := j;						prefs^^.theMode := albuming;					end			end		else			begin {Sysbeep(1);}				ThisMenagerie.Size := 0			end;		if ThisMenagerie.Size > MaxAlbum then			ThisMenagerie.Size := MaxAlbum;		LastGetFileName := MyReply.fname;		if LoadingFossils and (MyReply.good) and (ErrorCode = NoErr) then    {BEGIN Child[Special]:=TheBiomorph;}{    DoBreed;}{    Fossilizing:=TRUE;}{    ValidRect(PRect);}{    END;}			begin				errorCode := SetFPos(Slides, fsFromStart, 0);		{v1.1  was reset(Slides);}				StartPlayBack(prefs);			end;	end; {ReadAnimal}	procedure TakeCare (prefs: SnailPreferencesHandle; Page: Integer);		var			j: Integer;			PageStart: Integer;	begin		PageStart := ((Page - 1) * NBoxes) mod Album.Size;		for j := 1 to PBoxNo[Page] do			begin				Special := j;				Child[j] := Album.Member[PageStart + j]			end;		OldSpecial := 0;		prefs^^.TheMode := Albuming;		NActiveBoxes := PBoxNo[Page];		CurrentPage := Page;		SetCursor(prefs^^.CursList[BlackCursor]^^);	end; {TakeCare}	procedure StickInAlbum(prefs: SnailPreferencesHandle); {Only called (once) by DoLoad}		var			TitleRect: Rect;			Bust: Boolean;			Albstr: Stringhandle;	begin		if Page = 0 then			Page := 1;		Bust := FALSE;		TitleRect := prefs^^.Prect;		TitleRect.Bottom := prefs^^.PRect.Top + GenesHeight;{Morph is initially set to 1. It increases by 1 when a new one is stuck in album}		while (Morph <= Album.Size) and not Bust do			begin				if (BoxNo > NBoxes) then					begin						BoxNo := 1;						Page := Page + 1;						if Page > MaxPages then							begin								Bust := TRUE;								Sysbeep(1);{4 pages of album already full}								Album.Size := Morph;								Page := MaxPages							end					end; {case of new page needed}				if not Bust then					begin						if BoxNo = 1 then							begin								ClipRect(prefs^^.PRect);								EraseRect(prefs^^.Prect);								OldSpecial := 0;								MoveTo(200, 15);								TextSize(12);								TextFace([]);								AlbStr := GetString(AlbumPageID);								DrawString(Concat(AlbStr^^, ' ', char(Page + 48))); {changed v1.1}								TextSize(9);								StoreOffScreen(prefs^^.PRect, AlbumBitMap[Page]);							end;						ClipRect(prefs^^.Box[BoxNo]);						DelayVelop(prefs, Album.Member[Morph], Centre[BoxNo]);						PBoxNo[Page] := BoxNo;{range check failed}						Album.Place[Morph].Page := Page;						Album.Place[Morph].BoxNo := BoxNo;						StoreOffScreen(prefs^^.Box[BoxNo], AlbumBitMap[Page]);						Morph := Morph + 1;						BoxNo := BoxNo + 1;						ClipRect(prefs^^.Prect);						CurrentPage := Page;						TakeCare(prefs, Page);        {AlbumNRows:=NRows; AlbumNCols:=NCols;}					end			end	end; {StickInAlbum}	procedure UnCurtainPage (prefs: SnailPreferencesHandle; p: Integer);		var			LSlice, RSlice: Rect;			Mid: Integer;			TickValue: LongInt;	begin {CurtainPage;}    with prefs^^ do      begin		    Mid := (Prect.Right - Prect.Left) div 2;		    LSlice := Prect;		    with LSlice do			    begin				    Right := Mid;				    Left := Mid - 8			    end;		    RSlice := Prect;		    with RSlice do			    begin				    Left := Mid;				    Right := Mid + 8			    end;		    while LSlice.Left > Prect.Left do			    begin				    if Button then					    BrokenOut := TRUE;				    CopyBits(AlbumBitMap[p], MainPtr^.PortBits, LSlice, LSlice, srcCopy, nil);				    CopyBits(AlbumBitMap[p], MainPtr^.PortBits, RSlice, RSlice, srcCopy, nil);				    OffSetRect(LSlice, -8, 0);				    OffSetRect(Rslice, 8, 0);			    end;      end;    EraseRect(LSlice);		EraseRect(RSlice);	end; {UnCurtainPage}	procedure DoLoad (prefs: SnailPreferencesHandle; WithDialogue: Boolean);		var			i, j, k: Integer;	begin		SetCursor(prefs^^.CursList[WatchCursor]^^);		if Album.Size > 0 then			begin				UnCurtainPage(prefs, Page);				prefs^^.theMode := Albuming			end;		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		if WithDialogue then			ReadAnimals(prefs, ThisMenagerie);		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);{I think that ideally this should be handled by DoUpdate, but we}{    don't visit GetNextEvent before other things are done}		if ThisMenagerie.Size > 0 then			begin				k := 0;				i := album.size;				NBoxes := NRows * NCols;				while (k < ThisMenagerie.Size) and (i < MaxAlbum) do					begin						k := succ(k);						i := i + 1;						album.member[i] := ThisMenagerie.member[k];					end;				Album.Size := i;				StickInAlbum(prefs);				if OldSpecial = 0 then					begin						OldSpecial := Special;						InvertRect(prefs^^.Box[special])					end;				AlbumEmpty := FALSE;				StoreOffScreen(MainPtr^.PortRect, MyBitMap);			end;		if FrontWindow = MainPtr then			StoreOffScreen(MainPtr^.PortRect, MyBitMap);{IF TheMode=Highlighting THEN}{    BEGIN InvertRect(Box[Special]); OldSpecial:=0 END;}{theMode:=Albuming;}		if Button then			repeat			until not Button;		FlushEvents(everyEvent, 0);		ValidRect(prefs^^.PRect);		if Album.Size > MaxAlbum then			Album.Size := MaxAlbum;	end; {DoLoad}	procedure StoreBreedingScreen(prefs: SnailPreferencesHandle);		var			j: Integer;	begin		StoreMode := prefs^^.TheMode; {either breeding or highlighting}		StoreOldSpecial := OldSpecial;		for j := 1 to BreedNBoxes do			StoreChild[j] := Child[j];{IF TheMode=Highlighting THEN}{    BEGIN IF OldSpecial>0 THEN InvertRect(Box[OldSpecial]);}{    OldSpecial:=0}{    END;}		StoreOffScreen(MainPtr^.PortRect, AlbumBitMap[0]);{AlbumBitMap[0] is special reserve bitmap for breeding screen}		SomethingToRestore := (prefs^^.theMode = Breeding) or (prefs^^.theMode = Highlighting)	end; {StoreBreedingScreen}	procedure RestoreBreedingScreen(prefs: SnailPreferencesHandle);		var			j: Integer;	begin		if OldSpecial > 0 then			InvertRect(prefs^^.Box[OldSpecial]);		for j := 1 to BreedNBoxes do			Child[j] := StoreChild[j];		NRows := BreedNRows;		NCols := BreedNCols;		prefs^^.TheMode := Preliminary; {To prevent SetUpBoxes drawing boxes}		SetUpBoxes(prefs);		Special := MidBox;		prefs^^.TheMode := StoreMode;		ReStoreOffScreen(MainPtr^.PortRect, AlbumBitMap[0]);		NActiveBoxes := NBoxes;		OldSpecial := StoreOldSpecial;		SomethingToRestore := FALSE;		if prefs^^.TheMode = Highlighting then			begin				if OldSpecial > 0 then					InvertRect(prefs^^.Box[OldSpecial]);				OldSpecial := 0			end;	end;{RestoreBreedingScreen}	procedure AddToAlbum (prefs: SnailPreferencesHandle; Biomorph: Person);		var			StoreSpecial: Integer;	begin		AlbumChanged := TRUE;		StoreSpecial := Special;		ThisMenagerie.Size := 1;		ThisMenagerie.Member[1] := Biomorph; {In order to use Load}		DoLoad(prefs, FALSE);		Special := StoreSpecial;		RestoreBreedingScreen(prefs);		if prefs^^.TheMode = Engineering then			DoEngineer(prefs);	end; {AddToAlbum}	procedure DoSave (prefs: SnailPreferencesHandle; HowMuch: Integer);		var			ThatMenagerie: Menagerie;	begin		if FrontWindow = MainPtr then			StoreOffScreen(MainPtr^.PortRect, MyBitMap);		case HowMuch of			1: 				begin					ThatMenagerie.member[1] := Child[Special];					ThatMenagerie.Size := 1;					SaveAnimals(prefs, ThatMenagerie, FALSE)				end; {Save Biomorph}			2: 				begin				end;			3: 				begin					SaveAnimals(prefs, Album, FALSE);					if DoTheSave then						AlbumChanged := FALSE				end		end {CASES}	end; {DoSave}	procedure GracefulDeath(prefs: SnailPreferencesHandle);{This is used only for abnormal terminations, normal ones simple set finished to true and exit the main loop}{v1.1 fixed}		var			string1, string2: Str255;			theItem: Integer;	begin		if AlbumChanged then			begin				if gSystem.systemVersion < $0700 then					PositionDialog('ALRT', 152);				GetIndString(string1, kAlertStringsID, kAlbumID);				GetIndString(string2, kAlertStringsID, kClosingID);				ParamText(string1, string2, '', '');				theItem := CautionAlert(152, nil);				if theItem = 1 then					DoSave(prefs, 3); {Yes}			end;		if FossilsToSave then			begin				if gSystem.systemVersion < $0700 then					PositionDialog('ALRT', 152);				GetIndString(string1, kAlertStringsID, kFossilsID);				ParamText(string1, string2, '', '');				theItem := CautionAlert(152, nil);				if theItem = 1 then					SaveSlides(prefs); {Yes}			end;		CleanUp;		ExitToShell;		{Removed from cleanup to allow normal termination}	end; {GracefulDeath}	procedure DoClose(prefs: SnailPreferencesHandle);		var			Verdict: Integer;	begin		Verdict := 0;		if AlbumChanged then			begin				DireMessage(prefs, kAlbumID, kClosingID, Verdict, true);				if Verdict = 1 then					DoSave(prefs, 3); {Yes}				if Verdict = 3 then					Finished := FALSE; {Cancel}			end;		if (Verdict <> 3) or (not AlbumChanged) then			begin				Page := 0;				BoxNo := 1;				Morph := 1;				CurrentPage := 0;				Album.Size := 0;				EraseRect(prefs^^.Prect);				StoreOffScreen(MainPtr^.PortRect, MyBitMap);				prefs^^.TheMode := Preliminary;				NActiveBoxes := 0;{Special:=0;}				AlbumEmpty := TRUE			end;	end;	procedure Emphasize (prefs: SnailPreferencesHandle; MLoc: point);		var			j: Integer;	begin		GlobalToLocal(Mloc);		j := 0;		repeat			j := j + 1		until (PtInRect(Mloc, prefs^^.box[j])) or (j > NActiveBoxes);		if j <= NActiveBoxes then			begin				if danger then					danger := FALSE				else					begin						special := j;						if oldspecial > 0 then							InvertRect(prefs^^.box[OldSpecial]);						InvertRect(prefs^^.box[special]);        {MakeGeneBox(child[special]);}						oldspecial := special					end			end;	end; {emphasize}	procedure Zoom(prefs: SnailPreferencesHandle);		var			Quadrant: array[1..4] of Rect;			j, OldQuadrant, ThisQuadrant, MaxPage: Integer;			MLoc: POINT;	begin		EraseRect(prefs^^.Prect);		for j := 1 to 4 do			Quadrant[j] := prefs^^.Prect;		with prefs^^.Prect do			begin				Quadrant[1].top := top + 15;				Quadrant[2].top := top + 15;				Quadrant[1].right := Left + (right - Left) div 2;				Quadrant[1].Bottom := Top + (Bottom - Top) div 2;				Quadrant[3].Right := Quadrant[1].Right;				Quadrant[3].Top := Quadrant[1].Bottom;				Quadrant[2].Left := Quadrant[1].Right;				Quadrant[2].Bottom := Quadrant[1].Bottom;				Quadrant[4].Left := Quadrant[2].Left;				Quadrant[4].Top := Quadrant[2].Bottom			end;		for j := 1 to Page do			CopyBits(AlbumBitMap[j], MainPtr^.PortBits, prefs^^.Prect, Quadrant[j], srcCopy, nil);		OldQuadrant := 0;		ThisQuadrant := 1;		repeat			GetMouse(Mloc);			if MLoc.v < Quadrant[1].top then				SetCursor(Arrow)			else				begin					SetCursor(prefs^^.CursList[LensCursor]^^);					j := 0;					repeat						j := j + 1					until (j = 4) or (PtInRect(Mloc, Quadrant[j]));					if (OldQuadrant <> j) and (j <= Page) then						begin							PenSize(3, 3);							PenMode(PatXor);							if OldQuadrant <> 0 then								begin {PenPat(White);}									FrameRect(Quadrant[OldQuadrant]);            {PenPat(Black)}								end;							if j <= Page then								begin									FrameRect(Quadrant[j]);									OldQuadrant := j;								end;							PenSize(PSize, PSize);							PenMode(PatCopy);						end;				end;		until Button;		CopyBits(AlbumBitMap[OldQuadrant], MainPtr^.PortBits, prefs^^.Prect, prefs^^.Prect, srcCopy, nil);		TakeCare(prefs, OldQuadrant);		with MLoc do			begin				h := 2 * (h - Quadrant[OldQuadrant].left);				v := 2 * (v - Quadrant[OldQuadrant].Top)			end;		emphasize(prefs, Mloc);		zoomed := TRUE;	end; {Zoom}	function AlbumFull: Boolean;		var			AF: Boolean;	begin		AF := FALSE;		if (Page = 4) then			begin				if PBoxNo[Page] = (AlbumNRows * AlbumNCols) then					AF := TRUE			end;		AlbumFull := AF	end; {AlbumFull}end.