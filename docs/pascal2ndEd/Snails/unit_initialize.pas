unit unit_initialize;{These routines are called once only at startup.  Keep this file in a separate segment that can be unloaded}{At present, initialize proc is *very* long, mostly because of the vast numbers of global vars. We should try}{to cut this down, splitting the proc up and giving vars file scope or less where possible}{History}{v1.1  Added system check}{		   Added attempts to save temp file in several places (v1.01 failed on locked server volumes) }{          Removed calls to toolbox inits (done automatically by Think Pascal)}{          Removed calls to MoreMasters (10 calls "             "       "        "   )}{          No longer lock down cursors throughout program execution}{			Improved out of memory warnings (but still some plain ExitToShells in there) }interface uses unit_snail_types;	procedure Initialize(prefs: SnailPreferencesHandle);implementation	uses{$IFC UNDEFINED THINK_Pascal}		think_pascal, Types, OSUtils, Quickdraw, GestaltEqu, StandardFile, Files,    SegLoad, TextUtils, Dialogs, ToolUtils, Memory, Windows, Controls, Menus,    QuickdrawText, Events,{$ENDC}		Traps, Script, Folders, unit_error, unit_pedigree,  unit_drawpic,    unit_snapshot, unit_globals, unit_miscellaneous, unit_findthescale,    unit_standard_get_folder;	{Private uses, keeps compilation speed up}(************************************************}{* 											InspectSystem										   *}{*																										    	*}{*	Gather information about the current OS												*}{*	Added for v1.1.  We collect more info than we really need at present 	*}{************************************************)	procedure InspectSystem;		var			err: Integer;			environs: SysEnvRec;			response: Longint;			myFeature: Integer;	begin		gSystem.hasGestalt := TrapAvailable(_GestaltDispatch);		gSystem.hasWNE := WNEIsImplemented;		gSystem.hasScriptMgr := TrapAvailable(_ScriptUtil);		gSystem.scriptsInstalled := 1; (* assume only Roman script	*)		err := SysEnvirons(1, environs);		if (err = noErr) then			begin				gSystem.hasColorQD := environs.hasColorQD;				gSystem.hasFPU := environs.hasFPU;				gSystem.systemVersion := environs.systemVersion; {2-byte hex number, eg $0710 or $0607}				gSystem.sysVRefNum := environs.sysVRefNum;			end		else			begin				gSystem.hasColorQD := FALSE;				gSystem.hasFPU := FALSE;				gSystem.systemVersion := 0;			end;		if (gSystem.hasGestalt) then			{copied from TCL, but I am not sure this always works}			begin				gSystem.hasAppleEvents := Gestalt(gestaltAppleEventsAttr, response) = noErr;				gSystem.hasAliasMgr := Gestalt(gestaltAliasMgrAttr, response) = noErr;				gSystem.hasEditionMgr := Gestalt(gestaltEditionMgrAttr, response) = noErr;				gSystem.hasHelpMgr := Gestalt(gestaltHelpMgrAttr, response) = noErr;				gSystem.hasFolderMgr := Gestalt(gestaltFindFolderAttr, response) = noErr;				if (gSystem.hasScriptMgr) then					begin						err := Gestalt(gestaltScriptCount, response);						if (err = noErr) then							gSystem.scriptsInstalled := Integer(response);					end;			end		else	(* If we don't have Gestalt, then we can't have any System 7 features	*)			begin				gSystem.hasAppleEvents := FALSE;				gSystem.hasAliasMgr := FALSE;				gSystem.hasEditionMgr := FALSE;				gSystem.hasFolderMgr := FALSE;				gSystem.hasHelpMgr := FALSE;				if (gSystem.hasScriptMgr) then					gSystem.scriptsInstalled := GetEnvirons(smEnabled);			end;	end;{************************************************}{*	 We follow this strategy to deal with servers and locked volumes:	  	    *}{*		1) Try to save into the temp folder on the default disk	(sys 7)			*}{* 	2) Try to save in the System folder													*}{*		3) Try to save in the same folder as the application							*}{* 	4) Ask the user																					*}{* 	5) If all the above fail, quit with message to user								*}{*    6) If there is a fossil history file already, delete it							*}{************************************************}	procedure CreateHistoryFile;		const			No = 2;		{Button number in alert}		var			err, ignore: OSErr;			foundVRefNum: Integer;										{vRefNum and dirID of temp folder}			foundDirID, procID: LongInt;			answer: Integer;												{Alert button pressed}			reply: SFReply;			errString, errCode: Str255;								{String for alerts}			where: Point;													{For positioning SFPutFile dialog}		procedure GetAFolder (var volRefNum: Integer; var dirID: LongInt; fName: Str255);{If we have System 7 available we can ask user for a folder if there is trouble. Under System 6}{we use SFGetFile in the main CreateHistoryFile proc to ask to save the file (maybe this stuff}{can be converted to system 6?)}			var				mySFReply: StandardFileReply;				myFSSpec: FSSpec;		begin			where.h := -1;							{Get the system to position the box}			where.v := -1;			StandardGetFolder(where, 'Save temp file to:', mySFReply);			if not mySFReply.sfGood then	{User cancelled}				ExitToShell;			volRefNum := mySFReply.sfFile.vRefNum;			dirID := mySFReply.sfFile.parID;			err := FSMakeFSSpec(mySFReply.sfFile.vRefNum, mySFReply.sfFile.parID, fName, myFSSpec);			if err <> noErr then				Exit(GetAFolder);			err := FSpCreate(myFSSpec, 'SNAW', 'FOSS', mySFReply.sfScript); {We will exit the loop if this succeeded}		end; {GetAFolder}	begin		fileName := 'Fossil History';		volRefNum := defaultVolNum;		dirID := defaultDir;		err := -1;		{set it to anything but noErr to start}		if gSystem.hasFolderMgr then			if FindFolder(volRefNum, kTemporaryFolderType, kCreateFolder, foundVRefNum, foundDirID) = noErr then				begin		{If we found the temp folder, we will try to use it. Otherwise use default folder}					volRefNum := foundVRefNum;					dirID := foundDirID;					DeleteOldFile(volRefNum, dirID, fileName);				{There may already be a file left open after a crash. }					err := HCreate(volRefNum, dirID, fileName, 'SNAW', 'FOSS');				end;		if err <> noErr then			begin						{Second try under system 7, first try under system 6}				ignore := GetWDInfo(gSystem.sysVRefNum, volRefNum, dirID, procID);				DeleteOldFile(volRefNum, dirID, fileName);				err := HCreate(volRefNum, dirID, fileName, 'SNAW', 'FOSS');			end;		if err <> noErr then			begin			{try the default directory}				volRefNum := defaultVolNum;				dirID := defaultDir;				DeleteOldFile(volRefNum, dirID, fileName);				err := HCreate(volRefNum, dirID, fileName, 'SNAW', 'FOSS');			end;		if err <> noErr then			begin	{ask the user to choose a place}				GetIndString(errString, 128, 1);				NumToString(err, errCode);				ParamText(errString, errCode, '', '');				PositionDialog('ALRT', 200);				answer := StopAlert(200, nil);			{'Problem saving temp file, do you want to choose a folder?'}				if answer = No then					ExitToShell;				if gSystem.systemVersion >= $0700 then					GetAFolder(volRefNum, dirID, fileName)	{System 7 ask for folder}				else					begin														{System 6 normal save file dialog}						FindDlogPosition('DLOG', PutDlgID, where);{NB NOT sfPutDialogID! That is the System 7 style dialog, which doesn't exist in earlier systems}						SFPutFile(where, 'Save temp file to', fileName, nil, reply);						with reply do							begin								if not good then	{User cancelled operation}									ExitToShell;								ignore := GetWDInfo(vRefNum, volRefNum, dirID, procID);								fileName := fname;								err := HCreate(volRefNum, dirID, fileName, 'SNAW', 'FOSS');							end;{with}					end;{if not sys7}			end;{if}		if err = noErr then		{Okay, we have a file, now try to open it. }			err := HOpen(volRefNum, dirID, fileName, fsRdWrPerm, slides);		if err <> noErr then			begin				GetIndString(errString, 128, 2);				IOError(err, errString);									{ 'Error opening temp file'}				err := HDelete(volRefNum, dirID, fileName);					{Try to clean up after ourself}				ExitToShell			end;	{if}	end;{CreateHistoryFile}	procedure LoadCursors(prefs: SnailPreferencesHandle);{* Load Cursors from resources.   v1.1 renumbered cursors to allow looping. }{* We no longer lock handles, just prevent them from being purged. *}		var			indx: Integer;	begin		for Indx := iBeamCursor to watchCursor do					{ get four standard system cursors}			begin				prefs^^.CursList[Indx] := GetCursor(Indx); 							{ read in from system resource}				HNoPurge(Handle(prefs^^.CursList[Indx]));			end;		for indx := leftCursID to BlankCursID do						{Now load custom cursors}			begin				prefs^^.CursList[indx - 130] := GetCursor(indx);				HNoPurge(Handle(prefs^^.CursList[indx - 130]));					{make sure they don't get purged}			end;		SetCursor(prefs^^.CursList[watchCursor]^^);								{ bring up watch cursor}	end;	{LoadCursors}	procedure Initialize(prefs: SnailPreferencesHandle);{}{    purpose         initialize everything for the program}{NB Think Pascal sets up toolbox managers, flushes event queue, and calls MoreMasters 10x}		var			SizeNeeded: LONGINT;			j, i: Integer;			ToldToStop: Boolean;			errString, helpString: Str255;			aTime: Longint;	         { keeps track of time }			AlbumBounds: Rect;			ErrorCode: OSErr;			ThumbStrip: Rect;	begin		FossilsToSave := FALSE;		AlbumEmpty := TRUE;		ErrorCode := HGetVol(@DefaultVolume, DefaultVolNum, DefaultDir);	{v1.1 changed to get dirID as well}		if errorcode <> NoErr then			ExitToShell;		InspectSystem;							{**ADDED v1.1*}		CreateHistoryFile;					{      "                 }		Fossilizing := FALSE;    { set up window stuff }		GetWMgrPort(ScreenPort);          			{ get grafport for all windows      }		SetPort(ScreenPort);              				{ and keep hand just in case        }    with prefs^^ do      begin        Prect := ScreenBits.Bounds;		    with PRect do			    begin				    Left := Left + 2;				    Top := Top + 20;				    Right := Right - 2;				    Bottom := Bottom - 2;			    end;		    PlayBackRect := PRect;		    PlayBackRect.Top := PRect.Top + 70;		    PlayBackRect.Left := PRect.Left + 50;		    PlayBackRect.Bottom := PRect.Bottom - 50;		    PlayBackRect.Right := PRect.Right - 50;		    MainPtr := NewWindow(@MainRec, PRect, '', TRUE, plainDbox, Pointer(-1), FALSE, 0);    { get window }      end;    SetPort(MainPtr);                 					{ set window to current graf port   }		MainPeek := WindowPeek(MainPtr);  			{ get pointer to window record      }		MainPeek^.windowKind := PascalKind; 			{ set window type  (ID=32700)}		SelectWindow(MainPtr);           					{ and make window active            }		frontw := MainPtr;           						{ remember that it's in front       }		PlayBackPtr := NewWindow(@PlayBackRecord, PlaybackRect, 'Fossils', FALSE, DocumentProc, Pointer(-1), TRUE, 0);    { get window }		WindowPeek(PlayBackPtr)^.windowKind := PascalKind;		PlayBackRect := PlayBackPtr^.PortRect;		ThumbStrip := PlayBackPtr^.PortRect;		with PlayBackRect do			begin				right := right - Scrollbarwidth - 1;				bottom := bottom - Scrollbarwidth - 1;				MidPoint.h := (right - left) div 2;				MidPoint.v := (bottom - top) div 2			end;		with PlayBackPtr^.PortRect do			begin				ThumbStrip.left := right - (ScrollBarWidth - 1);				thumbStrip.top := top - 1;				thumbStrip.right := right + 1;				ThumbStrip.bottom := (bottom + 1) - (ScrollBarWidth - 1);			end;		LoadCursors(prefs);		{Changed v1.1}		MyControl := NewControl(PlayBackPtr, ThumbStrip, '', true, 0, 0, 0, ScrollBarProc, 0);		MakeOffScreen(MainPtr^.PortBits.Bounds, MyBitMap, burst);		if burst then			begin			{Not enough Memory - Added alert v1.1}				GetIndString(errString, 128, 3);				GetIndString(helpString, 128, 4);				DisplayError(-108, errString, helpString, StopError);				ExitToShell			end;		AlbumBounds := MainPtr^.PortBits.Bounds;		SizeNeeded := LONGINT(8 * PicSizeMax);		if LongInt((Memavail - SizeNeeded)) < SafetyValve then			begin{MemoryMessage(4405, 'in setting up space for biomorph linked list', Verdict);  v1.1 changed to below}				GetIndString(errString, 128, 5);	{** v1.1 **}				GetIndString(helpString, 128, 4);				DisplayError(-108, errString, helpString, StopError);				ExitToShell			end;		prefs^^.MyPic.BasePtr := NewPtr(LongInt(SizeNeeded));		if MemError <> noErr then			ExitToShell;		RootGod := GodHandle(NewHandle(SizeOf(God)));		if MemError <> noErr then			ExitToShell;		RootGod^^.Adam := nil;		RootGod^^.NextGod := nil;		RootGod^^.PreviousGod := nil;		ThatFull := Created(prefs);		SizeOfPerson := SizeOf(Person);	{v1.1 Saves calculating it before every save to file}		ToldToStop := FALSE;		MaxPages := 4;		{v1.1 was 1, but in turbo was a constant set to 4}		j := 0;		repeat			MakeOffScreen(AlbumBounds, AlbumBitMap[j], burst);			if burst then				begin					MaxPages := j - 1;					NumToString(MaxPages, errString);					if MaxPages >= 1 then						begin							MemoryMessage(prefs, 27291, errString, Verdict)						end					else						begin							GetIndString(errString, 128, 20);	{** v1.1 **}							GetIndString(helpString, 128, 4);							DisplayError(-108, errString, helpString, StopError);							ExitToShell;{MemoryMessage(4405, 'No room for Bitmap screens', Verdict)}						end				end			else				j := j + 1;			ToldToStop := burst or (j > 4)		until ToldToStop;		if MaxPages < 1 then			ExitToShell;		ScreenArea := screenBits.Bounds;  { get size of screen (don't assume) }		with ScreenArea do			begin				SetRect(DragArea, 20, 20, Right - 5, Bottom - 10);   { set drag region       }				SetRect(GrowArea, 50, 20, Right - 5, Bottom - 10);   { set grow region       }    {MoveWindow(MainPtr,Left+1,Top+36,TRUE);}{    SizeWindow(MainPtr,Right-1,bottom-36,TRUE);}			end;  { set up menus }		MenuList[AM] := GetMenu(ApplMenu);{ read menus in from resource fork  }		MenuList[FM] := GetMenu(FileMenu);		MenuList[EM] := GetMenu(EditMenu);		MenuList[OM] := GetMenu(OperMenu);		MenuList[BM] := GetMenu(BoxMenu);		MenuList[MM] := GetMenu(AnimalsMenu);		MenuList[PM] := GetMenu(PedigreeMenu);		MenuList[HM] := GetMenu(HelpMenu);		SpecialBreedMenu := GetMenu(SpecMenu);		AddResMenu(MenuList[AM], 'DRVR');  { pull in all desk accessories      }		LargeMenus(prefs);		NRows := 3;		Ncols := 5;		NBoxes := NRows * NCols;		BreedNBoxes := NBoxes;		AlbumNRows := NRows;		AlbumNCols := NCols;		BreedNRows := NRows;		BreedNCols := NCols;		FossilCounter := 0;		prefs^^.TheMode := Preliminary;		SetUpBoxes(prefs);		prefs^^.Margin := prefs^^.Box[MidBox];{Starting value for self-adjusting Box Number routine}		Page := 1;		BoxNo := 1;		Morph := 1;		prefs^^.Prect := MainPtr^.portRect;  (*SetPortBits (MainPtr^.portbits); needed here? *)		CopyBits(MainPtr^.PortBits, AlbumBitMap[Page], prefs^^.PRect, prefs^^.PRect, srcCopy, nil);{ program-specific initialization }  {Close(Slides);}		Finished := False;                 { set program terminator to false   }		for j := 6 to MutTypeNo do			Mut[j] := FALSE;		for j := 1 to 5 do			Mut[j] := TRUE;				{** changed 1.1 **}		for j := 1 to 6 do			SetItemState(EM, j, FALSE);		TextSize(9);		TextFace([]);		Album.size := 0;		OldSpecial := 0;		Special := 0;{ShowPen;}		prefs^^.TheMode := Preliminary;		SetUpBoxes(prefs); {Needed only to define MidBox. Doesn't show because not breeding}		prefs^^.DelayedDrawing := FALSE;		OldBox := 0;		for j := 1 to 4 do			SetItemState(BM, j, TRUE);		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		for j := 1 to MaxPages do			PBoxNo[j] := 0;		CurrentPage := 1;		Page := 1;		LastPutFileName := '';		LastGetFileName := '';		aTime := TickCount;		repeat			j := random		until Tickcount > aTime + 50;{GetDateTime(RandSeed);}		SomethingToRestore := FALSE;		Region2 := NewRgn;		DestRegion := NewRgn;		SaveRegion := NewRgn;		Rays := 1;		OldSpecialFull := nil;		SpecialFull := nil;		CheckItem(MenuList[PM], 4, TRUE);		CheckItem(MenuList[PM], 5, FALSE);		CheckItem(MenuList[PM], 6, FALSE);		with MidScreen do      with prefs^^ do			  begin				  h := PRect.Left + (Prect.right - Prect.left) div 2;				  v := PRect.Top + (PRect.Bottom - PRect.Top) div 2			  end;		MyPenSize := 1;{PrDrvrOpen;}		SweepOn := FALSE;		hideInBackGround := FALSE;		{by default, we leave windows alone. Under System 6 this might make disks unaccessable}		AlbumChanged := FALSE;		Danger := FALSE;		GetIndString(AsymString, 12947, 1);		GetIndString(BilatString, 12947, 2);		GetIndString(SingleString, 12947, 3);		GetIndString(UpDnString, 12947, 4);		GetIndString(RadialString, 12947, 5);		SetItemState(EM, 5, FALSE);		Zoomed := FALSE;		OldMode := Breeding;		prefs^^.ClipBoarding := FALSE;		Naive := TRUE;		WarningHasBeenGiven := FALSE;		{inc := 16; ABC THink does nothing, since there's one in develop routines}		pensize(PSize, PSize);		MyPat := Black;		ShellColour := LtGray;		PenPat(MyPat);		Incy := 1;{set up default triangle anchors}		Topan := snail;		Leftan := Turritella;		Rightan := bivalve;		prefs^^.SideView := true;		prefs^^.Threshold := 20;		InitDrawPic;    with WDetails do			begin				start := 1.2;				by := 1.5;				till := 10;			end;		with DDetails do			begin				start := 0;				by := 0.2;				till := 0.6;			end;		with TDetails do			begin				start := 0;				by := 2;				till := 8;			end;	end; { of proc Initialize }end.