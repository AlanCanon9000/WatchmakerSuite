unit unit_triangle;interfaceuses{$IFC UNDEFINED THINK_Pascal}  Types, Quickdraw, {$ENDC}  unit_snail_types,	unit_globals, unit_miscellaneous,  unit_snapshot, unit_error, unit_develop;	procedure AtLeast (var OutRect: Rect);	procedure OwnCursor (prefs: SnailPreferencesHandle; theRect: Rect; fromBitMap: BitMap; var theCursor: Cursor);	procedure MainTriangle(prefs: SnailPreferencesHandle);	procedure PlotTriangle (prefs: SnailPreferencesHandle; MLoc: point; Localswitch: Boolean);	procedure FlickerTriangle (prefs: SnailPreferencesHandle; MLoc: Point);implementationuses{$IFC UNDEFINED THINK_Pascal}		think_pascal, OSUtils, SegLoad, TextUtils, Memory, ToolUtils,{$ENDC} unit_drawpic;	procedure Triangle (var r1, r2, r3: real; b: point; m: point);		var			x, y, k: real;			screenheight: LONGINT;	begin		screenheight := screenbits.bounds.bottom - screenbits.bounds.top;		k := round(200 * screenheight / 340);		x := m.h - b.h;		y := (screenheight - m.v) - (screenheight - b.v);		r1 := y / k;		r3 := (x - y / 2) / k;		r2 := (k - x - y / 2) / k;	end; {triangle}	procedure DrawTriangle (a, b, c: point);	begin		Moveto(a.h, a.v);		LineTo(b.h, b.v);		LineTo(c.h, c.v);		LineTo(a.h, a.v);	end; {drawtriangle}	procedure Concoct (r1, r2, r3: real; a, b, c: person; var new: person);		var			hand, j, weight: Integer;		function Force3 (r: real): Integer;			var				i: Integer;		begin			i := round(r);			if i > 2 then				i := 2;			if i < 0 then				i := 0;			Force3 := i		end; {Force3}		function Force2 (r: real): Integer;			var				i: Integer;		begin			i := round(r);			if i > 1 then				i := 1;			if i < 0 then				i := 0;			Force2 := i		end; {Force2}	begin		with new do			begin				Wopening := exp(r1 * ln(a.Wopening) + r2 * ln(b.Wopening) + r3 * ln(c.Wopening));				if WOpening < 1 then					begin						sysbeep(1);						Wopening := 1					end;				DDisplacement := r1 * a.DDisplacement + r2 * b.DDisplacement + r3 * c.DDisplacement;				SShape := r1 * a.SShape + r2 * b.SShape + r3 * c.SShape;				TTranslation := r1 * a.TTranslation + r2 * b.TTranslation + r3 * c.TTranslation;				TranslationGradient := r1 * a.TranslationGradient + r2 * b.TranslationGradient + r3 * c.TranslationGradient;				if TranslationGradient <= 0.1 then					TranslationGradient := 0.1;				reach := round(r1 * a.reach + r2 * b.reach + r3 * c.reach);				Coarsegraininess := round(r1 * a.Coarsegraininess + r2 * b.Coarsegraininess + r3 * c.Coarsegraininess);				hand := round(r1 * a.Coarsegraininess + r2 * b.Coarsegraininess + r3 * c.Coarsegraininess);				if hand < 0 then					handedness := -1				else					handedness := 1;			end	end; {concoct}	procedure PlotTriangle (prefs: SnailPreferencesHandle; MLoc: point; Localswitch: Boolean);		var			offCentre: Point;	begin		if LocalSwitch then			GlobalToLocal(Mloc);		triangle(r1, r2, r3, b, MLoc);		concoct(r1, r2, r3, topan, leftan, rightan, child[special]);    with prefs^^ do      begin		    zeromargin := TRUE;		    DelayedDrawing := true;		    offCentre := develop(prefs, child[special], Mloc);		    grow(margin, 2);		    EraseRect(margin);		    FrameRect(margin);      end;    DrawPic(prefs, offCentre, child[special]);		DrawTriangle(a, b, c);{MakeGeneBox(child[special]);}	end; {PlotTriangle}	procedure MainTriangle(prefs: SnailPreferencesHandle);		var			ScreenWidth, ScreenHeight: LONGINT;			Storeanimal: person;	begin		AlreadyTriangling := FALSE;		if special > 0 then			Storeanimal := child[special];		LastMouse.h := -1;		LastMouse.v := -1;		eraserect(prefs^^.Prect);		with Screenbits.Bounds do			begin				ScreenWidth := right - left;				ScreenHeight := bottom - top			end;		a.h := round(234 * ScreenWidth / 512);		a.v := round(51 * ScreenHeight / 342);		b.h := round(134 * ScreenWidth / 512);		b.v := round(250 * ScreenHeight / 342);		c.h := round(333 * ScreenWidth / 512);		c.v := round(250 * ScreenHeight / 342);		mous.v := 0;		mous.h := 0;		eraserect(prefs^^.Prect);{drawtriangle(a, b, c);}		if special = 0 then			special := 1;		PlotTriangle(prefs, a, false);		PlotTriangle(prefs, b, false);		PlotTriangle(prefs, c, false);		if special > 0 then			child[special] := storeanimal;	end; {maintriangle}	procedure OwnCursor (prefs: SnailPreferencesHandle; theRect: Rect; fromBitMap: BitMap; var theCursor: Cursor);		var			Box: Rect;			aBitMap: BitMap;			myBits16: Bits16;			SizeNeeded: LONGINT;			CanDo: Boolean;			errString, helpString: Str255;		function MakeBits16 (theBitMap: BitMap; var theBits16: Bits16): Boolean;			type				BitsPtr = ^Bits16;			var				thePtr: BitsPtr;		begin			SizeNeeded := LONGINT(SizeOf(BitsPtr));			if (Memavail - SizeNeeded) < SafetyValve then				begin					GetIndString(errString, 128, 13);			{** v1.1 **}					GetIndString(helpString, 128, 14);					DisplayError(-108, errString, helpString, StopError);					ExitToShell;{was: MemoryMessage ( 4405 , ' in making Bits16' , Verdict ); exitToShell from proc}					MakeBits16 := FALSE				end			else				begin					thePtr := BitsPtr(NewPtr(SizeOf(BitsPtr)));					if MemError <> noErr then						ExitToShell;					thePtr := BitsPtr(theBitMap.BaseAddr);					theBits16 := thePtr^;					DisposPtr(Ptr(thePtr));					MakeBits16 := TRUE;				end; {TRUE condition}		end; {Make Bits16}		function BigEnough (var theRect: Rect): Boolean;			var				Width, Height: Integer;		begin			with theRect do				begin					Width := Right - Left;					Height := Bottom - Top;				end;			BigEnough := (Width > 16) and (Height > 16);		end; {LargerRect}	begin		SetRect(Box, 0, 0, 16, 16);		with theRect do			begin				left := left + 2;				right := right - 2;				top := top + 2;				bottom := bottom - 2			end;		aBitMap.rowBytes := 2;		aBitMap.bounds := box;		SizeNeeded := LONGINT(SizeOf(Bits16));		if (Memavail - SizeNeeded) < SafetyValve then			begin				GetIndString(errString, 128, 14);		{** v1.1 **}				GetIndString(helpString, 128, 4);				DisplayError(-108, errString, helpString, StopError);				ExitToShell;{was: MemoryMessage(4405, 'CanÕt make biomorphic cursor', Verdict);}				CanDo := FALSE;			end		else			begin				CanDo := TRUE;				aBitMap.baseAddr := NewPtr(SizeOf(Bits16));				if MemError <> noErr then					ExitToShell;     {No memory available}				CopyBits(fromBitMap, aBitMap, TheRect, box, srcCopy, nil);			end;		if CanDo and MakeBits16(aBitMap, MyBits16) and (BigEnough(theRect) or (prefs^^.theMode = Triangling)) then			begin				theCursor.data := MyBits16;				theCursor.mask := prefs^^.curslist[breedcursor]^^.mask;				theCursor.hotSpot.v := 8;				theCursor.hotSpot.h := 8;				DisposPtr(aBitMap.baseAddr);			end		else			theCursor := prefs^^.curslist[crosscursor]^^;	end; {OwnCursor}	function DivisibleByEight (n: Integer): Boolean;	begin		DivisibleByEight := 8 * (n div 8) = n	end;	procedure AtLeast (var OutRect: Rect);	begin		InsetRect(OutRect, -3, -3);		with OutRect do			begin				while not (DivisibleByEight(left)) do					left := left - 1;				while not (DivisibleByEight(right)) do					right := right + 1			end	end;	procedure MakeNiceBox (Inbox: Rect; var outbox: Rect);		var			width, height: Integer;	begin		OutBox := InBox;		with OutBox do			begin				height := bottom - top;{1+}				width := right - left;{1+}				if width < height then					width := height				else					height := width;    {WidthBytes:=width DIV 8;}{    WHILE odd(WidthBytes) DO WidthBytes:=WidthBytes+1;}{    Width:=WidthBytes*8;}				left := 8;				Right := left + Width;				Top := 8;				Bottom := Top + Height;				AtLeast(outbox);				right := right + 1;			end;	end; {MakeNiceBox}	procedure CursSnap (prefs: SnailPreferencesHandle; offset: Integer; biomorph: person);		var			Midpoint: Point;			NiceBox: Rect;			Offcen: Point;			SavePort: GrafPtr;			SaveBitMap: Bitmap;			offCentre: point;	begin {ClipRect(businessPart);}		GetPort(SavePort);		SaveBitMap := SavePort^.PortBits;		SetPortBits(AlbumBitMap[0]);		MakeNiceBox(prefs^^.margin, NiceBox);		with NiceBox do			begin				MidPoint.v := top + (bottom - top) div 2;				MidPoint.h := left + (right - left) div 2;			end;		EraseRect(NiceBox); {offscreen}		Offcen := MidPoint;		Offcen.v := Offcen.v - offset;		offCentre := Develop(prefs, biomorph, OffCen);		DrawPic(prefs, Offcentre, biomorph);		OwnCursor(prefs, Nicebox, AlbumBitMap[0], theCursor);		SetPort(SavePort);		SetPortBits(SaveBitMap);		ClipRect(MainPtr^.PortRect);	end; {CursSnap}	procedure FlickerTriangle (prefs: SnailPreferencesHandle; MLoc: Point);		var			infant: person;			margcentre, offset: Integer;			offsetPoint: Point;	begin		triangle(r1, r2, r3, b, MLoc);		concoct(r1, r2, r3, topan, leftan, rightan, infant);		if prefs^^.theMode <> triangling then			begin			end;    with prefs^^ do      begin		  DelayedDrawing := TRUE;		  ZeroMargin := TRUE;		  offsetPoint := Develop(prefs, infant, MLoc);      {At this point Margin really does correctly frame the biomorph}		  with margin do			  margcentre := top + (bottom - top) div 2;		  offset := margcentre - MLoc.v;		  CursSnap(prefs, offset, infant);      end;  end; {FlickerTriangle}end.