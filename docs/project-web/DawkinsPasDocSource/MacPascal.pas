UNIT MacPascal;{< Routines from the Mac Classic ToolBox used by all Watchmaker programs,with documentation from the 1985 edition of Inside Macintosh.}INTERFACETYPE        GenericPtr = RECORD END;        Ptr = ^GenericPtr;        Handle = ^Ptr;        Size = RECORD END;        Str255 = String;        Str63 = String;        ResType = RECORD END;        WindowPtr = RECORD END;	WindowRecord = RECORD END;	ControlHandle = RECORD END;	WindowPeek = RECORD END;	GrafPtr = RECORD END;        Rect = RECORD             left: INTEGER;             right: INTEGER;             top: INTEGER;             bottom: INTEGER;        END;	RectPtr = ^Rect;        BitMap =               RECORD                     baseAddr: Ptr; {< pointer to bit image}                     rowBytes: INTEGER; {< row width}                     bounds: Rect; {< boundary rectangle}               END;        Bits16 = RECORD END;        RgnHandle = RECORD END;        { Inside Macintosh I-202 }        VHSelect = (v,h);        { Inside Macintosh I-202 }        Point = RECORD CASE INTEGER OF        0: (v: INTEGER; {< vertical coordinate}        h: INTEGER); {< horizontal coordinate}        1: (vh: ARRAY[VHSelect] OF INTEGER)        END;        {Inside Macintosh I-202 Summary of QuickDraw}	Cursor = RECORD 		data: Bits16; {< cursor image}		mask: Bits16; {< cursor mask}		hotSpot: Point; {<point aligned with mouse}	END;	CursPtr = ^Cursor; {< Inside Macintosh I-474}	CursHandle = ^CursPtr;{< Inside Macintosh I-474: @preformatted (The CursHandle data type is defined in the Toolbox Utilities as follows:)}        MenuHandle = RECORD END;        EventRecord = RECORD END;        Pic = RECORD END;        PicHandle = RECORD END;        OSErr = INTEGER;        QElem = RECORD END;        QElemPtr = ^QElem;        Proc = RECORD END;        ProcPtr = ^Proc;        StringPtr = ^String;        SignedByte = RECORD END;        OSType = PACKED ARRAY[1..4] OF CHAR; {<Inside Macintosh III-184}        {File Manager Reference 2-242}        ParamBlkType =(ioParam, fileParam, volumeParam, cntrlParam,slotDevParam, multiDevParam, accessParam,objParam, copyParam, wdParam, fidParam, csParam,foreignPrivsParam);        FInfo =          RECORD          fdType: OSType; {< file type}          fdCreator: OSType; {< file creator}          fdFlags: Integer; {< Finder flags}          fdLocation: Point; {< file's location in window}          fdFldr: Integer; {< window that contains file}          END; {< Inside Macintosh II-84}          ParmBlkPtr = ^ParamBlockRec;                {basic File Manager parameter block. File Manager Reference 2-87.}ParamBlockRec = RECORDqLink:QElemPtr;{next queue entry}qType:Integer;{queue type}ioTrap:Integer;{routine trap}ioCmdAddr:Ptr;{routine address}ioCompletion:ProcPtr;{pointer to completion routine}ioResult:OSErr;{result code}ioNamePtr:StringPtr;{pointer to pathname}ioVRefNum:Integer;{volume specification}CASE ParamBlkType OFioParam:(ioRefNum:Integer;{file reference number}ioVersNum:SignedByte;{version number}ioPermssn:SignedByte;{read/write permission}ioMisc:Ptr;{miscellaneous}ioBuffer:Ptr;{data buffer}ioReqCount:LongInt;{requested number of bytes}ioActCount:LongInt;{actual number of bytes}ioPosMode:Integer;{positioning mode and newline char.}ioPosOffset:LongInt{positioning offset});fileParam:(ioFRefNum:Integer;{file reference number}ioFVersNum:SignedByte;{file version number (unused)}filler1:SignedByte;{reserved}ioFDirIndex:Integer;{directory index}ioFlAttrib:SignedByte;{file attributes}ioFlVersNum:SignedByte;{file version number (unused)}ioFlFndrInfo:FInfo;{information used by the Finder}ioFlNum:LongInt;{file ID}ioFlStBlk:Integer;{first alloc. blk. of data fork}ioFlLgLen:LongInt;{logical EOF of data fork}ioFlPyLen:LongInt;{physical EOF of data fork}ioFlRStBlk:Integer;{first alloc. blk. of resource fork}ioFlRLgLen:LongInt;{logical EOF of resource fork}ioFlRPyLen:LongInt;{physical EOF of resource fork}ioFlCrDat:LongInt;{date and time of creation}ioFlMdDat:LongInt{date and time of last modification}                  );volumeParam:(filler2:LongInt;    {reserved}ioVolIndex:Integer;  {volume index}ioVCrDate:LongInt;        {date and time of initialization}ioVLsBkUp:LongInt; {date and time of last modification}ioVAtrb:Integer; {volume attributes}ioVNmFls:Integer;      {number of files in root directory}ioVDirSt:Integer;  {first block of directory}ioVBlLn:Integer; {length of directory in blocks}ioVNmAlBlks:Integer; {number of allocation blocks}ioVAlBlkSiz:LongInt; {size of allocation blocks}ioVClpSiz:LongInt; {default clump size}ioAlBlSt:Integer; {first block in block map}ioVNxtFNum:LongInt;   {next unused file ID}ioVFrBlk:Integer {number of unused allocation blocks});END;        CInfoType = (hfileInfo, dirInfo);   {< File Manager 2-247}        {Macintosh Toolbox Essentials 7-49}        FXInfo =        RECORD        fdIconID:Integer;{< icon ID}        fdUnused:ARRAY[1..3] OF Integer;{< unused but reserved 6 bytes}        fdScript:SignedByte; {< script flag and code}        fdXFlags: SignedByte; {< reserved}        fdComment:Integer;{< comment ID}        fdPutAway:  LongInt;{< home directory ID}        END;        {Macintosh Toolbox Essentials 7-50}        DXInfo =          RECORD          frScroll:Point;         {scroll position}          frOpenChain:LongInt;                {directory ID chain of open folders}          frScript:SignedByte; {script flag and code}          frXFlags:SignedByte; {reserved}          frComment:Integer;  {comment ID}          frPutAway:LongInt; {home directory ID}          END;        {Macintosh Toolbox Essentials 7-50}        DInfo =        RECORD        frRect:Rect;{folder's window rectangle}        frFlags:Integer;{flags}        frLocation:Point;{folder's location in window}        frView:Integer;{folder's view}        END;                      CInfoPBPtr = ^CInfoPBRec;        CInfoPBRec =RECORDqLink: QElemPtr; {< next queue entry}qType: Integer; {< queue type}ioTrap: Integer; {< routine trap}ioCmdAddr: Ptr; {< routine address}ioCompletion: ProcPtr; {< pointer to completion routine}ioResult: OSErr; {< result code}ioNamePtr: StringPtr; {< pointer to pathname}ioVRefNum: Integer; {< volume specification}ioFRefNum: Integer; {< file reference number}ioFVersNum: SignedByte; {< version number}filler1: SignedByte; {< reserved}ioFDirIndex: Integer; {< directory index}ioFlAttrib: SignedByte; {< file or directory attributes}ioACUser: SignedByte; {< directory access rights}CASE CInfoType OFhFileInfo: (ioFlFndrInfo: FInfo; {< information used by the Finder}ioDirID: LongInt; {< directory ID or file ID}ioFlStBlk: Integer; {< first alloc. blk. of data fork}ioFlLgLen: LongInt; {< logical EOF of data fork}ioFlPyLen: LongInt; {< physical EOF of data fork}ioFlRStBlk: Integer; {< first alloc. blk. of resource fork}ioFlRLgLen: LongInt; {< logical EOF of resource fork}ioFlRPyLen: LongInt; {< physical EOF of resource fork}ioFlCrDat: LongInt; {< date and time of creation}ioFlMdDat: LongInt; {< date and time of last modification}ioFlBkDat: LongInt; {< date and time of last backup}ioFlXFndrInfo: FXInfo; {< additional Finder information}ioFlParID: LongInt; {< file parent directory ID}ioFlClpSiz: LongInt); {< file's clump size}dirInfo: (ioDrUsrWds: DInfo; {< information used by the Finder}ioDrDirID: LongInt; {< directory ID}ioDrNmFls: Integer; {< number of files in directory}filler3: ARRAY[1..9] OF Integer;ioDrCrDat: LongInt; {< date and time of creation}ioDrMdDat: LongInt; {< date and time of last modification}ioDrBkDat: LongInt; {< date and time of last backup}ioDrFndrInfo: DXInfo; {< additional Finder information}ioDrParID: LongInt); {< directory's parent directory ID}END;         {< catalog information parameter block File Manager 2-247}CONST        NoErr = 0;	iBeamCursor = 1; {< to select text Inside Macintosh I-474}	crossCursor = 2; {< to draw graphics Inside Macintosh I-474}	plusCursor = 3; {< to select cells in structured documents Inside Macintosh I-474}	watchCursor = 4; {< to indicate a long wait Inside Macintosh I-474}VAR   screenBits: BitMap;{Inside Macintosh, I-474:@preformatted(GetCursor returns a handle to the cursor having the given resource ID, readingit from the resource file if necessary. It calls the Resource Manager functionGetResource('CURS',cursorID). If the resource can't be read, GetCursor returns NIL.)}FUNCTION GetCursor(cursorlD: INTEGER ): CursHandle;{Write a string representation of an integer to a string variable,without using a + sign for positive values. Defined in Inside MacintoshChapter 18, THE BINARY-DECIMAL CONVERSION PACKAGE, I-489: "NumToString converts theNum to a string that represents its decimal value, and returns the resultin theString. If the value is negative, the string begins with a minus sign; otherwise, the sign isomitted. Leading zeroes are suppressed, except that the value 0 produces '0'. For example:@table(@rowHead( @cell(theNum) @cell(theString) )@row(     @cell(12) @cell('12')  )@row(     @cell(-23) @cell('-23') )@row(     @cell(0) @cell('0') )) }PROCEDURE NumToString(theNum: LONGINT; var theString: Str255);{Defined in Inside Macintosh Chapter 6, QuickDraw, section QuickDraw Routines I-172"DrawChar places the given character to the right of the pen location, with the left end of its baseline at the pen's location, and advaaces the pen accordingly. If the character isn't in the font, thefont's missing symbol is drawn.Note: If you're drawing a series of characters, it's faster to make one DrawString orDrawText call rather than a series of DrawChar calls."}PROCEDURE DrawChar(ch: CHAR);FUNCTION GetResource {< Inside Macintosh I-119}(theType: ResType; thelD: INTEGER) : Handle;FUNCTION ResError : INTEGER; {< Inside Macintosh I-133 }FUNCTION GetMenuBar: Handle;PROCEDURE SetMenuBar(menuList: Handle);FUNCTION GetMBarHeight: Integer;{File Manager Reference 2-190}FUNCTION PBGetCatInfo (paramBlock: CInfoPBPtr; async: Boolean): OSErr;{File Manager Reference 2-254}FUNCTION PBRead (paramBlock: ParmBlkPtr; async: Boolean): OSErr;{File Manager Reference 2-254}FUNCTION PBReadSync (paramBlock: ParmBlkPtr): OSErr;{File Manager Reference 2-254}FUNCTION PBReadAsync (paramBlock: ParmBlkPtr): OSErr;{File Manager Reference 2-254}FUNCTION PBWrite (paramBlock: ParmBlkPtr; async: Boolean): OSErr;{File Manager Reference 2-254}FUNCTION PBWriteSync (paramBlock: ParmBlkPtr): OSErr;{File Manager Reference 2-254}FUNCTION PBWriteAsync (paramBlock: ParmBlkPtr): OSErr;{File Manager Reference 2-254}FUNCTION PBClose (paramBlock: ParmBlkPtr; async: Boolean): OSErr;{File Manager Reference 2-254}FUNCTION PBCloseSync (paramBlock: ParmBlkPtr): OSErr;{File Manager Reference 2-254}FUNCTION PBCloseAsync (paramBlock: ParmBlkPtr): OSErr;{File Manager Reference 2-258} FUNCTION HCreate (vRefNum: Integer; dirID: LongInt;fileName: Str255; creator: OSType;fileType: OSType): OSErr;{File Manager Reference 2-258}FUNCTION DirCreate (vRefNum: Integer; parentDirID: LongInt; directoryName: Str255;VAR createdDirID: LongInt): OSErr;{File Manager Reference 2-258}FUNCTION HDelete (vRefNum: Integer; dirID: LongInt; fileName: Str255): OSErr;{File Manager Reference 2-253}FUNCTION GetFPos (refNum: Integer; VAR filePos: LongInt): OSErr;{File Manager Reference 2-253}FUNCTION SetFPos (refNum: Integer; posMode: Integer;posOff: LongInt): OSErr;{File Manager Reference 2-253}FUNCTION GetEOF (refNum: Integer; VAR logEOF: LongInt): OSErr;{File Manager Reference 2-253}FUNCTION SetEOF (refNum: Integer; logEOF: LongInt): OSErr;IMPLEMENTATIONFUNCTION GetCursor(cursorlD: INTEGER ): CursHandle;BEGIN GetCursor := nil; END;PROCEDURE DrawChar(ch: CHAR);BEGIN END;PROCEDURE NumToString(theNum: LONGINT; var theString: Str255);BEGIN END;FUNCTION GetResource {< Inside Macintosh I-119}(theType: ResType; thelD: INTEGER) : Handle; BEGIN GetResource := new(Handle); END;FUNCTION ResError : INTEGER; {< Inside Macintosh I-133 }  BEGIN ResError := NoErr; END;FUNCTION GetMenuBar: Handle; BEGIN GetMenuBar := new(Handle); END;PROCEDURE SetMenuBar(menuList: Handle); BEGIN END;FUNCTION GetMBarHeight: Integer; BEGIN GetMBarHeight := 0; END;FUNCTION PBGetCatInfo (paramBlock: CInfoPBPtr; async: Boolean): OSErr;BEGIN     PBGetCatInfo := noErr; END;{File Manager Reference 2-253}FUNCTION PBRead (paramBlock: ParmBlkPtr; async: Boolean): OSErr;BEGIN     PBRead := noErr; END;{File Manager Reference 2-254}FUNCTION PBReadSync (paramBlock: ParmBlkPtr): OSErr;BEGIN     PBReadSync := noErr; END;{File Manager Reference 2-254}FUNCTION PBReadAsync (paramBlock: ParmBlkPtr): OSErr;BEGIN     PBReadAsync := noErr; END;{File Manager Reference 2-254}FUNCTION PBWrite (paramBlock: ParmBlkPtr; async: Boolean): OSErr;BEGIN     PBWrite := noErr; END;{File Manager Reference 2-254}FUNCTION PBWriteSync (paramBlock: ParmBlkPtr): OSErr;BEGIN     PBWriteSync := noErr; END;{File Manager Reference 2-254}FUNCTION PBWriteAsync (paramBlock: ParmBlkPtr): OSErr;BEGIN     PBWriteAsync := noErr; END;{File Manager Reference 2-254}FUNCTION PBClose (paramBlock: ParmBlkPtr; async: Boolean): OSErr;BEGIN     PBClose := noErr; END;{File Manager Reference 2-254}FUNCTION PBCloseSync (paramBlock: ParmBlkPtr): OSErr;BEGIN     PBCloseSync := noErr; END;{File Manager Reference 2-254}FUNCTION PBCloseAsync (paramBlock: ParmBlkPtr): OSErr;BEGIN     PBCloseAsync := noErr; END;{File Manager Reference 2-258} FUNCTION HCreate (vRefNum: Integer; dirID: LongInt;fileName: Str255; creator: OSType;fileType: OSType): OSErr; BEGIN     HCreate := noErr; END;{File Manager Reference 2-258}FUNCTION DirCreate (vRefNum: Integer; parentDirID: LongInt; directoryName: Str255;VAR createdDirID: LongInt): OSErr;BEGIN     DirCreate := noErr; END;{File Manager Reference 2-258}FUNCTION HDelete (vRefNum: Integer; dirID: LongInt; fileName: Str255): OSErr;BEGIN     HDelete := noErr; END;{File Manager Reference 2-253}FUNCTION GetFPos (refNum: Integer; VAR filePos: LongInt): OSErr;BEGIN     GetFPos := noErr; END;{File Manager Reference 2-253}FUNCTION SetFPos (refNum: Integer; posMode: Integer;   posOff: LongInt): OSErr;BEGIN     SetFPos := noErr; END;{File Manager Reference 2-253}FUNCTION GetEOF (refNum: Integer; VAR logEOF: LongInt): OSErr;BEGIN     GetEOF := noErr; END;{File Manager Reference 2-253}FUNCTION SetEOF (refNum: Integer; logEOF: LongInt): OSErr;BEGIN     SetEOF := noErr; END;END.