unit Preferences;{File name:  Preferences.Pas  }{Function: Handle a dialog}{History: 12/12/90 Original by Prototyper.   }{                       }interface	uses		MyGlobals, Boxes, Ted, Breeding_Window;	procedure D_Preferences;implementation	const   								{These are the item numbers for controls in the Dialog}		I_OK = 1;		I_Colour = 2;		I_Sideways = 3;		I_Centring = 9;		I_x = 4;		I_x5 = 5;		I_x7 = 6;		I_x9 = 7;		I_x11 = 8;	var		theInput: TEHandle;		ExitDialog: boolean;   		{Flag used to exit the Dialog}		DoubleClick: boolean;  		{Flag to say that a double click on a list happened}		MyPt: Point;   				{Current list selection point}		MyErr: OSErr;  				{OS error returned}	procedure D_Preferences;		var			GetSelection: DialogPtr;{Pointer to this dialog}			tempRect: Rect;    		{Temporary rectangle}			DType: Integer;    		{Type of dialog item}			Index: Integer;    		{For looping}			DItem: Handle; 			{Handle to the dialog item}			CItem, CTempItem: controlhandle;{Control handle}			sTemp: Str255; 			{Get text entered, temp holding}			itemHit: Integer;  		{Get selection}			temp: Integer; 			{Get selection, temp holding}			dataBounds: Rect;  		{Rect to setup the list}			cSize: Point;  			{Pointer to a cell in a list}			Icon_Handle: Handle;   	{Temp handle to read an Icon into}			NewMouse: Point;   		{Mouse location during tracking Icon presses}			InIcon: boolean;   		{Flag to say pressed in an Icon}			ThisEditText: TEHandle; {Handle to get the Dialogs TE record}			TheDialogPtr: DialogPeek;{Pointer to Dialogs definition record, contains the TE record}	{This is an update routine for non-controls in the dialog}	{This is executed after the dialog is uncovered by an alert}		procedure Refresh_Dialog;   		{Refresh the dialogs non-controls}			var				rTempRect: Rect;     		{Temp rectangle used for drawing}		begin			SetPort(GetSelection);  	{Point to our dialog window}			GetDItem(GetSelection, I_OK, DType, DItem, tempRect);{Get the item handle}			PenSize(3, 3);  			{Change pen to draw thick default outline}			InsetRect(tempRect, -4, -4);{Draw outside the button by 1 pixel}			FrameRoundRect(tempRect, 16, 16); {Draw the outline}			PenSize(1, 1);  			{Restore the pen size to the default value}		end;	begin   							{Start of dialog handler}		GetSelection := GetNewDialog(8, nil, Pointer(-1));{Bring in the dialog resource}		ShowWindow(GetSelection);{Open a dialog box}		SelectWindow(GetSelection);{Lets see it}		SetPort(GetSelection);  	{Prepare to add conditional text}		TheDialogPtr := DialogPeek(GetSelection);{Get to the inner record}		ThisEditText := TheDialogPtr^.textH;{Get to the TE record}		HLock(Handle(ThisEditText));{Lock it for safety}		ThisEditText^^.txSize := 12;{TE Point size}		TextSize(12);   			{Window Point size}		ThisEditText^^.txFont := systemFont;{TE Font ID}		TextFont(systemFont);   	{Window Font ID}		ThisEditText^^.txFont := 0;{TE Font ID}		ThisEditText^^.fontAscent := 12;{Font ascent}		ThisEditText^^.lineHeight := 12 + 3 + 1;{Font ascent + descent + leading}		HUnLock(Handle(ThisEditText));{UnLock the handle when done}			{Setup initial conditions}		GetDItem(GetSelection, I_x9, DType, DItem, tempRect);{Get the item handle}		NumToString(NRows, sTemp);		SetIText(DItem, sTemp);    	{Set the current value of NRows into dialog}		GetDItem(GetSelection, I_x11, DType, DItem, tempRect);{Get the item handle}		NumToString(NCols, sTemp);		SetIText(DItem, sTemp);    	{Set the current value of NCols into dialog}		Refresh_Dialog;     		{Draw any Lists, popups, lines, or rectangles}		ExitDialog := FALSE;  		{Do not exit dialog handle loop yet}		GetDItem(GetSelection, I_Colour, DType, DItem, tempRect);{Get item information}		CItem := Pointer(DItem);		if WantColor then {Set check box to register present state of WantColor}			temp := 1		else			temp := 0;		SetCtlValue(CItem, temp);		GetDItem(GetSelection, I_Centring, DType, DItem, tempRect);{Get item information}		CItem := Pointer(DItem);		if Centring then {Set check box to register present state of WantColor}			temp := 1		else			temp := 0;		SetCtlValue(CItem, temp);		GetDItem(GetSelection, I_SideWays, DType, DItem, tempRect);{Get item information}		CItem := Pointer(DItem);		if Sideways then  {Set check box to register present state of Sideways}			temp := 1		else			temp := 0;		SetCtlValue(CItem, temp);		repeat  					{Start of dialog handle loop}			ModalDialog(nil, itemHit);{Wait until an item is hit}			GetDItem(GetSelection, itemHit, DType, DItem, tempRect);{Get item information}			CItem := Pointer(DItem);{Get the control handle}				{Handle it real time}			if (ItemHit = I_OK) then{Handle the Button being pressed}				begin					{?? Code to handle this button goes here}					ExitDialog := TRUE;{Exit the dialog when this selection is made}				end;    				{End for this item selected}			if (ItemHit = I_Colour) then{Handle the checkbox being pressed}				begin					temp := GetCtlValue(CItem);{Get the current Checkbox value}					SetCtlValue(CItem, (temp + 1) mod 2);{Toggle the value to the opposite}					if (temp = 0) then{Do all CHECKED linkages}						begin						end     			{End for this item checked}					else    			{Do all UNCHECKED linkages}						begin						end;    			{End for this item unchecked}				end;    				{End for this item selected}			if (ItemHit = I_Centring) then{Handle the checkbox being pressed}				begin					temp := GetCtlValue(CItem);{Get the current Checkbox value}					SetCtlValue(CItem, (temp + 1) mod 2);{Toggle the value to the opposite}					if (temp = 0) then{Do all CHECKED linkages}						begin						end     			{End for this item checked}					else    			{Do all UNCHECKED linkages}						begin						end;    			{End for this item unchecked}				end;    				{End for this item selected}			if (ItemHit = I_Sideways) then{Handle the checkbox being pressed}				begin					if sideways then						temp := 1					else						temp := 0;					SetCtlValue(CItem, temp);					temp := GetCtlValue(CItem);{Get the current Checkbox value}					SetCtlValue(CItem, (temp + 1) mod 2);{Toggle the value to the opposite}					if (temp = 0) then{Do all CHECKED linkages}						begin						end     			{End for this item checked}					else    			{Do all UNCHECKED linkages}						begin						end;    			{End for this item unchecked}				end;    				{End for this item selected}		until ExitDialog;   		{Handle dialog items until exit selected}			{Get results after dialog}		GetDItem(GetSelection, I_Colour, DType, DItem, tempRect);{Get the Checkbox handle}		CItem := Pointer(DItem);{Change dialog handle to control handle}		temp := GetCtlValue(CItem);{Get the checkbox value}		GetDItem(GetSelection, I_Colour, DType, DItem, tempRect);{Get item information}		CItem := Pointer(DItem);		if temp = 1 then			wantColor := true		else			wantColor := false;		{??? HANDLE THE CHECKBOX RESULT FOR  Colour HERE}		GetDItem(GetSelection, I_Centring, DType, DItem, tempRect);{Get the Checkbox handle}		CItem := Pointer(DItem);{Change dialog handle to control handle}		temp := GetCtlValue(CItem);{Get the checkbox value}		GetDItem(GetSelection, I_Centring, DType, DItem, tempRect);{Get item information}		CItem := Pointer(DItem);		if temp = 1 then			Centring := true		else			Centring := false;		{??? HANDLE THE CHECKBOX RESULT FOR  Centring HERE}		GetDItem(GetSelection, I_Sideways, DType, DItem, tempRect);{Get the Checkbox handle}		CItem := Pointer(DItem);{Change dialog handle to control handle}		temp := GetCtlValue(CItem);{Get the checkbox value}			{??? HANDLE THE CHECKBOX RESULT FOR  Sideways HERE}		if temp = 1 then			sideways := true		else			sideways := false;		GetDItem(GetSelection, I_x9, DType, DItem, tempRect);{Get the item handle}		GetIText(DItem, sTemp);{Get the text entered}			{??? HANDLE THE STRING ENTERED FOR  3  HERE}		StringToNum(sTemp, NRows);		GetDItem(GetSelection, I_x11, DType, DItem, tempRect);{Get the item handle}		GetIText(DItem, sTemp);{Get the text entered}			{??? HANDLE THE STRING ENTERED FOR  5  HERE}		StringToNum(sTemp, NCols);		MidBox := 1 + (NRows * NCols) div 2;		DisposDialog(GetSelection);{Flush the dialog out of memory}		Open_Breeding_Window(theInput);	end;    							{End of procedure}end.    							{End of unit}