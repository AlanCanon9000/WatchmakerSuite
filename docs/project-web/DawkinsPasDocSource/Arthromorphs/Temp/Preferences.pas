unit Preferences;{File name:  Preferences.Pas  }{Function: Handle a dialog}{History: 1/4/91 Original by Prototyper.   }{                       }interface	procedure D_Preferences;implementationconst   								{These are the item numbers for controls in the Dialog}		I_OK = 1;		I_Colour = 2;		I_Sideways = 3;		I_x = 4;		I_x5 = 5;		I_x7 = 6;		I_x9 = 7;		I_x11 = 8;var 		ExitDialog : boolean;   		{Flag used to exit the Dialog}		DoubleClick : boolean;  		{Flag to say that a double click on a list happened}		MyPt : Point;   				{Current list selection point}		MyErr : OSErr;  				{OS error returned} 	procedure D_Preferences;	var			GetSelection : DialogPtr;{Pointer to this dialog}			tempRect : Rect;    		{Temporary rectangle}			DType : Integer;    		{Type of dialog item}			Index : Integer;    		{For looping}			DItem : Handle; 			{Handle to the dialog item}			CItem, CTempItem : controlhandle;{Control handle}			sTemp : Str255; 			{Get text entered, temp holding}			itemHit : Integer;  		{Get selection}			temp : Integer; 			{Get selection, temp holding}			dataBounds : Rect;  		{Rect to setup the list}			cSize : Point;  			{Pointer to a cell in a list}			Icon_Handle : Handle;   	{Temp handle to read an Icon into}			NewMouse : Point;   		{Mouse location during tracking Icon presses}			InIcon : boolean;   		{Flag to say pressed in an Icon}			ThisEditText : TEHandle; {Handle to get the Dialogs TE record}			TheDialogPtr : DialogPeek;{Pointer to Dialogs definition record, contains the TE record}	 	{This is an update routine for non-controls in the dialog} 	{This is executed after the dialog is uncovered by an alert} 	procedure Refresh_Dialog;   		{Refresh the dialogs non-controls}	var 			rTempRect:Rect;     		{Temp rectangle used for drawing}	 	begin 			SetPort(GetSelection);  	{Point to our dialog window}			GetDItem(GetSelection,I_OK,DType,DItem,tempRect);{Get the item handle}			PenSize(3, 3);  			{Change pen to draw thick default outline}			InsetRect(tempRect, -4, -4);{Draw outside the button by 1 pixel}			FrameRoundRect(tempRect, 16, 16); {Draw the outline}			PenSize(1, 1);  			{Restore the pen size to the default value}				end; 	 	 	begin   							{Start of dialog handler}			GetSelection := GetNewDialog(8, nil,  Pointer(-1) );{Bring in the dialog resource}			ShowWindow(GetSelection);{Open a dialog box}			SelectWindow(GetSelection);{Lets see it}			SetPort(GetSelection);  	{Prepare to add conditional text}			 			TheDialogPtr := DialogPeek(GetSelection);{Get to the inner record}			ThisEditText := TheDialogPtr^.textH;{Get to the TE record}			HLock(Handle(ThisEditText));{Lock it for safety}			ThisEditText^^.txSize := 12;{TE Point size}			TextSize(12);   			{Window Point size}			ThisEditText^^.txFont := systemFont;{TE Font ID}			TextFont(systemFont);   	{Window Font ID}			ThisEditText^^.txFont := 0;{TE Font ID}			ThisEditText^^.fontAscent := 12;{Font ascent}			ThisEditText^^.lineHeight := 12 + 3 + 1;{Font ascent + descent + leading}			HUnLock(Handle(ThisEditText));{UnLock the handle when done}						 			{Setup initial conditions}			GetDItem(GetSelection,I_x9,DType,DItem,tempRect);{Get the item handle}			SetIText(DItem,'3');    	{Set the default text string}						GetDItem(GetSelection,I_x11,DType,DItem,tempRect);{Get the item handle}			SetIText(DItem,'5');    	{Set the default text string}						Refresh_Dialog;     		{Draw any Lists, popups, lines, or rectangles}			 			ExitDialog:=FALSE;  		{Do not exit dialog handle loop yet}			 			repeat  					{Start of dialog handle loop}				ModalDialog(nil, itemHit);{Wait until an item is hit}				GetDItem(GetSelection, itemHit, DType, DItem, tempRect);{Get item information}				CItem := Pointer(DItem);{Get the control handle}				 				{Handle it real time}				if (ItemHit =I_OK) then{Handle the Button being pressed}				begin					{?? Code to handle this button goes here}					ExitDialog:=TRUE;{Exit the dialog when this selection is made}				end;    				{End for this item selected}												if (ItemHit =I_Colour) then{Handle the checkbox being pressed}				begin					temp := GetCtlValue(CItem);{Get the current Checkbox value}					SetCtlValue(CItem, (temp + 1) mod 2);{Toggle the value to the opposite}										if (temp = 0) then{Do all CHECKED linkages}					begin					end     			{End for this item checked}					else    			{Do all UNCHECKED linkages}					begin					end;    			{End for this item unchecked}									end;    				{End for this item selected}												if (ItemHit =I_Sideways) then{Handle the checkbox being pressed}				begin					temp := GetCtlValue(CItem);{Get the current Checkbox value}					SetCtlValue(CItem, (temp + 1) mod 2);{Toggle the value to the opposite}										if (temp = 0) then{Do all CHECKED linkages}					begin					end     			{End for this item checked}					else    			{Do all UNCHECKED linkages}					begin					end;    			{End for this item unchecked}									end;    				{End for this item selected}								 			until ExitDialog;   		{Handle dialog items until exit selected}			 			{Get results after dialog}			GetDItem(GetSelection,I_Colour,DType,DItem,tempRect);{Get the Checkbox handle}			CItem := Pointer(DItem);{Change dialog handle to control handle}			temp:= GetCtlValue(CItem);{Get the checkbox value}			{??? HANDLE THE CHECKBOX RESULT FOR  Colour HERE}						GetDItem(GetSelection,I_Sideways,DType,DItem,tempRect);{Get the Checkbox handle}			CItem := Pointer(DItem);{Change dialog handle to control handle}			temp:= GetCtlValue(CItem);{Get the checkbox value}			{??? HANDLE THE CHECKBOX RESULT FOR  Sideways HERE}						GetDItem(GetSelection,I_x9,DType,DItem,tempRect);{Get the item handle}			GetIText(DItem, sTemp);{Get the text entered}			{??? HANDLE THE STRING ENTERED FOR  3  HERE}						GetDItem(GetSelection,I_x11,DType,DItem,tempRect);{Get the item handle}			GetIText(DItem, sTemp);{Get the text entered}			{??? HANDLE THE STRING ENTERED FOR  5  HERE}									DisposDialog(GetSelection);{Flush the dialog out of memory}				end;    							{End of procedure}		end.    							{End of unit}	