{Created: Saturday, July 27, 1991 at 10:42 PM Quickdraw.p Pascal Interface to the Macintosh Libraries  Copyright Apple Computer, Inc. 1985-1991  All rights reserved    	Change History (most recent first):		<19>	  7/6/92	KON		No longer need bits 5 and 6 in gdFlags. Move bit 4 to bit 6.		<18>	 6/30/92	KON		Add three new gdFlags: Bit 4 hasAuxMenuBar, Bit 5									pixelsAreSlewSlow, and Bit 6 whiteIsOff.		<17>	 5/29/92	DCL		Moved StdText from QuickDraw to QuickDrawText.		<16>	  5/5/92	DCL		For New Inside Mac: removing 'sc' prefixes from some calls,									moving some calls from script to TextUtils, and moving some from									TextUtils & QuickDraw to QuickdrawText. Weeeeeeee!		<15>	 4/15/92	DCL		For New Inside Mac: Moved many definitions from Script to									TextUtils and QuickDraw. And added new synonyms. #1025005		<14>	 7/31/91	JL		Updated Copyright. Restored Comments.		<13>	  2/4/91	JL		Added burstDevice and ext32Device.		<12>	 1/28/91	LN		Checked in Database Generated File from DSG. Added Dispose									synonym for Dispos calls.		<11>	12/14/90	KON		Change name of PICT2Header to OpenCPicParams.[smc]		 <10>	 10/3/90	JAL		Added Inline for GetMaskTable, Added BitMapToRegionGlue call 		 							for pre Mac II machines, changed QDProcsPtr to a CQDProcsPtr									in CGrafPort, added RGBDirect, baseAddr32, rgnOverflowErr, 									and insufficientStackErr		 <9>	 9/15/90	KON		Added CopyDeepMask, OpenCPicture, and PICT2Header record.		 <8>	 9/14/90	csd		Added interfaces for the DeviceLoop call.		 <7>	  9/4/90	kaz		Adding grayishTextOr text mode.		 <6>	 6/19/90	DVB		Add "ColorSpecPtr" type	To Do:}UNIT Quickdraw;INTERFACEUSES Types, QuickdrawText;CONSTinvalColReq = -1;							{invalid color table request}{ transfer modes }srcCopy = 0;								{the 16 transfer modes}srcOr = 1;srcXor = 2;srcBic = 3;notSrcCopy = 4;notSrcOr = 5;notSrcXor = 6;notSrcBic = 7;patCopy = 8;patOr = 9;patXor = 10;patBic = 11;notPatCopy = 12;notPatOr = 13;notPatXor = 14;notPatBic = 15;{ Special Text Transfer Mode }grayishTextOr = 49;{ Arithmetic transfer modes }blend = 32;addPin = 33;addOver = 34;subPin = 35;addMax = 37;adMax = 37;subOver = 38;adMin = 39;ditherCopy = 64;{ Transparent mode constant }transparent = 36;{ QuickDraw color separation constants }normalBit = 0;								{normal screen mapping}inverseBit = 1;								{inverse screen mapping}redBit = 4;									{RGB additive mapping}greenBit = 3;blueBit = 2;cyanBit = 8;								{CMYBk subtractive mapping}magentaBit = 7;yellowBit = 6;blackBit = 5;blackColor = 33;							{colors expressed in these mappings}whiteColor = 30;redColor = 205;greenColor = 341;blueColor = 409;cyanColor = 273;magentaColor = 137;yellowColor = 69;picLParen = 0;								{standard picture comments}picRParen = 1;clutType = 0;								{0 if lookup table}fixedType = 1;								{1 if fixed table}directType = 2;								{2 if direct values}gdDevType = 0;								{0 = monochrome 1 = color}hasAuxMenuBar = 6;							{1 if device has an aux menu bar on it}burstDevice = 7;ext32Device = 8;ramInit = 10;								{1 if initialized from 'scrn' resource}mainScreen = 11;							{1 if main screen }allInit = 12;								{1 if all devices initialized }screenDevice = 13;							{1 if screen device [not used]}noDriver = 14;								{1 if no driver for this GDevice }screenActive = 15;							{1 if in use}hiliteBit = 7;								{flag bit in HiliteMode (lowMem flag)}pHiliteBit = 0;								{flag bit in HiliteMode used with BitClr procedure}defQDColors = 127;							{resource ID of clut for default QDColors}{ pixel type }RGBDirect = 16;								{16 & 32 bits/pixel pixelType value }{ pmVersion values }baseAddr32 = 4;								{pixmap base address is 32-bit address}rgnOverflowErr = -147;						{Region accumulation failed. Resulting region may be currupt }insufficientStackErr = -149;				{QuickDraw could not complete the operation }TYPEGrafVerb = (frame,paint,erase,invert,fill);PixelType = (chunky,chunkyPlanar,planar);PatPtr = ^Pattern;PatHandle = ^PatPtr;Pattern = PACKED ARRAY [0..7] OF 0..255;QDByte = SignedByte;QDPtr = Ptr;								{ blind pointer }QDHandle = Handle;							{ blind handle }QDErr = INTEGER;Bits16 = ARRAY [0..15] OF INTEGER;DeviceLoopFlags = SET OF (singleDevices,dontMatchSeeds,allDevices,DeviceLoopFlags3, DeviceLoopFlags4,DeviceLoopFlags5,DeviceLoopFlags6,DeviceLoopFlags7,DeviceLoopFlags8, DeviceLoopFlags9,DeviceLoopFlags10,DeviceLoopFlags11,DeviceLoopFlags12, DeviceLoopFlags13,DeviceLoopFlags14,DeviceLoopFlags15,DeviceLoopFlags16, DeviceLoopFlags17,DeviceLoopFlags18,DeviceLoopFlags19,DeviceLoopFlags20, DeviceLoopFlags21,DeviceLoopFlags22,DeviceLoopFlags23,DeviceLoopFlags24, DeviceLoopFlags25,DeviceLoopFlags26,DeviceLoopFlags27,DeviceLoopFlags28, DeviceLoopFlags29,DeviceLoopFlags30,DeviceLoopFlags31);BitMapPtr = ^BitMap;BitMapHandle = ^BitMapPtr;BitMap = RECORD baseAddr: Ptr; rowBytes: INTEGER; bounds: Rect; END;CursPtr = ^Cursor;CursHandle = ^CursPtr;Cursor = RECORD data: Bits16; mask: Bits16; hotSpot: Point; END;PenState = RECORD pnLoc: Point; pnSize: Point; pnMode: INTEGER; pnPat: Pattern; END;RgnPtr = ^Region;RgnHandle = ^RgnPtr;Region = RECORD rgnSize: INTEGER;							{size in bytes} rgnBBox: Rect;								{enclosing rectangle} END;PicPtr = ^Picture;PicHandle = ^PicPtr;Picture = RECORD picSize: INTEGER; picFrame: Rect; END;PolyPtr = ^Polygon;PolyHandle = ^PolyPtr;Polygon = RECORD polySize: INTEGER; polyBBox: Rect; polyPoints: ARRAY [0..0] OF Point; END;QDProcsPtr = ^QDProcs;QDProcs = RECORD textProc: Ptr; lineProc: Ptr; rectProc: Ptr; rRectProc: Ptr; ovalProc: Ptr; arcProc: Ptr; polyProc: Ptr; rgnProc: Ptr; bitsProc: Ptr; commentProc: Ptr; txMeasProc: Ptr; getPicProc: Ptr; putPicProc: Ptr; END;GrafPtr = ^GrafPort;GrafPort = RECORD device: INTEGER; portBits: BitMap; portRect: Rect; visRgn: RgnHandle; clipRgn: RgnHandle; bkPat: Pattern; fillPat: Pattern; pnLoc: Point; pnSize: Point; pnMode: INTEGER; pnPat: Pattern; pnVis: INTEGER; txFont: INTEGER; txFace: Style;								{txFace is unpacked byte but push as short} txMode: INTEGER; txSize: INTEGER; spExtra: Fixed; fgColor: LONGINT; bkColor: LONGINT; colrBit: INTEGER; patStretch: INTEGER; picSave: Handle; rgnSave: Handle; polySave: Handle; grafProcs: QDProcsPtr; END;WindowPtr = GrafPtr;{typedef pascal Boolean (*ColorSearchProcPtr)(RGBColor *rgb, long *position);typedef pascal Boolean (*ColorComplementProcPtr)(RGBColor *rgb);}RGBColor = RECORD red: INTEGER;								{magnitude of red component} green: INTEGER;							{magnitude of green component} blue: INTEGER;								{magnitude of blue component} END;ColorSpecPtr = ^ColorSpec;ColorSpec = RECORD value: INTEGER;							{index or other value} rgb: RGBColor;								{true color} END;CSpecArray = ARRAY [0..0] OF ColorSpec;CTabPtr = ^ColorTable;CTabHandle = ^CTabPtr;ColorTable = RECORD ctSeed: LONGINT;							{unique identifier for table} ctFlags: INTEGER;							{high bit: 0 = PixMap; 1 = device} ctSize: INTEGER;							{number of entries in CTTable} ctTable: CSpecArray;						{array [0..0] of ColorSpec} END;MatchRec = RECORD red: INTEGER; green: INTEGER; blue: INTEGER; matchData: LONGINT; END;PixMapPtr = ^PixMap;PixMapHandle = ^PixMapPtr;PixMap = RECORD baseAddr: Ptr;								{pointer to pixels} rowBytes: INTEGER;							{offset to next line} bounds: Rect;								{encloses bitmap} pmVersion: INTEGER;						{pixMap version number} packType: INTEGER;							{defines packing format} packSize: LONGINT;							{length of pixel data} hRes: Fixed;								{horiz. resolution (ppi)} vRes: Fixed;								{vert. resolution (ppi)} pixelType: INTEGER;						{defines pixel type} pixelSize: INTEGER;						{# bits in pixel} cmpCount: INTEGER;							{# components in pixel} cmpSize: INTEGER;							{# bits per component} planeBytes: LONGINT;						{offset to next plane} pmTable: CTabHandle;						{color map for this pixMap} pmReserved: LONGINT;						{for future use. MUST BE 0} END;PixPatPtr = ^PixPat;PixPatHandle = ^PixPatPtr;PixPat = RECORD patType: INTEGER;							{type of pattern} patMap: PixMapHandle;						{the pattern's pixMap} patData: Handle;							{pixmap's data} patXData: Handle;							{expanded Pattern data} patXValid: INTEGER;						{flags whether expanded Pattern valid} patXMap: Handle;							{Handle to expanded Pattern data} pat1Data: Pattern;							{old-Style pattern/RGB color} END;CCrsrPtr = ^CCrsr;CCrsrHandle = ^CCrsrPtr;CCrsr = RECORD crsrType: INTEGER;							{type of cursor} crsrMap: PixMapHandle;						{the cursor's pixmap} crsrData: Handle;							{cursor's data} crsrXData: Handle;							{expanded cursor data} crsrXValid: INTEGER;						{depth of expanded data (0 if none)} crsrXHandle: Handle;						{future use} crsr1Data: Bits16;							{one-bit cursor} crsrMask: Bits16;							{cursor's mask} crsrHotSpot: Point;						{cursor's hotspot} crsrXTable: LONGINT;						{private} crsrID: LONGINT;							{private} END;CIconPtr = ^CIcon;CIconHandle = ^CIconPtr;CIcon = RECORD iconPMap: PixMap;							{the icon's pixMap} iconMask: BitMap;							{the icon's mask} iconBMap: BitMap;							{the icon's bitMap} iconData: Handle;							{the icon's data} iconMaskData: ARRAY [0..0] OF INTEGER;		{icon's mask and BitMap data} END;GammaTblPtr = ^GammaTbl;GammaTblHandle = ^GammaTblPtr;GammaTbl = RECORD gVersion: INTEGER;							{gamma version number} gType: INTEGER;							{gamma data type} gFormulaSize: INTEGER;						{Formula data size} gChanCnt: INTEGER;							{number of channels of data} gDataCnt: INTEGER;							{number of values/channel} gDataWidth: INTEGER;						{bits/corrected value (data packed to next larger byte size)} gFormulaData: ARRAY [0..0] OF INTEGER;		{data for formulas followed by gamma values} END;ITabPtr = ^ITab;ITabHandle = ^ITabPtr;ITab = RECORD iTabSeed: LONGINT;							{copy of CTSeed from source CTable} iTabRes: INTEGER;							{bits/channel resolution of iTable} iTTable: ARRAY [0..0] OF SignedByte;		{byte colortable index values} END;SProcPtr = ^SProcRec;SProcHndl = ^SProcPtr;SProcRec = RECORD nxtSrch: Handle;							{SProcHndl Handle to next SProcRec} srchProc: ProcPtr;							{pointer to search procedure} END;CProcPtr = ^CProcRec;CProcHndl = ^CProcPtr;CProcRec = RECORD nxtComp: CProcHndl;						{CProcHndl Handle to next CProcRec} compProc: ProcPtr;							{pointer to complement procedure} END;GDPtr = ^GDevice;GDHandle = ^GDPtr;GDevice = RECORD gdRefNum: INTEGER;							{driver's unit number} gdID: INTEGER;								{client ID for search procs} gdType: INTEGER;							{fixed/CLUT/direct} gdITable: ITabHandle;						{Handle to inverse lookup table} gdResPref: INTEGER;						{preferred resolution of GDITable} gdSearchProc: SProcHndl;					{search proc list head} gdCompProc: CProcHndl;						{complement proc list} gdFlags: INTEGER;							{grafDevice flags word} gdPMap: PixMapHandle;						{describing pixMap} gdRefCon: LONGINT;							{reference value} gdNextGD: GDHandle;						{GDHandle Handle of next gDevice} gdRect: Rect;								{ device's bounds in global coordinates} gdMode: LONGINT;							{device's current mode} gdCCBytes: INTEGER;						{depth of expanded cursor data} gdCCDepth: INTEGER;						{depth of expanded cursor data} gdCCXData: Handle;							{Handle to cursor's expanded data} gdCCXMask: Handle;							{Handle to cursor's expanded mask} gdReserved: LONGINT;						{future use. MUST BE 0} END;GVarPtr = ^GrafVars;GVarHandle = ^GVarPtr;GrafVars = RECORD rgbOpColor: RGBColor;						{color for addPin  subPin and average} rgbHiliteColor: RGBColor;					{color for hiliting} pmFgColor: Handle;							{palette Handle for foreground color} pmFgIndex: INTEGER;						{index value for foreground} pmBkColor: Handle;							{palette Handle for background color} pmBkIndex: INTEGER;						{index value for background} pmFlags: INTEGER;							{flags for Palette Manager} END;CQDProcsPtr = ^CQDProcs;CQDProcs = RECORD textProc: Ptr; lineProc: Ptr; rectProc: Ptr; rRectProc: Ptr; ovalProc: Ptr; arcProc: Ptr; polyProc: Ptr; rgnProc: Ptr; bitsProc: Ptr; commentProc: Ptr; txMeasProc: Ptr; getPicProc: Ptr; putPicProc: Ptr; opcodeProc: Ptr;							{fields added to QDProcs} newProc1: Ptr; newProc2: Ptr; newProc3: Ptr; newProc4: Ptr; newProc5: Ptr; newProc6: Ptr; END;CGrafPtr = ^CGrafPort;CGrafPort = RECORD device: INTEGER; portPixMap: PixMapHandle;					{port's pixel map} portVersion: INTEGER;						{high 2 bits always set} grafVars: Handle;							{Handle to more fields} chExtra: INTEGER;							{character extra} pnLocHFrac: INTEGER;						{pen fraction} portRect: Rect; visRgn: RgnHandle; clipRgn: RgnHandle; bkPixPat: PixPatHandle;					{background pattern} rgbFgColor: RGBColor;						{RGB components of fg} rgbBkColor: RGBColor;						{RGB components of bk} pnLoc: Point; pnSize: Point; pnMode: INTEGER; pnPixPat: PixPatHandle;					{pen's pattern} fillPixPat: PixPatHandle;					{fill pattern} pnVis: INTEGER; txFont: INTEGER; txFace: Style;								{txFace is unpacked byte  push as short} txMode: INTEGER; txSize: INTEGER; spExtra: Fixed; fgColor: LONGINT; bkColor: LONGINT; colrBit: INTEGER; patStretch: INTEGER; picSave: Handle; rgnSave: Handle; polySave: Handle; grafProcs: CQDProcsPtr; END;CWindowPtr = CGrafPtr;ReqListRec = RECORD reqLSize: INTEGER;							{request list size} reqLData: ARRAY [0..0] OF INTEGER;			{request list data} END;OpenCPicParams = RECORD srcRect: Rect; hRes: Fixed; vRes: Fixed; version: INTEGER; reserved1: INTEGER; reserved2: LONGINT; END;DeviceLoopDrawingProcPtr = ProcPtr;VAR thePort: GrafPtr; white: Pattern; black: Pattern; gray: Pattern; ltGray: Pattern; dkGray: Pattern; arrow: Cursor; screenBits: BitMap; randSeed: LONGINT;PROCEDURE InitGraf(globalPtr: Ptr);PROCEDURE OpenPort(port: GrafPtr);PROCEDURE InitPort(port: GrafPtr);PROCEDURE ClosePort(port: GrafPtr);PROCEDURE SetPort(port: GrafPtr);PROCEDURE GetPort(VAR port: GrafPtr);PROCEDURE GrafDevice(device: INTEGER);PROCEDURE SetPortBits(bm: BitMap);PROCEDURE PortSize(width: INTEGER;height: INTEGER);PROCEDURE MovePortTo(leftGlobal: INTEGER;topGlobal: INTEGER);PROCEDURE SetOrigin(h: INTEGER;v: INTEGER);PROCEDURE SetClip(rgn: RgnHandle);PROCEDURE GetClip(rgn: RgnHandle);PROCEDURE ClipRect(r: Rect);PROCEDURE BackPat(pat: Pattern);PROCEDURE InitCursor;PROCEDURE SetCursor(crsr: Cursor);PROCEDURE HideCursor;PROCEDURE ShowCursor;PROCEDURE ObscureCursor;PROCEDURE HidePen;PROCEDURE ShowPen;PROCEDURE GetPen(VAR pt: Point);PROCEDURE GetPenState(VAR pnState: PenState);PROCEDURE SetPenState(pnState: PenState);PROCEDURE PenSize(width: INTEGER;height: INTEGER);PROCEDURE PenMode(mode: INTEGER);PROCEDURE PenPat(pat: Pattern);PROCEDURE PenNormal;PROCEDURE MoveTo(h: INTEGER;v: INTEGER);PROCEDURE Move(dh: INTEGER;dv: INTEGER);PROCEDURE LineTo(h: INTEGER;v: INTEGER);PROCEDURE Line(dh: INTEGER;dv: INTEGER);PROCEDURE ForeColor(color: LONGINT);PROCEDURE BackColor(color: LONGINT);PROCEDURE ColorBit(whichBit: INTEGER);PROCEDURE SetRect(VAR r: Rect;left: INTEGER;top: INTEGER;right: INTEGER; bottom: INTEGER);PROCEDURE OffsetRect(VAR r: Rect;dh: INTEGER;dv: INTEGER);PROCEDURE InsetRect(VAR r: Rect;dh: INTEGER;dv: INTEGER);FUNCTION SectRect(src1: Rect;src2: Rect;VAR dstRect: Rect): BOOLEAN;PROCEDURE UnionRect(src1: Rect;src2: Rect;VAR dstRect: Rect);FUNCTION EqualRect(rect1: Rect;rect2: Rect): BOOLEAN;FUNCTION EmptyRect(r: Rect): BOOLEAN;PROCEDURE FrameRect(r: Rect);PROCEDURE PaintRect(r: Rect);PROCEDURE EraseRect(r: Rect);PROCEDURE InvertRect(r: Rect);PROCEDURE FillRect(r: Rect;pat: Pattern);PROCEDURE FrameOval(r: Rect);PROCEDURE PaintOval(r: Rect);PROCEDURE EraseOval(r: Rect);PROCEDURE InvertOval(r: Rect);PROCEDURE FillOval(r: Rect;pat: Pattern);PROCEDURE FrameRoundRect(r: Rect;ovalWidth: INTEGER;ovalHeight: INTEGER);PROCEDURE PaintRoundRect(r: Rect;ovalWidth: INTEGER;ovalHeight: INTEGER);PROCEDURE EraseRoundRect(r: Rect;ovalWidth: INTEGER;ovalHeight: INTEGER);PROCEDURE InvertRoundRect(r: Rect;ovalWidth: INTEGER;ovalHeight: INTEGER);PROCEDURE FillRoundRect(r: Rect;ovalWidth: INTEGER;ovalHeight: INTEGER; pat: Pattern);PROCEDURE FrameArc(r: Rect;startAngle: INTEGER;arcAngle: INTEGER);PROCEDURE PaintArc(r: Rect;startAngle: INTEGER;arcAngle: INTEGER);PROCEDURE EraseArc(r: Rect;startAngle: INTEGER;arcAngle: INTEGER);PROCEDURE InvertArc(r: Rect;startAngle: INTEGER;arcAngle: INTEGER);PROCEDURE FillArc(r: Rect;startAngle: INTEGER;arcAngle: INTEGER;pat: Pattern);FUNCTION NewRgn: RgnHandle;PROCEDURE OpenRgn;PROCEDURE CloseRgn(dstRgn: RgnHandle);FUNCTION BitMapToRegionGlue(region: RgnHandle;bMap: BitMap): OSErr;FUNCTION BitMapToRegion(region: RgnHandle;bMap: BitMap): OSErr;PROCEDURE DisposeRgn(rgn: RgnHandle);PROCEDURE CopyRgn(srcRgn: RgnHandle;dstRgn: RgnHandle);PROCEDURE SetEmptyRgn(rgn: RgnHandle);PROCEDURE SetRectRgn(rgn: RgnHandle;left: INTEGER;top: INTEGER;right: INTEGER; bottom: INTEGER);PROCEDURE RectRgn(rgn: RgnHandle;r: Rect);PROCEDURE OffsetRgn(rgn: RgnHandle;dh: INTEGER;dv: INTEGER);PROCEDURE InsetRgn(rgn: RgnHandle;dh: INTEGER;dv: INTEGER);PROCEDURE SectRgn(srcRgnA: RgnHandle;srcRgnB: RgnHandle;dstRgn: RgnHandle);PROCEDURE UnionRgn(srcRgnA: RgnHandle;srcRgnB: RgnHandle;dstRgn: RgnHandle);PROCEDURE DiffRgn(srcRgnA: RgnHandle;srcRgnB: RgnHandle;dstRgn: RgnHandle);PROCEDURE XorRgn(srcRgnA: RgnHandle;srcRgnB: RgnHandle;dstRgn: RgnHandle);FUNCTION RectInRgn(r: Rect;rgn: RgnHandle): BOOLEAN;FUNCTION EqualRgn(rgnA: RgnHandle;rgnB: RgnHandle): BOOLEAN;FUNCTION EmptyRgn(rgn: RgnHandle): BOOLEAN;PROCEDURE FrameRgn(rgn: RgnHandle);PROCEDURE PaintRgn(rgn: RgnHandle);PROCEDURE EraseRgn(rgn: RgnHandle);PROCEDURE InvertRgn(rgn: RgnHandle);PROCEDURE FillRgn(rgn: RgnHandle;pat: Pattern);PROCEDURE ScrollRect(r: Rect;dh: INTEGER;dv: INTEGER;updateRgn: RgnHandle);PROCEDURE CopyBits(srcBits: BitMap;dstBits: BitMap;srcRect: Rect;dstRect: Rect; mode: INTEGER;maskRgn: RgnHandle);PROCEDURE SeedFill(srcPtr: Ptr;dstPtr: Ptr;srcRow: INTEGER;dstRow: INTEGER; height: INTEGER;words: INTEGER;seedH: INTEGER;seedV: INTEGER);PROCEDURE CalcMask(srcPtr: Ptr;dstPtr: Ptr;srcRow: INTEGER;dstRow: INTEGER; height: INTEGER;words: INTEGER);PROCEDURE CopyMask(srcBits: BitMap;maskBits: BitMap;dstBits: BitMap;srcRect: Rect; maskRect: Rect;dstRect: Rect);FUNCTION OpenPicture(picFrame: Rect): PicHandle;PROCEDURE PicComment(kind: INTEGER;dataSize: INTEGER;dataHandle: Handle);PROCEDURE ClosePicture;PROCEDURE DrawPicture(myPicture: PicHandle;dstRect: Rect);PROCEDURE KillPicture(myPicture: PicHandle);FUNCTION OpenPoly: PolyHandle;PROCEDURE ClosePoly;PROCEDURE KillPoly(poly: PolyHandle);PROCEDURE OffsetPoly(poly: PolyHandle;dh: INTEGER;dv: INTEGER);PROCEDURE FramePoly(poly: PolyHandle);PROCEDURE PaintPoly(poly: PolyHandle);PROCEDURE ErasePoly(poly: PolyHandle);PROCEDURE InvertPoly(poly: PolyHandle);PROCEDURE FillPoly(poly: PolyHandle;pat: Pattern);PROCEDURE SetPt(VAR pt: Point;h: INTEGER;v: INTEGER);PROCEDURE LocalToGlobal(VAR pt: Point);PROCEDURE GlobalToLocal(VAR pt: Point);FUNCTION Random: INTEGER;PROCEDURE StuffHex(thingPtr: Ptr;s: Str255);FUNCTION GetPixel(h: INTEGER;v: INTEGER): BOOLEAN;PROCEDURE ScalePt(VAR pt: Point;srcRect: Rect;dstRect: Rect);PROCEDURE MapPt(VAR pt: Point;srcRect: Rect;dstRect: Rect);PROCEDURE MapRect(VAR r: Rect;srcRect: Rect;dstRect: Rect);PROCEDURE MapRgn(rgn: RgnHandle;srcRect: Rect;dstRect: Rect);PROCEDURE MapPoly(poly: PolyHandle;srcRect: Rect;dstRect: Rect);PROCEDURE SetStdProcs(VAR procs: QDProcs);PROCEDURE StdRect(verb: GrafVerb;r: Rect);PROCEDURE StdRRect(verb: GrafVerb;r: Rect;ovalWidth: INTEGER;ovalHeight: INTEGER);PROCEDURE StdOval(verb: GrafVerb;r: Rect);PROCEDURE StdArc(verb: GrafVerb;r: Rect;startAngle: INTEGER;arcAngle: INTEGER);PROCEDURE StdPoly(verb: GrafVerb;poly: PolyHandle);PROCEDURE StdRgn(verb: GrafVerb;rgn: RgnHandle);PROCEDURE StdBits(VAR srcBits: BitMap;VAR srcRect: Rect;dstRect: Rect;mode: INTEGER; maskRgn: RgnHandle);PROCEDURE StdComment(kind: INTEGER;dataSize: INTEGER;dataHandle: Handle);PROCEDURE StdGetPic(dataPtr: Ptr;byteCount: INTEGER);PROCEDURE StdPutPic(dataPtr: Ptr;byteCount: INTEGER);PROCEDURE AddPt(src: Point;VAR dst: Point);FUNCTION EqualPt(pt1: Point;pt2: Point): BOOLEAN;FUNCTION PtInRect(pt: Point;r: Rect): BOOLEAN;PROCEDURE Pt2Rect(pt1: Point;pt2: Point;VAR dstRect: Rect);PROCEDURE PtToAngle(r: Rect;pt: Point;VAR angle: INTEGER);FUNCTION PtInRgn(pt: Point;rgn: RgnHandle): BOOLEAN;PROCEDURE StdLine(newPt: Point);PROCEDURE OpenCPort(port: CGrafPtr);PROCEDURE InitCPort(port: CGrafPtr);PROCEDURE CloseCPort(port: CGrafPtr);FUNCTION NewPixMap: PixMapHandle;PROCEDURE DisposPixMap(pm: PixMapHandle);PROCEDURE DisposePixMap(pm: PixMapHandle);PROCEDURE CopyPixMap(srcPM: PixMapHandle;dstPM: PixMapHandle);FUNCTION NewPixPat: PixPatHandle;PROCEDURE DisposPixPat(pp: PixPatHandle);PROCEDURE DisposePixPat(pp: PixPatHandle);PROCEDURE CopyPixPat(srcPP: PixPatHandle;dstPP: PixPatHandle);PROCEDURE PenPixPat(pp: PixPatHandle);PROCEDURE BackPixPat(pp: PixPatHandle);FUNCTION GetPixPat(patID: INTEGER): PixPatHandle;PROCEDURE MakeRGBPat(pp: PixPatHandle;myColor: RGBColor);PROCEDURE FillCRect(r: Rect;pp: PixPatHandle);PROCEDURE FillCOval(r: Rect;pp: PixPatHandle);PROCEDURE FillCRoundRect(r: Rect;ovalWidth: INTEGER;ovalHeight: INTEGER; pp: PixPatHandle);PROCEDURE FillCArc(r: Rect;startAngle: INTEGER;arcAngle: INTEGER;pp: PixPatHandle);PROCEDURE FillCRgn(rgn: RgnHandle;pp: PixPatHandle);PROCEDURE FillCPoly(poly: PolyHandle;pp: PixPatHandle);PROCEDURE RGBForeColor(color: RGBColor);PROCEDURE RGBBackColor(color: RGBColor);PROCEDURE SetCPixel(h: INTEGER;v: INTEGER;cPix: RGBColor);PROCEDURE SetPortPix(pm: PixMapHandle);PROCEDURE GetCPixel(h: INTEGER;v: INTEGER;VAR cPix: RGBColor);PROCEDURE GetForeColor(VAR color: RGBColor);PROCEDURE GetBackColor(VAR color: RGBColor);PROCEDURE SeedCFill(srcBits: BitMap;dstBits: BitMap;srcRect: Rect;dstRect: Rect; seedH: INTEGER;seedV: INTEGER;matchProc: ProcPtr;matchData: LONGINT);PROCEDURE CalcCMask(srcBits: BitMap;dstBits: BitMap;srcRect: Rect;dstRect: Rect; seedRGB: RGBColor;matchProc: ProcPtr;matchData: LONGINT);FUNCTION OpenCPicture(newHeader: OpenCPicParams): PicHandle;PROCEDURE OpColor(color: RGBColor);PROCEDURE HiliteColor(color: RGBColor);PROCEDURE DisposCTable(cTable: CTabHandle);PROCEDURE DisposeCTable(cTable: CTabHandle);FUNCTION GetCTable(ctID: INTEGER): CTabHandle;FUNCTION GetCCursor(crsrID: INTEGER): CCrsrHandle;PROCEDURE SetCCursor(cCrsr: CCrsrHandle);PROCEDURE AllocCursor;PROCEDURE DisposCCursor(cCrsr: CCrsrHandle);PROCEDURE DisposeCCursor(cCrsr: CCrsrHandle);FUNCTION GetCIcon(iconID: INTEGER): CIconHandle;PROCEDURE PlotCIcon(theRect: Rect;theIcon: CIconHandle);PROCEDURE DisposCIcon(theIcon: CIconHandle);PROCEDURE DisposeCIcon(theIcon: CIconHandle);PROCEDURE SetStdCProcs(VAR procs: CQDProcs);FUNCTION GetMaxDevice(globalRect: Rect): GDHandle;FUNCTION GetCTSeed: LONGINT;FUNCTION GetDeviceList: GDHandle;FUNCTION GetMainDevice: GDHandle;FUNCTION GetNextDevice(curDevice: GDHandle): GDHandle;FUNCTION TestDeviceAttribute(gdh: GDHandle;attribute: INTEGER): BOOLEAN;PROCEDURE SetDeviceAttribute(gdh: GDHandle;attribute: INTEGER;value: BOOLEAN);PROCEDURE InitGDevice(qdRefNum: INTEGER;mode: LONGINT;gdh: GDHandle);FUNCTION NewGDevice(refNum: INTEGER;mode: LONGINT): GDHandle;PROCEDURE DisposGDevice(gdh: GDHandle);PROCEDURE DisposeGDevice(gdh: GDHandle);PROCEDURE SetGDevice(gd: GDHandle);FUNCTION GetGDevice: GDHandle;FUNCTION Color2Index(myColor: RGBColor): LONGINT;PROCEDURE Index2Color(index: LONGINT;VAR aColor: RGBColor);PROCEDURE InvertColor(VAR myColor: RGBColor);FUNCTION RealColor(color: RGBColor): BOOLEAN;PROCEDURE GetSubTable(myColors: CTabHandle;iTabRes: INTEGER;targetTbl: CTabHandle);PROCEDURE MakeITable(cTabH: CTabHandle;iTabH: ITabHandle;res: INTEGER);PROCEDURE AddSearch(searchProc: ProcPtr);PROCEDURE AddComp(compProc: ProcPtr);PROCEDURE DelSearch(searchProc: ProcPtr);PROCEDURE DelComp(compProc: ProcPtr);PROCEDURE SubPt(src: Point;VAR dst: Point);PROCEDURE SetClientID(id: INTEGER);PROCEDURE ProtectEntry(index: INTEGER;protect: BOOLEAN);PROCEDURE ReserveEntry(index: INTEGER;reserve: BOOLEAN);PROCEDURE SetEntries(start: INTEGER;count: INTEGER;aTable: CSpecArray);PROCEDURE SaveEntries(srcTable: CTabHandle;resultTable: CTabHandle;VAR selection: ReqListRec);PROCEDURE RestoreEntries(srcTable: CTabHandle;dstTable: CTabHandle;VAR selection: ReqListRec);FUNCTION QDError: INTEGER;PROCEDURE CopyDeepMask(srcBits: BitMap;maskBits: BitMap;dstBits: BitMap; srcRect: Rect;maskRect: Rect;dstRect: Rect;mode: INTEGER;maskRgn: RgnHandle);PROCEDURE DeviceLoop(drawingRgn: RgnHandle;drawingProc: DeviceLoopDrawingProcPtr; userData: LONGINT;flags: DeviceLoopFlags);FUNCTION GetMaskTable: Ptr;IMPLEMENTATIONPROCEDURE InitGraf(globalPtr: Ptr);BEGIN END;PROCEDURE OpenPort(port: GrafPtr);BEGIN END;PROCEDURE InitPort(port: GrafPtr);BEGIN END;PROCEDURE ClosePort(port: GrafPtr);BEGIN END;PROCEDURE SetPort(port: GrafPtr);BEGIN END;PROCEDURE GetPort(VAR port: GrafPtr);BEGIN END;PROCEDURE GrafDevice(device: INTEGER);BEGIN END;PROCEDURE SetPortBits(bm: BitMap);BEGIN END;PROCEDURE PortSize(width: INTEGER;height: INTEGER);BEGIN END;PROCEDURE MovePortTo(leftGlobal: INTEGER;topGlobal: INTEGER);BEGIN END;PROCEDURE SetOrigin(h: INTEGER;v: INTEGER);BEGIN END;PROCEDURE SetClip(rgn: RgnHandle);BEGIN END;PROCEDURE GetClip(rgn: RgnHandle);BEGIN END;PROCEDURE ClipRect(r: Rect);BEGIN END;PROCEDURE BackPat(pat: Pattern);BEGIN END;PROCEDURE InitCursor;BEGIN END;PROCEDURE SetCursor(crsr: Cursor);BEGIN END;PROCEDURE HideCursor;BEGIN END;PROCEDURE ShowCursor;BEGIN END;PROCEDURE ObscureCursor;BEGIN END;PROCEDURE HidePen;BEGIN END;PROCEDURE ShowPen;BEGIN END;PROCEDURE GetPen(VAR pt: Point);BEGIN END;PROCEDURE GetPenState(VAR pnState: PenState);BEGIN END;PROCEDURE SetPenState(pnState: PenState);BEGIN END;PROCEDURE PenSize(width: INTEGER;height: INTEGER);BEGIN END;PROCEDURE PenMode(mode: INTEGER);BEGIN END;PROCEDURE PenPat(pat: Pattern);BEGIN END;PROCEDURE PenNormal;BEGIN END;PROCEDURE MoveTo(h: INTEGER;v: INTEGER);BEGIN END;PROCEDURE Move(dh: INTEGER;dv: INTEGER);BEGIN END;PROCEDURE LineTo(h: INTEGER;v: INTEGER);BEGIN END;PROCEDURE Line(dh: INTEGER;dv: INTEGER);BEGIN END;PROCEDURE ForeColor(color: LONGINT);BEGIN END;PROCEDURE BackColor(color: LONGINT);BEGIN END;PROCEDURE ColorBit(whichBit: INTEGER);BEGIN END;PROCEDURE SetRect(VAR r: Rect;left: INTEGER;top: INTEGER;right: INTEGER; bottom: INTEGER);BEGIN END;PROCEDURE OffsetRect(VAR r: Rect;dh: INTEGER;dv: INTEGER);BEGIN END;PROCEDURE InsetRect(VAR r: Rect;dh: INTEGER;dv: INTEGER);BEGIN END;FUNCTION SectRect(src1: Rect;src2: Rect;VAR dstRect: Rect): BOOLEAN;BEGIN SectRect := false END;PROCEDURE UnionRect(src1: Rect;src2: Rect;VAR dstRect: Rect);BEGIN END;FUNCTION EqualRect(rect1: Rect;rect2: Rect): BOOLEAN;BEGIN EqualRect := false END;FUNCTION EmptyRect(r: Rect): BOOLEAN;BEGIN EmptyRect := false END;PROCEDURE FrameRect(r: Rect);BEGIN END;PROCEDURE PaintRect(r: Rect);BEGIN END;PROCEDURE EraseRect(r: Rect);BEGIN END;PROCEDURE InvertRect(r: Rect);BEGIN END;PROCEDURE FillRect(r: Rect;pat: Pattern);BEGIN END;PROCEDURE FrameOval(r: Rect);BEGIN END;PROCEDURE PaintOval(r: Rect);BEGIN END;PROCEDURE EraseOval(r: Rect);BEGIN END;PROCEDURE InvertOval(r: Rect);BEGIN END;PROCEDURE FillOval(r: Rect;pat: Pattern);BEGIN END;PROCEDURE FrameRoundRect(r: Rect;ovalWidth: INTEGER;ovalHeight: INTEGER);BEGIN END;PROCEDURE PaintRoundRect(r: Rect;ovalWidth: INTEGER;ovalHeight: INTEGER);BEGIN END;PROCEDURE EraseRoundRect(r: Rect;ovalWidth: INTEGER;ovalHeight: INTEGER);BEGIN END;PROCEDURE InvertRoundRect(r: Rect;ovalWidth: INTEGER;ovalHeight: INTEGER);BEGIN END;PROCEDURE FillRoundRect(r: Rect;ovalWidth: INTEGER;ovalHeight: INTEGER; pat: Pattern);BEGIN END;PROCEDURE FrameArc(r: Rect;startAngle: INTEGER;arcAngle: INTEGER);BEGIN END;PROCEDURE PaintArc(r: Rect;startAngle: INTEGER;arcAngle: INTEGER);BEGIN END;PROCEDURE EraseArc(r: Rect;startAngle: INTEGER;arcAngle: INTEGER);BEGIN END;PROCEDURE InvertArc(r: Rect;startAngle: INTEGER;arcAngle: INTEGER);BEGIN END;PROCEDURE FillArc(r: Rect;startAngle: INTEGER;arcAngle: INTEGER;pat: Pattern);BEGIN END;FUNCTION NewRgn: RgnHandle;BEGIN NewRgn := new(RgnHandle)  END;PROCEDURE OpenRgn;BEGIN END;PROCEDURE CloseRgn(dstRgn: RgnHandle);BEGIN END;FUNCTION BitMapToRegionGlue(region: RgnHandle;bMap: BitMap): OSErr;BEGIN BitMapToRegionGlue :=  noErr END;FUNCTION BitMapToRegion(region: RgnHandle;bMap: BitMap): OSErr;BEGIN BitMapToRegion := noErr  END;PROCEDURE DisposeRgn(rgn: RgnHandle);BEGIN END;PROCEDURE CopyRgn(srcRgn: RgnHandle;dstRgn: RgnHandle);BEGIN END;PROCEDURE SetEmptyRgn(rgn: RgnHandle);BEGIN END;PROCEDURE SetRectRgn(rgn: RgnHandle;left: INTEGER;top: INTEGER;right: INTEGER; bottom: INTEGER);BEGIN END;PROCEDURE RectRgn(rgn: RgnHandle;r: Rect);BEGIN END;PROCEDURE OffsetRgn(rgn: RgnHandle;dh: INTEGER;dv: INTEGER);BEGIN END;PROCEDURE InsetRgn(rgn: RgnHandle;dh: INTEGER;dv: INTEGER);BEGIN END;PROCEDURE SectRgn(srcRgnA: RgnHandle;srcRgnB: RgnHandle;dstRgn: RgnHandle);BEGIN END;PROCEDURE UnionRgn(srcRgnA: RgnHandle;srcRgnB: RgnHandle;dstRgn: RgnHandle);BEGIN END;PROCEDURE DiffRgn(srcRgnA: RgnHandle;srcRgnB: RgnHandle;dstRgn: RgnHandle);BEGIN END;PROCEDURE XorRgn(srcRgnA: RgnHandle;srcRgnB: RgnHandle;dstRgn: RgnHandle);BEGIN END;FUNCTION RectInRgn(r: Rect;rgn: RgnHandle): BOOLEAN;BEGIN RectInRgn := false  END;FUNCTION EqualRgn(rgnA: RgnHandle;rgnB: RgnHandle): BOOLEAN;BEGIN EqualRgn := false  END;FUNCTION EmptyRgn(rgn: RgnHandle): BOOLEAN;BEGIN EmptyRgn := false END;PROCEDURE FrameRgn(rgn: RgnHandle);BEGIN END;PROCEDURE PaintRgn(rgn: RgnHandle);BEGIN END;PROCEDURE EraseRgn(rgn: RgnHandle);BEGIN END;PROCEDURE InvertRgn(rgn: RgnHandle);BEGIN END;PROCEDURE FillRgn(rgn: RgnHandle;pat: Pattern);BEGIN END;PROCEDURE ScrollRect(r: Rect;dh: INTEGER;dv: INTEGER;updateRgn: RgnHandle);BEGIN END;PROCEDURE CopyBits(srcBits: BitMap;dstBits: BitMap;srcRect: Rect;dstRect: Rect; mode: INTEGER;maskRgn: RgnHandle);BEGIN END;PROCEDURE SeedFill(srcPtr: Ptr;dstPtr: Ptr;srcRow: INTEGER;dstRow: INTEGER; height: INTEGER;words: INTEGER;seedH: INTEGER;seedV: INTEGER);BEGIN END;PROCEDURE CalcMask(srcPtr: Ptr;dstPtr: Ptr;srcRow: INTEGER;dstRow: INTEGER; height: INTEGER;words: INTEGER);BEGIN END;PROCEDURE CopyMask(srcBits: BitMap;maskBits: BitMap;dstBits: BitMap;srcRect: Rect; maskRect: Rect;dstRect: Rect);BEGIN END;FUNCTION OpenPicture(picFrame: Rect): PicHandle;BEGIN OpenPicture := new(PicHandle)  END;PROCEDURE PicComment(kind: INTEGER;dataSize: INTEGER;dataHandle: Handle);BEGIN END;PROCEDURE ClosePicture;BEGIN END;PROCEDURE DrawPicture(myPicture: PicHandle;dstRect: Rect);BEGIN END;PROCEDURE KillPicture(myPicture: PicHandle);BEGIN END;FUNCTION OpenPoly: PolyHandle;BEGIN OpenPoly := new(PolyHandle)  END;PROCEDURE ClosePoly;BEGIN END;PROCEDURE KillPoly(poly: PolyHandle);BEGIN END;PROCEDURE OffsetPoly(poly: PolyHandle;dh: INTEGER;dv: INTEGER);BEGIN END;PROCEDURE FramePoly(poly: PolyHandle);BEGIN END;PROCEDURE PaintPoly(poly: PolyHandle);BEGIN END;PROCEDURE ErasePoly(poly: PolyHandle);BEGIN END;PROCEDURE InvertPoly(poly: PolyHandle);BEGIN END;PROCEDURE FillPoly(poly: PolyHandle;pat: Pattern);BEGIN END;PROCEDURE SetPt(VAR pt: Point;h: INTEGER;v: INTEGER);BEGIN END;PROCEDURE LocalToGlobal(VAR pt: Point);BEGIN END;PROCEDURE GlobalToLocal(VAR pt: Point);BEGIN END;FUNCTION Random: INTEGER;BEGIN Random :=  0 END;PROCEDURE StuffHex(thingPtr: Ptr;s: Str255);BEGIN END;FUNCTION GetPixel(h: INTEGER;v: INTEGER): BOOLEAN;BEGIN GetPixel := false  END;PROCEDURE ScalePt(VAR pt: Point;srcRect: Rect;dstRect: Rect);BEGIN END;PROCEDURE MapPt(VAR pt: Point;srcRect: Rect;dstRect: Rect);BEGIN END;PROCEDURE MapRect(VAR r: Rect;srcRect: Rect;dstRect: Rect);BEGIN END;PROCEDURE MapRgn(rgn: RgnHandle;srcRect: Rect;dstRect: Rect);BEGIN END;PROCEDURE MapPoly(poly: PolyHandle;srcRect: Rect;dstRect: Rect);BEGIN END;PROCEDURE SetStdProcs(VAR procs: QDProcs);BEGIN END;PROCEDURE StdRect(verb: GrafVerb;r: Rect);BEGIN END;PROCEDURE StdRRect(verb: GrafVerb;r: Rect;ovalWidth: INTEGER;ovalHeight: INTEGER);BEGIN END;PROCEDURE StdOval(verb: GrafVerb;r: Rect);BEGIN END;PROCEDURE StdArc(verb: GrafVerb;r: Rect;startAngle: INTEGER;arcAngle: INTEGER);BEGIN END;PROCEDURE StdPoly(verb: GrafVerb;poly: PolyHandle);BEGIN END;PROCEDURE StdRgn(verb: GrafVerb;rgn: RgnHandle);BEGIN END;PROCEDURE StdBits(VAR srcBits: BitMap;VAR srcRect: Rect;dstRect: Rect;mode: INTEGER; maskRgn: RgnHandle);BEGIN END;PROCEDURE StdComment(kind: INTEGER;dataSize: INTEGER;dataHandle: Handle);BEGIN END;PROCEDURE StdGetPic(dataPtr: Ptr;byteCount: INTEGER);BEGIN END;PROCEDURE StdPutPic(dataPtr: Ptr;byteCount: INTEGER);BEGIN END;PROCEDURE AddPt(src: Point;VAR dst: Point);BEGIN END;FUNCTION EqualPt(pt1: Point;pt2: Point): BOOLEAN;BEGIN EqualPt := false  END;FUNCTION PtInRect(pt: Point;r: Rect): BOOLEAN;BEGIN PtInRect := false  END;PROCEDURE Pt2Rect(pt1: Point;pt2: Point;VAR dstRect: Rect);BEGIN END;PROCEDURE PtToAngle(r: Rect;pt: Point;VAR angle: INTEGER);BEGIN END;FUNCTION PtInRgn(pt: Point;rgn: RgnHandle): BOOLEAN;BEGIN PtInRgn := false END;PROCEDURE StdLine(newPt: Point);BEGIN END;PROCEDURE OpenCPort(port: CGrafPtr);BEGIN END;PROCEDURE InitCPort(port: CGrafPtr);BEGIN END;PROCEDURE CloseCPort(port: CGrafPtr);BEGIN END;FUNCTION NewPixMap: PixMapHandle;BEGIN NewPixMap :=  new(PixMapHandle) END;PROCEDURE DisposPixMap(pm: PixMapHandle);BEGIN END;PROCEDURE DisposePixMap(pm: PixMapHandle);BEGIN END;PROCEDURE CopyPixMap(srcPM: PixMapHandle;dstPM: PixMapHandle);BEGIN END;FUNCTION NewPixPat: PixPatHandle;BEGIN NewPixPat := new(PixPatHandle)  END;PROCEDURE DisposPixPat(pp: PixPatHandle);BEGIN END;PROCEDURE DisposePixPat(pp: PixPatHandle);BEGIN END;PROCEDURE CopyPixPat(srcPP: PixPatHandle;dstPP: PixPatHandle);BEGIN END;PROCEDURE PenPixPat(pp: PixPatHandle);BEGIN END;PROCEDURE BackPixPat(pp: PixPatHandle);BEGIN END;FUNCTION GetPixPat(patID: INTEGER): PixPatHandle;BEGIN GetPixPat := new(PixPatHandle)  END;PROCEDURE MakeRGBPat(pp: PixPatHandle;myColor: RGBColor);BEGIN END;PROCEDURE FillCRect(r: Rect;pp: PixPatHandle);BEGIN END;PROCEDURE FillCOval(r: Rect;pp: PixPatHandle);BEGIN END;PROCEDURE FillCRoundRect(r: Rect;ovalWidth: INTEGER;ovalHeight: INTEGER; pp: PixPatHandle);BEGIN END;PROCEDURE FillCArc(r: Rect;startAngle: INTEGER;arcAngle: INTEGER;pp: PixPatHandle);BEGIN END;PROCEDURE FillCRgn(rgn: RgnHandle;pp: PixPatHandle);BEGIN END;PROCEDURE FillCPoly(poly: PolyHandle;pp: PixPatHandle);BEGIN END;PROCEDURE RGBForeColor(color: RGBColor);BEGIN END;PROCEDURE RGBBackColor(color: RGBColor);BEGIN END;PROCEDURE SetCPixel(h: INTEGER;v: INTEGER;cPix: RGBColor);BEGIN END;PROCEDURE SetPortPix(pm: PixMapHandle);BEGIN END;PROCEDURE GetCPixel(h: INTEGER;v: INTEGER;VAR cPix: RGBColor);BEGIN END;PROCEDURE GetForeColor(VAR color: RGBColor);BEGIN END;PROCEDURE GetBackColor(VAR color: RGBColor);BEGIN END;PROCEDURE SeedCFill(srcBits: BitMap;dstBits: BitMap;srcRect: Rect;dstRect: Rect; seedH: INTEGER;seedV: INTEGER;matchProc: ProcPtr;matchData: LONGINT);BEGIN END;PROCEDURE CalcCMask(srcBits: BitMap;dstBits: BitMap;srcRect: Rect;dstRect: Rect; seedRGB: RGBColor;matchProc: ProcPtr;matchData: LONGINT);BEGIN END;FUNCTION OpenCPicture(newHeader: OpenCPicParams): PicHandle;BEGIN OpenCPicture := new(PicHandle)  END;PROCEDURE OpColor(color: RGBColor);BEGIN END;PROCEDURE HiliteColor(color: RGBColor);BEGIN END;PROCEDURE DisposCTable(cTable: CTabHandle);BEGIN END;PROCEDURE DisposeCTable(cTable: CTabHandle);BEGIN END;FUNCTION GetCTable(ctID: INTEGER): CTabHandle;BEGIN GetCTable := new(CTabHandle) END;FUNCTION GetCCursor(crsrID: INTEGER): CCrsrHandle;BEGIN GetCCursor := new(CCrsrHandle) END;PROCEDURE SetCCursor(cCrsr: CCrsrHandle);BEGIN END;PROCEDURE AllocCursor;BEGIN END;PROCEDURE DisposCCursor(cCrsr: CCrsrHandle);BEGIN END;PROCEDURE DisposeCCursor(cCrsr: CCrsrHandle);BEGIN END;FUNCTION GetCIcon(iconID: INTEGER): CIconHandle;BEGIN GetCIcon := new(CIconHandle)  END;PROCEDURE PlotCIcon(theRect: Rect;theIcon: CIconHandle);BEGIN END;PROCEDURE DisposCIcon(theIcon: CIconHandle);BEGIN END;PROCEDURE DisposeCIcon(theIcon: CIconHandle);BEGIN END;PROCEDURE SetStdCProcs(VAR procs: CQDProcs);BEGIN END;FUNCTION GetMaxDevice(globalRect: Rect): GDHandle;BEGIN GetMaxDevice := new(GDHandle) END;FUNCTION GetCTSeed: LONGINT;BEGIN GetCTSeed :=  0 END;FUNCTION GetDeviceList: GDHandle;BEGIN GetDeviceList := new(GDHandle)  END;FUNCTION GetMainDevice: GDHandle;BEGIN GetMainDevice := new(GDHandle) END;FUNCTION GetNextDevice(curDevice: GDHandle): GDHandle;BEGIN GetNextDevice := new(GDHandle) END;FUNCTION TestDeviceAttribute(gdh: GDHandle;attribute: INTEGER): BOOLEAN;BEGIN TestDeviceAttribute := false END;PROCEDURE SetDeviceAttribute(gdh: GDHandle;attribute: INTEGER;value: BOOLEAN);BEGIN END;PROCEDURE InitGDevice(qdRefNum: INTEGER;mode: LONGINT;gdh: GDHandle);BEGIN END;FUNCTION NewGDevice(refNum: INTEGER;mode: LONGINT): GDHandle;BEGIN NewGDevice := new(GDHandle)  END;PROCEDURE DisposGDevice(gdh: GDHandle);BEGIN END;PROCEDURE DisposeGDevice(gdh: GDHandle);BEGIN END;PROCEDURE SetGDevice(gd: GDHandle);BEGIN END;FUNCTION GetGDevice: GDHandle;BEGIN GetGDevice := new(GDHandle)  END;FUNCTION Color2Index(myColor: RGBColor): LONGINT;BEGIN Color2Index := 0 END;PROCEDURE Index2Color(index: LONGINT;VAR aColor: RGBColor);BEGIN END;PROCEDURE InvertColor(VAR myColor: RGBColor);BEGIN END;FUNCTION RealColor(color: RGBColor): BOOLEAN;BEGIN RealColor := false  END;PROCEDURE GetSubTable(myColors: CTabHandle;iTabRes: INTEGER;targetTbl: CTabHandle);BEGIN END;PROCEDURE MakeITable(cTabH: CTabHandle;iTabH: ITabHandle;res: INTEGER);BEGIN END;PROCEDURE AddSearch(searchProc: ProcPtr);BEGIN END;PROCEDURE AddComp(compProc: ProcPtr);BEGIN END;PROCEDURE DelSearch(searchProc: ProcPtr);BEGIN END;PROCEDURE DelComp(compProc: ProcPtr);BEGIN END;PROCEDURE SubPt(src: Point;VAR dst: Point);BEGIN END;PROCEDURE SetClientID(id: INTEGER);BEGIN END;PROCEDURE ProtectEntry(index: INTEGER;protect: BOOLEAN);BEGIN END;PROCEDURE ReserveEntry(index: INTEGER;reserve: BOOLEAN);BEGIN END;PROCEDURE SetEntries(start: INTEGER;count: INTEGER;aTable: CSpecArray);BEGIN END;PROCEDURE SaveEntries(srcTable: CTabHandle;resultTable: CTabHandle;VAR selection: ReqListRec);BEGIN END;PROCEDURE RestoreEntries(srcTable: CTabHandle;dstTable: CTabHandle;VAR selection: ReqListRec);BEGIN END;FUNCTION QDError: INTEGER;BEGIN QDError := 0 END;PROCEDURE CopyDeepMask(srcBits: BitMap;maskBits: BitMap;dstBits: BitMap; srcRect: Rect;maskRect: Rect;dstRect: Rect;mode: INTEGER;maskRgn: RgnHandle);BEGIN END;PROCEDURE DeviceLoop(drawingRgn: RgnHandle;drawingProc: DeviceLoopDrawingProcPtr; userData: LONGINT;flags: DeviceLoopFlags);BEGIN END;FUNCTION GetMaskTable: Ptr;BEGIN GetMaskTable := new(Ptr) END; END.