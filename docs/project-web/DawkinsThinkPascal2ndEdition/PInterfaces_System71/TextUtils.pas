{	File:		TextUtils.p	 Pascal Interface to the Macintosh Libraries	Copyright:	© 1985-1992 by Apple Computer, Inc.	All rights reserved.	Change History (most recent first):		<14>	10/16/92	PKE		For new IM: Change reserved field name in NBreakTable to length,									reflecting its real usage.		<13>	 6/26/92	DCL		Miner Formatting Changes. Digging deep for things to do. Getting									the file ready for ETO 8.		<12>	 5/29/92	DCL		Moved DateTime stuff to OSUtils and Intl stuff to IntlResources		<11>	  5/7/92	DCL		NIIM: Movin date & time Stuff from DateTime to TextUtils.		<10>	  5/6/92	DCL		NIIM: Moved KeyTrans back from TextUtils to Events.		 <9>	  5/5/92	DCL		For New Inside Mac: removing 'sc' prefixes from some calls,									moving some calls from script to TextUtils, and moving some from									TextUtils & QuickDraw to QuickdrawText. Weeeeeeee!		 <8>	 4/17/92	DCL		For New Inside Mac: Mo' Better Call Names. Str -> String, Secs									-> Seconds. Sorry, no more Secs.		 <7>	 4/15/92	DCL		For New Inside Mac: Moved StyledLineBreakCode from script to									TextUtils.		 <6>	 4/15/92	DCL		For New Inside Mac: Moved many definitions from Script to									TextUtils and QuickDraw. And added new synonyms. #1025005		 <5>	  4/6/92	DCL		For New Inside Mac: Moved declarations from Script.[aph] to									TextUtils.[aph]. #1025005		 <4>	  4/1/92	DCL		Fix the calls from xxxxIntlxxxx to xxxxxxxxxIntl.		 <3>	 3/30/92	DCL		New Improved Names for New Improved Inside Mac.		<2+>	 3/26/92	DCL	For New Inside Mac:  Added New Improved Better Names for the									same old calls.  #1025005		 <2>	 3/26/92	DCL	For New IM: Moved many declarations and routines from									Packages.[ph] to TextUtils.[ph]		 <1>	 3/12/92	DCL	first checked in} UNIT TextUtils; INTERFACE USES Types, Quickdraw, Script, OSUtils, IntlResources, QuickdrawText;CONST{ Constants for truncWhere argument in TruncString and TruncText }truncEnd = 0;									{ Truncate at end }truncMiddle = $4000;							{ Truncate in middle }smTruncEnd = 0;									{ Truncate at end    obsolete }smTruncMiddle = $4000;							{ Truncate in middle     obsolete }{ Constants for TruncString and TruncText results }notTruncated = 0;								{ No truncation was necessary }truncated = 1;									{ Truncation performed }truncErr = -1;									{ General error }smNotTruncated = 0;								{ No truncation was necessary obsolete }smTruncated = 1;								{ Truncation performed    obsolete }smTruncErr = -1;								{ General error      obsolete }fVNumber = 0;									{first version of NumFormatString}{ String2Date status values }fatalDateTime = $8000;							{String2Date and String2Time mask to a fatal error}longDateFound = 1;								{String2Date mask to long date found}leftOverChars = 2;								{String2Date & Time mask to warn of left over characters}sepNotIntlSep = 4;								{String2Date & Time mask to warn of non-standard separators}fieldOrderNotIntl = 8;							{String2Date & Time mask to warn of non-standard field order}extraneousStrings = 16;							{String2Date & Time mask to warn of unparsable strings in text}tooManySeps = 32;								{String2Date & Time mask to warn of too many separators}sepNotConsistent = 64;							{String2Date & Time mask to warn of inconsistent separators}tokenErr = $8100;								{String2Date & Time mask for 'tokenizer err encountered'}cantReadUtilities = $8200;dateTimeNotFound = $8400;dateTimeInvalid = $8800;{ Special language code values for Language Order }systemCurLang = -2;								{ current (itlbLang) lang for system script }systemDefLang = -3;								{ default (table) lang for system script }currentCurLang = -4;							{ current (itlbLang) lang for current script }currentDefLang = -5;							{ default lang for current script }scriptCurLang = -6;								{ current (itlbLang) lang for specified script }scriptDefLang = -7;								{ default language for a specified script }iuSystemCurLang = -2;							{ <obsolete> current (itlbLang) lang for system script }iuSystemDefLang = -3;							{ <obsolete> default (table) lang for system script }iuCurrentCurLang = -4;							{ <obsolete> current (itlbLang) lang for current script }iuCurrentDefLang = -5;							{ <obsolete> default lang for current script }iuScriptCurLang = -6;							{ <obsolete> current (itlbLang) lang for specified script }iuScriptDefLang = -7;							{ <obsolete> default language for a specified script }TYPEStyledLineBreakCode = (smBreakWord,smBreakChar,smBreakOverflow);FormatClass = (fPositive,fNegative,fZero);FormatResultType = (fFormatOK,fBestGuess,fOutOfSynch,fSpuriousChars,fMissingDelimiter, fExtraDecimal,fMissingLiteral,fExtraExp,fFormatOverflow,fFormStrIsNAN, fBadPartsTable,fExtraPercent,fExtraSeparator,fEmptyFormatString);NumFormatString = PACKED RECORD fLength: Byte; fVersion: Byte; data: PACKED ARRAY [0..253] OF SignedByte;		{private data} END;NumFormatStringRec = NumFormatString;FVector = RECORD start: INTEGER; length: INTEGER; END;TripleInt = ARRAY [0..2] OF FVector;			{ index by [fPositive..fZero] }ScriptRunStatus = RECORD script: SignedByte; variant: SignedByte; END;{ New types for System 7.0:                  type for truncWhere parameter in new TruncString, TruncText }TruncCode = INTEGER;DateForm = (shortDate,longDate,abbrevDate);StringToDateStatus = INTEGER;String2DateStatus = INTEGER;DateCachePtr = ^DateCacheRecord;DateCacheRecord = PACKED RECORD hidden: ARRAY [0..255] OF INTEGER;				{only for temporary use} END;BreakTablePtr = ^BreakTable;BreakTable = RECORD charTypes: ARRAY [0..255] OF SignedByte; tripleLength: INTEGER; triples: ARRAY [0..0] OF INTEGER; END;NBreakTablePtr = ^NBreakTable;NBreakTable = RECORD flags1: SignedByte; flags2: SignedByte; version: INTEGER; classTableOff: INTEGER; auxCTableOff: INTEGER; backwdTableOff: INTEGER; forwdTableOff: INTEGER; doBackup: INTEGER; length: INTEGER;								{length of NBreakTable}			{<14>} charTypes: ARRAY [0..255] OF SignedByte; tables: ARRAY [0..0] OF INTEGER; END;PROCEDURE IUDateString(dateTime: LONGINT;longFlag: DateForm;VAR result: Str255);PROCEDURE DateString(dateTime: LONGINT;longFlag: DateForm;VAR result: Str255; intlHandle: Handle);PROCEDURE IUDatePString(dateTime: LONGINT;longFlag: DateForm;VAR result: Str255; intlHandle: Handle);PROCEDURE IUTimeString(dateTime: LONGINT;wantSeconds: BOOLEAN;VAR result: Str255);PROCEDURE TimeString(dateTime: LONGINT;wantSeconds: BOOLEAN;VAR result: Str255; intlHandle: Handle);PROCEDURE IUTimePString(dateTime: LONGINT;wantSeconds: BOOLEAN;VAR result: Str255; intlHandle: Handle);PROCEDURE LongDateString(VAR dateTime: LongDateTime;longFlag: DateForm; VAR result: Str255;intlHandle: Handle);PROCEDURE IULDateString(VAR dateTime: LongDateTime;longFlag: DateForm;VAR result: Str255; intlHandle: Handle);PROCEDURE LongTimeString(VAR dateTime: LongDateTime;wantSeconds: BOOLEAN; VAR result: Str255;intlHandle: Handle);PROCEDURE IULTimeString(VAR dateTime: LongDateTime;wantSeconds: BOOLEAN; VAR result: Str255;intlHandle: Handle);FUNCTION InitDateCache(theCache: DateCachePtr): OSErr;FUNCTION StringToDate(textPtr: Ptr;textLen: LONGINT;theCache: DateCachePtr; VAR lengthUsed: LONGINT;VAR dateTime: LongDateRec): StringToDateStatus;FUNCTION String2Date(textPtr: Ptr;textLen: LONGINT;theCache: DateCachePtr; VAR lengthUsed: LONGINT;VAR dateTime: LongDateRec): String2DateStatus;FUNCTION StringToTime(textPtr: Ptr;textLen: LONGINT;theCache: DateCachePtr; VAR lengthUsed: LONGINT;VAR dateTime: LongDateRec): StringToDateStatus;FUNCTION String2Time(textPtr: Ptr;textLen: LONGINT;theCache: DateCachePtr; VAR lengthUsed: LONGINT;VAR dateTime: LongDateRec): String2DateStatus;FUNCTION EqualString(str1: Str255;str2: Str255;caseSens: BOOLEAN;diacSens: BOOLEAN): BOOLEAN;PROCEDURE UpperString(VAR theString: Str255;diacSens: BOOLEAN);PROCEDURE UprString(VAR theString: Str255;diacSens: BOOLEAN);FUNCTION RelString(str1: Str255;str2: Str255;caseSens: BOOLEAN;diacSens: BOOLEAN): INTEGER;FUNCTION GetString(stringID: INTEGER): StringHandle;FUNCTION Munger(h: Handle;offset: LONGINT;ptr1: Ptr;len1: LONGINT;ptr2: Ptr; len2: LONGINT): LONGINT;PROCEDURE SetString(theString: StringHandle;strNew: Str255);FUNCTION NewString(theString: Str255): StringHandle;PROCEDURE GetIndString(VAR theString: Str255;strListID: INTEGER;index: INTEGER);FUNCTION IUMagString(aPtr: Ptr;bPtr: Ptr;aLen: INTEGER;bLen: INTEGER): INTEGER;FUNCTION IUMagIDString(aPtr: Ptr;bPtr: Ptr;aLen: INTEGER;bLen: INTEGER): INTEGER;FUNCTION IUCompString(aStr: Str255;bStr: Str255): INTEGER;FUNCTION IUEqualString(aStr: Str255;bStr: Str255): INTEGER;PROCEDURE StringToNum(theString: Str255;VAR theNum: LONGINT);PROCEDURE NumToString(theNum: LONGINT;VAR theString: Str255);FUNCTION CompareText(aPtr: Ptr;bPtr: Ptr;aLen: INTEGER;bLen: INTEGER;itl2Handle: Handle): INTEGER;FUNCTION IUMagPString(aPtr: Ptr;bPtr: Ptr;aLen: INTEGER;bLen: INTEGER;itl2Handle: Handle): INTEGER;FUNCTION IdenticalText(aPtr: Ptr;bPtr: Ptr;aLen: INTEGER;bLen: INTEGER; itl2Handle: Handle): INTEGER;FUNCTION IUMagIDPString(aPtr: Ptr;bPtr: Ptr;aLen: INTEGER;bLen: INTEGER; itl2Handle: Handle): INTEGER;FUNCTION CompareString(aStr: Str255;bStr: Str255;itl2Handle: Handle): INTEGER;FUNCTION IUCompPString(aStr: Str255;bStr: Str255;itl2Handle: Handle): INTEGER;FUNCTION IdenticalString(aStr: Str255;bStr: Str255;itl2Handle: Handle): INTEGER;FUNCTION IUEqualPString(aStr: Str255;bStr: Str255;itl2Handle: Handle): INTEGER;FUNCTION ScriptOrder(script1: ScriptCode;script2: ScriptCode): INTEGER;FUNCTION IUScriptOrder(script1: ScriptCode;script2: ScriptCode): INTEGER;FUNCTION LanguageOrder(language1: LangCode;language2: LangCode): INTEGER;FUNCTION IULangOrder(language1: LangCode;language2: LangCode): INTEGER;FUNCTION TextOrder(aPtr: Ptr;bPtr: Ptr;aLen: INTEGER;bLen: INTEGER;aScript: ScriptCode; bScript: ScriptCode;aLang: LangCode;bLang: LangCode): INTEGER;FUNCTION IUTextOrder(aPtr: Ptr;bPtr: Ptr;aLen: INTEGER;bLen: INTEGER;aScript: ScriptCode; bScript: ScriptCode;aLang: LangCode;bLang: LangCode): INTEGER;FUNCTION StringOrder(aStr: Str255;bStr: Str255;aScript: ScriptCode;bScript: ScriptCode; aLang: LangCode;bLang: LangCode): INTEGER;FUNCTION IUStringOrder(aStr: Str255;bStr: Str255;aScript: ScriptCode;bScript: ScriptCode; aLang: LangCode;bLang: LangCode): INTEGER;PROCEDURE FindWord(textPtr: Ptr;textLength: INTEGER;offset: INTEGER;leadingEdge: BOOLEAN; breaks: BreakTablePtr;VAR offsets: OffsetTable);PROCEDURE FindWordBreaks(textPtr: Ptr;textLength: INTEGER;offset: INTEGER; leadingEdge: BOOLEAN;breaks: BreakTablePtr;VAR offsets: OffsetTable;script: ScriptCode);PROCEDURE UprText(textPtr: Ptr;len: INTEGER);PROCEDURE LwrText(textPtr: Ptr;len: INTEGER);PROCEDURE LowerText(textPtr: Ptr;len: INTEGER);PROCEDURE StripText(textPtr: Ptr;len: INTEGER);PROCEDURE UpperText(textPtr: Ptr;len: INTEGER);PROCEDURE StripUpperText(textPtr: Ptr;len: INTEGER);FUNCTION StyledLineBreak(textPtr: Ptr;textLen: LONGINT;textStart: LONGINT; textEnd: LONGINT;flags: LONGINT;VAR textWidth: Fixed;VAR textOffset: LONGINT): StyledLineBreakCode;FUNCTION StringToFormatRec(inString: Str255;partsTable: NumberParts;VAR outString: NumFormatString): FormatStatus;FUNCTION Str2Format(inString: Str255;partsTable: NumberParts;VAR outString: NumFormatString): FormatStatus;FUNCTION FormatRecToString(myCanonical: NumFormatString;partsTable: NumberParts; VAR outString: Str255;VAR positions: TripleInt): FormatStatus;FUNCTION Format2Str(myCanonical: NumFormatString;partsTable: NumberParts; VAR outString: Str255;VAR positions: TripleInt): FormatStatus;FUNCTION ExtendedToString(x: Extended80;myCanonical: NumFormatString;partsTable: NumberParts; VAR outString: Str255): FormatStatus;FUNCTION FormatX2Str(x: Extended80;myCanonical: NumFormatString;partsTable: NumberParts; VAR outString: Str255): FormatStatus;FUNCTION StringToExtended(source: Str255;myCanonical: NumFormatString;partsTable: NumberParts; VAR x: Extended80): FormatStatus;FUNCTION FormatStr2X(source: Str255;myCanonical: NumFormatString;partsTable: NumberParts; VAR x: Extended80): FormatStatus;FUNCTION FindScriptRun(textPtr: Ptr;textLen: LONGINT;VAR lenUsed: LONGINT): ScriptRunStatus;PROCEDURE NFindWord(textPtr: Ptr;textLength: INTEGER;offset: INTEGER;leadingEdge: BOOLEAN; nbreaks: NBreakTablePtr;VAR offsets: OffsetTable);FUNCTION TruncString(width: INTEGER;VAR theString: Str255;truncWhere: TruncCode): INTEGER;FUNCTION TruncText(width: INTEGER;textPtr: Ptr;VAR length: INTEGER;truncWhere: TruncCode): INTEGER;FUNCTION ReplaceText(baseText: Handle;substitutionText: Handle;key: Str15): INTEGER;PROCEDURE LowercaseText(textPtr: Ptr;len: INTEGER;script: ScriptCode);PROCEDURE StripDiacritics(textPtr: Ptr;len: INTEGER;script: ScriptCode);PROCEDURE UppercaseText(textPtr: Ptr;len: INTEGER;script: ScriptCode);PROCEDURE UppercaseStripDiacritics(textPtr: Ptr;len: INTEGER;script: ScriptCode);IMPLEMENTATIONPROCEDURE IUDateString(dateTime: LONGINT;longFlag: DateForm;VAR result: Str255); BEGIN END;PROCEDURE DateString(dateTime: LONGINT;longFlag: DateForm;VAR result: Str255; intlHandle: Handle); BEGIN END;PROCEDURE IUDatePString(dateTime: LONGINT;longFlag: DateForm;VAR result: Str255; intlHandle: Handle); BEGIN END;PROCEDURE IUTimeString(dateTime: LONGINT;wantSeconds: BOOLEAN;VAR result: Str255); BEGIN END;PROCEDURE TimeString(dateTime: LONGINT;wantSeconds: BOOLEAN;VAR result: Str255; intlHandle: Handle); BEGIN END;PROCEDURE IUTimePString(dateTime: LONGINT;wantSeconds: BOOLEAN;VAR result: Str255; intlHandle: Handle); BEGIN END;PROCEDURE LongDateString(VAR dateTime: LongDateTime;longFlag: DateForm; VAR result: Str255;intlHandle: Handle); BEGIN END;PROCEDURE IULDateString(VAR dateTime: LongDateTime;longFlag: DateForm;VAR result: Str255; intlHandle: Handle); BEGIN END;PROCEDURE LongTimeString(VAR dateTime: LongDateTime;wantSeconds: BOOLEAN; VAR result: Str255;intlHandle: Handle); BEGIN END;PROCEDURE IULTimeString(VAR dateTime: LongDateTime;wantSeconds: BOOLEAN; VAR result: Str255;intlHandle: Handle); BEGIN END;FUNCTION InitDateCache(theCache: DateCachePtr): OSErr; BEGIN InitDateCache := noErr END;FUNCTION StringToDate(textPtr: Ptr;textLen: LONGINT;theCache: DateCachePtr; VAR lengthUsed: LONGINT;VAR dateTime: LongDateRec): StringToDateStatus; BEGIN StringToDate := 0 END;FUNCTION String2Date(textPtr: Ptr;textLen: LONGINT;theCache: DateCachePtr; VAR lengthUsed: LONGINT;VAR dateTime: LongDateRec): String2DateStatus; BEGIN String2Date := 0 END;FUNCTION StringToTime(textPtr: Ptr;textLen: LONGINT;theCache: DateCachePtr; VAR lengthUsed: LONGINT;VAR dateTime: LongDateRec): StringToDateStatus; BEGIN StringToTime := 0 END;FUNCTION String2Time(textPtr: Ptr;textLen: LONGINT;theCache: DateCachePtr; VAR lengthUsed: LONGINT;VAR dateTime: LongDateRec): String2DateStatus; BEGIN String2Time := 0 END;FUNCTION EqualString(str1: Str255;str2: Str255;caseSens: BOOLEAN;diacSens: BOOLEAN): BOOLEAN; BEGIN EqualString := false END;PROCEDURE UpperString(VAR theString: Str255;diacSens: BOOLEAN); BEGIN END;PROCEDURE UprString(VAR theString: Str255;diacSens: BOOLEAN); BEGIN END;FUNCTION RelString(str1: Str255;str2: Str255;caseSens: BOOLEAN;diacSens: BOOLEAN): INTEGER; BEGIN RelString := 0 END;FUNCTION GetString(stringID: INTEGER): StringHandle; BEGIN GetString := new(StringHandle) END;FUNCTION Munger(h: Handle;offset: LONGINT;ptr1: Ptr;len1: LONGINT;ptr2: Ptr; len2: LONGINT): LONGINT; BEGIN Munger := 0 END;PROCEDURE SetString(theString: StringHandle;strNew: Str255); BEGIN END;FUNCTION NewString(theString: Str255): StringHandle; BEGIN NewString := new(StringHandle) END;PROCEDURE GetIndString(VAR theString: Str255;strListID: INTEGER;index: INTEGER); BEGIN END;FUNCTION IUMagString(aPtr: Ptr;bPtr: Ptr;aLen: INTEGER;bLen: INTEGER): INTEGER; BEGIN IUMagString := 0 END;FUNCTION IUMagIDString(aPtr: Ptr;bPtr: Ptr;aLen: INTEGER;bLen: INTEGER): INTEGER; BEGIN IUMagIDString := 0 END;FUNCTION IUCompString(aStr: Str255;bStr: Str255): INTEGER; BEGIN IUCompString := 0 END;FUNCTION IUEqualString(aStr: Str255;bStr: Str255): INTEGER; BEGIN IUEqualString := 0 END;PROCEDURE StringToNum(theString: Str255;VAR theNum: LONGINT); BEGIN END;PROCEDURE NumToString(theNum: LONGINT;VAR theString: Str255); BEGIN END;FUNCTION CompareText(aPtr: Ptr;bPtr: Ptr;aLen: INTEGER;bLen: INTEGER;itl2Handle: Handle): INTEGER; BEGIN CompareText := 0 END;FUNCTION IUMagPString(aPtr: Ptr;bPtr: Ptr;aLen: INTEGER;bLen: INTEGER;itl2Handle: Handle): INTEGER; BEGIN IUMagPString := 0 END;FUNCTION IdenticalText(aPtr: Ptr;bPtr: Ptr;aLen: INTEGER;bLen: INTEGER; itl2Handle: Handle): INTEGER; BEGIN IdenticalText := 0 END;FUNCTION IUMagIDPString(aPtr: Ptr;bPtr: Ptr;aLen: INTEGER;bLen: INTEGER; itl2Handle: Handle): INTEGER; BEGIN IUMagIDPString := 0 END;FUNCTION CompareString(aStr: Str255;bStr: Str255;itl2Handle: Handle): INTEGER; BEGIN CompareString := 0 END;FUNCTION IUCompPString(aStr: Str255;bStr: Str255;itl2Handle: Handle): INTEGER; BEGIN IUCompPString := 0 END;FUNCTION IdenticalString(aStr: Str255;bStr: Str255;itl2Handle: Handle): INTEGER; BEGIN IdenticalString := 0 END;FUNCTION IUEqualPString(aStr: Str255;bStr: Str255;itl2Handle: Handle): INTEGER; BEGIN IUEqualPString := 0 END;FUNCTION ScriptOrder(script1: ScriptCode;script2: ScriptCode): INTEGER; BEGIN ScriptOrder := 0 END;FUNCTION IUScriptOrder(script1: ScriptCode;script2: ScriptCode): INTEGER; BEGIN IUScriptOrder := 0 END;FUNCTION LanguageOrder(language1: LangCode;language2: LangCode): INTEGER; BEGIN LanguageOrder := 0 END;FUNCTION IULangOrder(language1: LangCode;language2: LangCode): INTEGER; BEGIN IULangOrder := 0 END;FUNCTION TextOrder(aPtr: Ptr;bPtr: Ptr;aLen: INTEGER;bLen: INTEGER;aScript: ScriptCode; bScript: ScriptCode;aLang: LangCode;bLang: LangCode): INTEGER; BEGIN TextOrder := 0 END;FUNCTION IUTextOrder(aPtr: Ptr;bPtr: Ptr;aLen: INTEGER;bLen: INTEGER;aScript: ScriptCode; bScript: ScriptCode;aLang: LangCode;bLang: LangCode): INTEGER; BEGIN IUTextOrder := 0 END;FUNCTION StringOrder(aStr: Str255;bStr: Str255;aScript: ScriptCode;bScript: ScriptCode; aLang: LangCode;bLang: LangCode): INTEGER; BEGIN StringOrder := 0 END;FUNCTION IUStringOrder(aStr: Str255;bStr: Str255;aScript: ScriptCode;bScript: ScriptCode; aLang: LangCode;bLang: LangCode): INTEGER; BEGIN IUStringOrder := 0 END;PROCEDURE FindWord(textPtr: Ptr;textLength: INTEGER;offset: INTEGER;leadingEdge: BOOLEAN; breaks: BreakTablePtr;VAR offsets: OffsetTable); BEGIN END;PROCEDURE FindWordBreaks(textPtr: Ptr;textLength: INTEGER;offset: INTEGER; leadingEdge: BOOLEAN;breaks: BreakTablePtr;VAR offsets: OffsetTable;script: ScriptCode); BEGIN END;PROCEDURE UprText(textPtr: Ptr;len: INTEGER); BEGIN END;PROCEDURE LwrText(textPtr: Ptr;len: INTEGER); BEGIN END;PROCEDURE LowerText(textPtr: Ptr;len: INTEGER); BEGIN END;PROCEDURE StripText(textPtr: Ptr;len: INTEGER); BEGIN END;PROCEDURE UpperText(textPtr: Ptr;len: INTEGER); BEGIN END;PROCEDURE StripUpperText(textPtr: Ptr;len: INTEGER); BEGIN END;FUNCTION StyledLineBreak(textPtr: Ptr;textLen: LONGINT;textStart: LONGINT; textEnd: LONGINT;flags: LONGINT;VAR textWidth: Fixed;VAR textOffset: LONGINT): StyledLineBreakCode; BEGIN StyledLineBreak := smBreakWord END;FUNCTION StringToFormatRec(inString: Str255;partsTable: NumberParts;VAR outString: NumFormatString): FormatStatus; BEGIN StringToFormatRec := 0 END;FUNCTION Str2Format(inString: Str255;partsTable: NumberParts;VAR outString: NumFormatString): FormatStatus; BEGIN Str2Format := 0 END;FUNCTION FormatRecToString(myCanonical: NumFormatString;partsTable: NumberParts; VAR outString: Str255;VAR positions: TripleInt): FormatStatus; BEGIN FormatRecToString := 0 END;FUNCTION Format2Str(myCanonical: NumFormatString;partsTable: NumberParts; VAR outString: Str255;VAR positions: TripleInt): FormatStatus;BEGIN Format2Str := 0 END;FUNCTION ExtendedToString(x: Extended80;myCanonical: NumFormatString;partsTable: NumberParts; VAR outString: Str255): FormatStatus; BEGIN ExtendedToString := 0 END;FUNCTION FormatX2Str(x: Extended80;myCanonical: NumFormatString;partsTable: NumberParts; VAR outString: Str255): FormatStatus; BEGIN FormatX2Str := 0 END;FUNCTION StringToExtended(source: Str255;myCanonical: NumFormatString;partsTable: NumberParts; VAR x: Extended80): FormatStatus; BEGIN StringToExtended := 0 END;FUNCTION FormatStr2X(source: Str255;myCanonical: NumFormatString;partsTable: NumberParts; VAR x: Extended80): FormatStatus; BEGIN FormatStr2X := 0 END;FUNCTION FindScriptRun(textPtr: Ptr;textLen: LONGINT;VAR lenUsed: LONGINT): ScriptRunStatus;         VAR status: ScriptRunStatus;         BEGIN           status.script := 0;           status.variant := 0;           FindScriptRun := status         END;PROCEDURE NFindWord(textPtr: Ptr;textLength: INTEGER;offset: INTEGER;leadingEdge: BOOLEAN; nbreaks: NBreakTablePtr;VAR offsets: OffsetTable); BEGIN END;FUNCTION TruncString(width: INTEGER;VAR theString: Str255;truncWhere: TruncCode): INTEGER; BEGIN TruncString := 0; END;FUNCTION TruncText(width: INTEGER;textPtr: Ptr;VAR length: INTEGER;truncWhere: TruncCode): INTEGER; BEGIN TruncText := 0 END;FUNCTION ReplaceText(baseText: Handle;substitutionText: Handle;key: Str15): INTEGER; BEGIN ReplaceText := 0; END;PROCEDURE LowercaseText(textPtr: Ptr;len: INTEGER;script: ScriptCode); BEGIN END;PROCEDURE StripDiacritics(textPtr: Ptr;len: INTEGER;script: ScriptCode); BEGIN END;PROCEDURE UppercaseText(textPtr: Ptr;len: INTEGER;script: ScriptCode); BEGIN END;PROCEDURE UppercaseStripDiacritics(textPtr: Ptr;len: INTEGER;script: ScriptCode); BEGIN END;END.