{Created: Tuesday, July 30, 1991 at 2:11 PM Controls.p Pascal Interface to the Macintosh Libraries  Copyright Apple Computer, Inc. 1985-1992  All rights reserved	Change History (most recent first):		 <8>	 11/7/92	JDR		Added the PopupPrivateData record.		 <7>	  4/6/92	DCL		For New Inside Mac: Adding fancy new improved names for old									crusty routines. #1025005		 <6>	 7/30/91	JL		Updated Copyright.		 <5>	1/29/91		jal		<LN> checked in database generated file from DSG.		 <4>	12/14/90	dba		<JDR> add calc messages for 32-bit clean CDEFs; use									popupMenuProc name to match Pascal		 <3>	 11/4/90	dba		add UpdateControls (synonym for UpdtControl)		 <2>	 9/15/90	PWD		Moved popup constants here from CTBUtilities.p.  <kaz> <crz>}UNIT Controls; INTERFACE USES Types, QuickDraw, Menus;CONSTpushButProc = 0;checkBoxProc = 1;radioButProc = 2;useWFont = 8;scrollBarProc = 16;inButton = 10;inCheckBox = 11;inUpButton = 20;inDownButton = 21;inPageUp = 22;inPageDown = 23;inThumb = 129;popupMenuProc = 1008;				{ 63 * 16 }popupFixedWidth = $0001;			{ popup menu CDEF variation codes }popupUseAddResMenu = $0004;popupUseWFont = $0008;popupTitleBold = $00000100;			{ Popup Title characteristics }popupTitleItalic = $00000200;popupTitleUnderline = $00000400;popupTitleOutline = $00000800;popupTitleShadow = $00001000;popupTitleCondense = $00002000;popupTitleExtend = $00004000;popupTitleNoStyle = $00008000;popupTitleLeftJust = $00000000;popupTitleCenterJust = $00000001;popupTitleRightJust = $000000FF;{axis constraints for DragGrayRgn call}noConstraint = 0;hAxisOnly = 1;vAxisOnly = 2;{control messages}drawCntl = 0;testCntl = 1;calcCRgns = 2;initCntl = 3;dispCntl = 4;posCntl = 5;thumbCntl = 6;dragCntl = 7;autoTrack = 8;calcCntlRgn = 10;calcThumbRgn = 11;cFrameColor = 0;cBodyColor = 1;cTextColor = 2;cThumbColor = 3;popupMenuCDEFproc = popupMenuProc;	{ synonym for compatibility }TYPEControlPtr = ^ControlRecord;ControlHandle = ^ControlPtr;ControlRecord = PACKED RECORD nextControl: ControlHandle; contrlOwner: WindowPtr; contrlRect: Rect; contrlVis: Byte; contrlHilite: Byte; contrlValue: INTEGER; contrlMin: INTEGER; contrlMax: INTEGER; contrlDefProc: Handle; contrlData: Handle; contrlAction: ProcPtr; contrlRfCon: LONGINT; contrlTitle: Str255; END;PopupPrivateDataPtr = ^PopupPrivateData;PopupPrivateDataHandle = ^PopupPrivateDataPtr;PopupPrivateData = RECORD mHandle: MenuHandle;				{popup menu handle} mID: INTEGER;						{popup menu ID} END;CCTabPtr = ^CtlCTab;CCTabHandle = ^CCTabPtr;CtlCTab = RECORD ccSeed: LONGINT;					{reserved} ccRider: INTEGER;					{see what you have done - reserved} ctSize: INTEGER;					{usually 3 for controls} ctTable: ARRAY [0..3] OF ColorSpec; END;AuxCtlPtr = ^AuxCtlRec;AuxCtlHandle = ^AuxCtlPtr;AuxCtlRec = RECORD acNext: AuxCtlHandle;				{handle to next AuxCtlRec} acOwner: ControlHandle;			{handle for aux record's control} acCTable: CCTabHandle;				{color table for this control} acFlags: INTEGER;					{misc flag byte} acReserved: LONGINT;				{reserved for use by Apple} acRefCon: LONGINT;					{for use by application} END;FUNCTION NewControl(theWindow: WindowPtr;boundsRect: Rect;title: Str255; visible: BOOLEAN;value: INTEGER;min: INTEGER;max: INTEGER;procID: INTEGER; refCon: LONGINT): ControlHandle;PROCEDURE SetControlTitle(theControl: ControlHandle;title: Str255);PROCEDURE SetCTitle(theControl: ControlHandle;title: Str255);PROCEDURE GetControlTitle(theControl: ControlHandle;VAR title: Str255);PROCEDURE GetCTitle(theControl: ControlHandle;VAR title: Str255);FUNCTION GetNewControl(controlID: INTEGER;owner: WindowPtr): ControlHandle;PROCEDURE DisposeControl(theControl: ControlHandle);PROCEDURE KillControls(theWindow: WindowPtr);PROCEDURE HideControl(theControl: ControlHandle);PROCEDURE ShowControl(theControl: ControlHandle);PROCEDURE DrawControls(theWindow: WindowPtr);PROCEDURE Draw1Control(theControl: ControlHandle);PROCEDURE HiliteControl(theControl: ControlHandle;hiliteState: INTEGER);PROCEDURE UpdateControls(theWindow: WindowPtr;updateRgn: RgnHandle);PROCEDURE UpdtControl(theWindow: WindowPtr;updateRgn: RgnHandle);PROCEDURE MoveControl(theControl: ControlHandle;h: INTEGER;v: INTEGER);PROCEDURE SizeControl(theControl: ControlHandle;w: INTEGER;h: INTEGER);PROCEDURE SetControlValue(theControl: ControlHandle;theValue: INTEGER);PROCEDURE SetCtlValue(theControl: ControlHandle;theValue: INTEGER);FUNCTION GetControlValue(theControl: ControlHandle): INTEGER;FUNCTION GetCtlValue(theControl: ControlHandle): INTEGER;PROCEDURE SetControlMinimum(theControl: ControlHandle;minValue: INTEGER);PROCEDURE SetCtlMin(theControl: ControlHandle;minValue: INTEGER);FUNCTION GetControlMinimum(theControl: ControlHandle): INTEGER;FUNCTION GetCtlMin(theControl: ControlHandle): INTEGER;PROCEDURE SetControlMaximum(theControl: ControlHandle;maxValue: INTEGER);PROCEDURE SetCtlMax(theControl: ControlHandle;maxValue: INTEGER);FUNCTION GetControlMaximum(theControl: ControlHandle): INTEGER;FUNCTION GetCtlMax(theControl: ControlHandle): INTEGER;PROCEDURE SetControlReference(theControl: ControlHandle;data: LONGINT);PROCEDURE SetCRefCon(theControl: ControlHandle;data: LONGINT);FUNCTION GetControlReference(theControl: ControlHandle): LONGINT;FUNCTION GetCRefCon(theControl: ControlHandle): LONGINT;PROCEDURE SetControlAction(theControl: ControlHandle;actionProc: ProcPtr);PROCEDURE SetCtlAction(theControl: ControlHandle;actionProc: ProcPtr);FUNCTION GetControlAction(theControl: ControlHandle): ProcPtr;FUNCTION GetCtlAction(theControl: ControlHandle): ProcPtr;PROCEDURE DragControl(theControl: ControlHandle;startPt: Point;limitRect: Rect; slopRect: Rect;axis: INTEGER);FUNCTION TestControl(theControl: ControlHandle;thePt: Point): INTEGER;FUNCTION TrackControl(theControl: ControlHandle;thePoint: Point;actionProc: ProcPtr): INTEGER;FUNCTION FindControl(thePoint: Point;theWindow: WindowPtr;VAR theControl: ControlHandle): INTEGER;PROCEDURE SetControlColor(theControl: ControlHandle;newColorTable: CCTabHandle);PROCEDURE SetCtlColor(theControl: ControlHandle;newColorTable: CCTabHandle);FUNCTION GetAuxiliaryControlRecord(theControl: ControlHandle;VAR acHndl: AuxCtlHandle): BOOLEAN;FUNCTION GetAuxCtl(theControl: ControlHandle;VAR acHndl: AuxCtlHandle): BOOLEAN;FUNCTION GetControlVariant(theControl: ControlHandle): INTEGER;FUNCTION GetCVariant(theControl: ControlHandle): INTEGER;IMPLEMENTATIONFUNCTION NewControl(theWindow: WindowPtr;boundsRect: Rect;title: Str255; visible: BOOLEAN;value: INTEGER;min: INTEGER;max: INTEGER;procID: INTEGER; refCon: LONGINT): ControlHandle; BEGIN NewControl := new(ControlHandle) END;PROCEDURE SetControlTitle(theControl: ControlHandle;title: Str255); BEGIN END;PROCEDURE SetCTitle(theControl: ControlHandle;title: Str255); BEGIN END;PROCEDURE GetControlTitle(theControl: ControlHandle;VAR title: Str255); BEGIN END;PROCEDURE GetCTitle(theControl: ControlHandle;VAR title: Str255); BEGIN END;FUNCTION GetNewControl(controlID: INTEGER;owner: WindowPtr): ControlHandle; BEGIN GetNewControl := new(ControlHandle) END;PROCEDURE DisposeControl(theControl: ControlHandle); BEGIN END;PROCEDURE KillControls(theWindow: WindowPtr); BEGIN END;PROCEDURE HideControl(theControl: ControlHandle); BEGIN END;PROCEDURE ShowControl(theControl: ControlHandle); BEGIN END;PROCEDURE DrawControls(theWindow: WindowPtr); BEGIN END;PROCEDURE Draw1Control(theControl: ControlHandle); BEGIN END;PROCEDURE HiliteControl(theControl: ControlHandle;hiliteState: INTEGER); BEGIN END;PROCEDURE UpdateControls(theWindow: WindowPtr;updateRgn: RgnHandle); BEGIN END;PROCEDURE UpdtControl(theWindow: WindowPtr;updateRgn: RgnHandle); BEGIN END;PROCEDURE MoveControl(theControl: ControlHandle;h: INTEGER;v: INTEGER); BEGIN END;PROCEDURE SizeControl(theControl: ControlHandle;w: INTEGER;h: INTEGER); BEGIN END;PROCEDURE SetControlValue(theControl: ControlHandle;theValue: INTEGER); BEGIN END;PROCEDURE SetCtlValue(theControl: ControlHandle;theValue: INTEGER); BEGIN END;FUNCTION GetControlValue(theControl: ControlHandle): INTEGER; BEGIN GetControlValue := 0 END;FUNCTION GetCtlValue(theControl: ControlHandle): INTEGER; BEGIN GetCtlValue := 0 END;PROCEDURE SetControlMinimum(theControl: ControlHandle;minValue: INTEGER); BEGIN END;PROCEDURE SetCtlMin(theControl: ControlHandle;minValue: INTEGER); BEGIN END;FUNCTION GetControlMinimum(theControl: ControlHandle): INTEGER; BEGIN GetControlMinimum := 0; END;FUNCTION GetCtlMin(theControl: ControlHandle): INTEGER; BEGIN GetCtlMin := 0 END;PROCEDURE SetControlMaximum(theControl: ControlHandle;maxValue: INTEGER); BEGIN END;PROCEDURE SetCtlMax(theControl: ControlHandle;maxValue: INTEGER); BEGIN END;FUNCTION GetControlMaximum(theControl: ControlHandle): INTEGER; BEGIN GetControlMaximum := 0 END;FUNCTION GetCtlMax(theControl: ControlHandle): INTEGER; BEGIN GetCtlMax := 0 END;PROCEDURE SetControlReference(theControl: ControlHandle;data: LONGINT); BEGIN END;PROCEDURE SetCRefCon(theControl: ControlHandle;data: LONGINT); BEGIN END;FUNCTION GetControlReference(theControl: ControlHandle): LONGINT; BEGIN GetControlReference := 0 END;FUNCTION GetCRefCon(theControl: ControlHandle): LONGINT; BEGIN GetCRefCon := 0 END;PROCEDURE SetControlAction(theControl: ControlHandle;actionProc: ProcPtr); BEGIN END;PROCEDURE SetCtlAction(theControl: ControlHandle;actionProc: ProcPtr); BEGIN END;FUNCTION GetControlAction(theControl: ControlHandle): ProcPtr; BEGIN GetControlAction := new(ProcPtr) END;FUNCTION GetCtlAction(theControl: ControlHandle): ProcPtr; BEGIN GetCtlAction := new(ProcPtr) END;PROCEDURE DragControl(theControl: ControlHandle;startPt: Point;limitRect: Rect; slopRect: Rect;axis: INTEGER); BEGIN END;FUNCTION TestControl(theControl: ControlHandle;thePt: Point): INTEGER; BEGIN TestControl := 0 END;FUNCTION TrackControl(theControl: ControlHandle;thePoint: Point;actionProc: ProcPtr): INTEGER; BEGIN TrackControl := 0 END;FUNCTION FindControl(thePoint: Point;theWindow: WindowPtr;VAR theControl: ControlHandle): INTEGER; BEGIN FindControl := 0 END;PROCEDURE SetControlColor(theControl: ControlHandle;newColorTable: CCTabHandle); BEGIN END;PROCEDURE SetCtlColor(theControl: ControlHandle;newColorTable: CCTabHandle); BEGIN END;FUNCTION GetAuxiliaryControlRecord(theControl: ControlHandle;VAR acHndl: AuxCtlHandle): BOOLEAN; BEGIN GetAuxiliaryControlRecord := false END;FUNCTION GetAuxCtl(theControl: ControlHandle;VAR acHndl: AuxCtlHandle): BOOLEAN; BEGIN GetAuxCtl := false END;FUNCTION GetControlVariant(theControl: ControlHandle): INTEGER; BEGIN GetControlVariant := 0 END;FUNCTION GetCVariant(theControl: ControlHandle): INTEGER; BEGIN GetCVariant := 0 END;END.