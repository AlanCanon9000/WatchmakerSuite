unit  Genome_Window;{File name: Genome_Window.Pas}{Function: Handle a Window}{History: 12/12/90 Original by Prototyper.   }interface	{Initialize us so all our routines can be activated}	procedure Init_Genome_Window;	{Close our window}	procedure Close_Genome_Window(whichWindow:WindowPtr; var theInput:TEHandle);	{Open our window and draw everything}	procedure Open_Genome_Window(var theInput:TEHandle);	{Update our window, someone uncovered a part of us}	procedure Update_Genome_Window(whichWindow:WindowPtr);	{Handle action to our window, like controls}	procedure Do_Genome_Window(myEvent:EventRecord; var theInput:TEHandle);implementationvar		MyWindow : WindowPtr;   		{Window pointer}		tempRect,temp2Rect : Rect;  	{Temporary rectangle}		Index : Integer;    			{For looping}		CtrlHandle : ControlHandle;{Control handle}		sTemp : Str255; 				{Get text entered, temp holding} {=================================} 	{Initialize us so all our routines can be activated}	procedure Init_Genome_Window; begin   								{Start of Window initialize routine}		MyWindow:=nil;  				{Make sure other routines know we are not valid yet}end;    								{End of procedure}{=================================} 	{Close our window}	procedure Close_Genome_Window; begin   								{Start of Window close routine}		if (MyWindow <> nil) and ((MyWindow = whichWindow) or (ord4(whichWindow) = -1)) then{See if we should close this window}		begin			DisposeWindow(MyWindow);{Clear window and controls}			MyWindow := nil;    		{Make sure other routines know we are open}		end;    						{End for if (MyWindow<>nil)}end;    								{End of procedure}{=================================} 	{Update our window, someone uncovered a part of us}	procedure UpDate_Genome_Window;var		SavePort : WindowPtr;   		{Place to save the last port}begin   								{Start of Window update routine}		if (MyWindow <> nil) and (MyWindow = whichWindow) then{Handle an open when already opened}		begin			GetPort(SavePort);  		{Save the current port}			SetPort(MyWindow);  		{Set the port to my window}			DrawControls(MyWindow);{Draw all the controls}			SetPort(SavePort);  		{Restore the old port}		end;    						{End for if (MyWindow<>nil)}end;    								{End of procedure}{=================================} 	{Open our window and draw everything}	procedure Open_Genome_Window;var		Index : Integer;    			{For looping}		dataBounds : Rect;  			{For making lists}		cSize : Point;  				{For making lists}begin   								{Start of Window open routine} 		if (MyWindow = nil) then    	{Handle an open when already opened}		begin			MyWindow:= GetNewWindow(1,nil, Pointer(-1));{Get the window from the resource file}			SetPort(MyWindow);  		{Prepare to write into our window}						ShowWindow(MyWindow);   	{Show the window now}			SelectWindow(MyWindow);{Bring our window to the front}					end 							{End for if (MyWindow<>nil)}		else			SelectWindow(MyWindow);{Already open, so show it}		end;    								{End of procedure}{=================================} 	{Handle action to our window, like controls}	procedure Do_Genome_Window;var		RefCon:longint; 				{RefCon for controls}		code:integer;   				{Location of event in window or controls}		theValue:integer;   			{Current value of a control}		whichWindow:WindowPtr;  		{Window pointer where event happened}		myPt:Point; 					{Point where event happened}		theControl:ControlHandle;   	{Handle for a control}		MyErr:OSErr;    				{OS error returned}begin   								{Start of Window handler}		if (MyWindow <> nil) then   	{Handle only when the window is valid}		begin			code := FindWindow(myEvent.where, whichWindow);{Get where in window and which window}						if (myEvent.what = MouseDown) and (MyWindow = whichWindow) then{}			begin   					{}				myPt := myEvent.where;{Get mouse position}				with MyWindow^.portBits.bounds do{Make it relative}				begin					myPt.h := myPt.h + left;					myPt.v := myPt.v + top;				end;				 			 end;			 			if (MyWindow = whichWindow) and (code = inContent) then{for our window}			begin								code := FindControl(myPt, whichWindow, theControl);{Get type of control}								if (code <> 0) then{Check type of control}					code := TrackControl(theControl,myPt, nil);{Track the control}							end;    					{End for if (MyWindow=whichWindow)}		end;    						{End for if (MyWindow<>nil)}end;    								{End of procedure}{=================================} end.    								{End of unit}