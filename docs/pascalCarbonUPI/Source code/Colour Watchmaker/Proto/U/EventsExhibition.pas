unit EventsExhibition;  													{Additional event handler routines}{Unit name:  EventsExhibition.p  }{Function:  This module contains the extra event handler routines}{     These routines allow us to override events in the main loop,}{     and to handle unique events.}{ History: 20/6/91 Original by Prototyper 3.0   }interface	uses		PCommonExhibition, Common_Exhibition, {Common}		PUtils_Exhibition, Utils_Exhibition, biomorphs, MacOSAll; {General Utilities}	{Handle special key combinations}	function HandleKey (myevent: EventRecord): boolean;	{Special disk inserted handling}	function HandleDisk (myevent: EventRecord): boolean;	{Let us into the main loop}	procedure ApplLoop_Exhibition;	{Filter events from the main loop}	procedure ApplEvent_Exhibition (var DoIt: boolean; myEvent: EventRecord);	{Handle our special user events}	procedure Handle_UserEvent (TheUserEvent: UserEventRec);implementation{=======================================================}	{Routine: HandleKey}	{Purpose: Allow us to filter key strokes and special key combinations.}	{	Return TRUE if we let the main loop handle the key stroke, return}	{		FALSE if we handle it and want the main loop to ignore it.}	function HandleKey (myevent: EventRecord): boolean;		var			charCode: integer; 												{Key code}			ch: char; 															{Key pressed in Ascii}			CmdKeyPressed: boolean; 										{Command key pressed}			OptionKeyPressed: boolean;   									{Option key pressed}			ShiftKeyPressed: boolean;     									{Shift key pressed}	begin		HandleKey := TRUE;    											{Let the main loop handle it}		charCode := BitAnd(myevent.message, CharCodeMask);{Get the character}		ch := CHR(charCode); 											{Change it to ASCII}		CmdKeyPressed := (BAND(myevent.modifiers, cmdKey) <> 0);{See if Command key is down}		OptionKeyPressed := (BAND(myevent.modifiers, optionKey) <> 0);{See if Option key is down}		ShiftKeyPressed := (BAND(myevent.modifiers, shiftKey) <> 0);{See if Shift key is down}	end;{=======================================================}	{Routine: HandleDisk}	{Purpose: Allow us to handle disk inserted events specially.}	{	Return TRUE if we let the main loop handle the key stroke, return}	{		FALSE if we handle it and want the main loop to ignore it.}	function HandleDisk (myevent: EventRecord): boolean;	begin		HandleDisk := TRUE;   											{Let the main loop handle it}	end;{=======================================================}	{Routine: ApplLoop_Exhibition}	{Purpose: At the top of the main loop, called each time thru the main}	{	loop.  This is very often if WNE was false.  If WNE was true then}	{	how often this routine is called depends on the setting of SleepValue}	{	in the ApplInit routine.}	procedure ApplLoop_Exhibition;	begin		if BreedWin = FrontWindow then			myApplLoop(BreedWin);	end;{=======================================================}	{Routine: ApplEvent_Exhibition}	{Purpose: Allow us to filter all events before the main loop handles them.}	{	Set  DoIt  to TRUE to let the main loop handle the event.  Set  DoIt to}	{		FALSE if we handle it and want the main loop to ignore it.}	procedure ApplEvent_Exhibition (var DoIt: boolean; myEvent: EventRecord);	begin		DoIt := TRUE;   													{Let the main loop handle it}		if (myEvent.what = app4Evt) then   							{Handle a Suspend or Resume event}			begin				DoIt := FALSE;  												{Tell the main loop to skip it}			end		else if (myEvent.what = 0) then 								{Handle a NULL event}			begin				DoIt := FALSE;  												{Tell the main loop to skip it}			end;	end;{=======================================================}	{Routine: Handle_UserEvent}	{Purpose: Handle our special user events}	procedure Handle_UserEvent (TheUserEvent: UserEventRec);	begin	end;{=======================================================}end.    																		{End of the program}