unit Ted;interface	uses		MyGlobals, boxes, Error_Alert;	const		YardSize = 5000;		miniSize = 200;		scale = 10;{2500 would allow 18 Animals with 15 segments each and 4 joints per segment.}	type		AtomKind = (Free, AnimalTrunk, AnimalJoint, AnimalClaw, SectionTrunk, SectionJoint, SectionClaw, SegmentTrunk, SegmentJoint, SegmentClaw, Joint, Claw);		Atom = record				Kind: AtomKind;				Height: real;		{also used for Thickness of a Joint}				Width: real;		{also used for Length of a Joint}				Angle: real;		{also used in an AnimalTrunk to store the number of atoms in the animal}							{also used in SectionTrunk to store the Overlap of segments}							{also used in SegmentTrunk to store the rank number of the segment}				NextLikeMe: Integer;		{where to look in the BoneYard for the next atom. 0 means end of chain}{Also used in AnimalTrunk to store Gradient gene, slightly more or less than 100.  Treat as Percentage}				FirstBelowMe: Integer;		{where to look in the BoneYard for the next atom. 0 means end of chain}			end;		AtomPtr = ^Atom;		AtomHdl = ^AtomPtr;		AtomArray = array[1..Yardsize] of AtomHdl;		{for the real thing, use 2500}		SmallAtomArray = array[1..miniSize] of AtomHdl;		{Just holds one animal, compactly}		AnimalStarts = array[0..MaxBoxes] of integer;		LevelLocs = array[1..10] of integer;		{stores indexes of where we are when travelling through an animal}		{to copy it.  1 spare, 2 AnimalTrunk, 3 AnimalJoint, 4  SectionTrunk, 5 SectionJoint, 6 SegmentTrunk, }			{7 SegmentJoint, 8 Joint, 9 Claw, 10 spare}		KindsData = array[AtomKind] of integer;		{a number for each kind of Atom}		CumParams = array[1..9] of real;		{where the AnimalTrunk.Width is multiplied by SegmentTrunk.Width}	var		BoneYard: AtomArray;		{all atoms live here.  We index it to look at atoms}		MiniYard: SmallAtomArray;		RecordTop, RecordBottom, CurrentGenome: integer;		{index of first atom on an Animal}		BreedersChoice: AnimalStarts;		{indexes of starts of all the Animals on the screen}		NorthPole, SouthPole, EastPole, WestPole, FreePointer, MiniFree: integer;			{start searching from here for free blocks}		ParamOffset: KindsData;	{Tells where Height, Width, Angle go in a CumParams.  see Draw}		AnimalPicture: array[0..MaxBoxes] of PicHandle;		Midriff, SegmentCounter, SecondSegmentAtomNo: integer;		f: file of Atom;		naive: boolean;		GradientFactor: real;	function CountAtoms (which: integer): integer;	procedure NewMinimal;	procedure InitBoneYard;	procedure Breed;	procedure evolve (MLoc: point);{***call this as Evolve(MyPt) from Do_Breeding_Window immediately after defining MyPt}	procedure UpDateAnimals;	procedure SaveArthromorph;	procedure LoadArthromorph;	procedure StartDocument;	procedure flipWantColor;	procedure QuitGracefully; {Call right at end of whole program}	procedure Draw (which: integer; params: CumParams; x, y, xCenter: integer; var ySeg: integer);	procedure DrawInBox (BoxNo: integer);	procedure TellError (what: string);	procedure Tandem (target: integer);implementation	procedure TellError (what: string);	begin		ParamText(what, '', '', '');		A_Error_Alert;	end;	function randint (Max: Integer): Integer;		var			r: integer;	begin{delivers integer between 1 and Max;}		repeat			r := ABS(Random) mod (Max + 1)		until r > 0;		randint := r;	end;{Basic handling of Atoms}	procedure InitBoneYard;		{Call just once at the beginning}		var			this: Atom;			which: integer;	begin		for which := 1 to YardSize do			BoneYard[which] := AtomHdl(NewHandle(SizeOf(Atom)));		for which := 1 to MiniSize do			begin				MiniYard[which] := AtomHdl(NewHandle(SizeOf(Atom)));				MiniYard[which]^^.kind := free;			end;		FreePointer := 1;		for which := 1 to YardSize do			begin				BoneYard[which]^^.Kind := Free;				BoneYard[which]^^.NextLikeMe := 0;   {Don't count on this}			end;		ParamOffset[AnimalTrunk] := 1;		{where in a CumParams the Width of an AnimalTrunk gets multiplied in}		ParamOffset[AnimalJoint] := 4;		ParamOffset[AnimalClaw] := 7;		ParamOffset[SectionTrunk] := 1;		ParamOffset[SectionJoint] := 4;		ParamOffset[SectionClaw] := 7;		ParamOffset[SegmentTrunk] := 1;		ParamOffset[SegmentJoint] := 4;		ParamOffset[SegmentClaw] := 7;		ParamOffset[Joint] := 4;		ParamOffset[Claw] := 7;	end;	function Allocate: Integer;		var			this: Atom;			oldFreePtr, which: integer;	begin		oldFreePtr := FreePointer;		which := FreePointer;		repeat			this := BoneYard[which]^^;			which := which + 1;		{remember its one bigger}		until (this.Kind = Free) or (which > YardSize);		if which > YardSize then			begin				which := 1;				repeat					this := BoneYard[which]^^;					which := which + 1;				until (this.Kind = Free) or (which > oldFreePtr);				if which = oldFreePtr + 1 then					TellError('Morphs are too complex');			end;		FreePointer := which;		if which <= 1 then			TellError('Allocate tried to put out less than 1');		if which > Yardsize then			TellError('Allocate tried to put out >Yardsize');		Allocate := which - 1;		{undo the +1 above}	end;	procedure Deallocate (which: integer);	begin		BoneYard[which]^^.Kind := Free;		{toss it back}	end;{Creating and destroying Animals}	procedure Kill (which: integer);	{Destroy this animal.   Mark all of its Atoms as Free again.}	{Recursively step through the animal}		var			this: Atom;	begin		this := BoneYard[which]^^;		if this.FirstBelowMe <> 0 then			Kill(this.FirstBelowMe);		if (this.NextLikeMe <> 0) and (this.kind <> AnimalTrunk) then			Kill(this.NextLikeMe);		Deallocate(which);		{Free this Atom}	end; {Kill}	function Copy (which: integer): integer;		var			newPlace: integer;	begin	{Duplicate this entire animal.   Return the index of the start of the new animal.}	{It is a very good idea to Kill the old animal first.  That way, we can reuse its atoms.}		newPlace := Allocate;		{Grab a new atom}		BoneYard[NewPlace]^^ := BoneYard[which]^^;		if BoneYard[which]^^.FirstBelowMe <> 0 then			BoneYard[NewPlace]^^.FirstBelowMe := Copy(BoneYard[which]^^.FirstBelowMe);		if (BoneYard[which]^^.NextLikeMe <> 0) and (BoneYard[which]^^.kind <> AnimalTrunk) then			BoneYard[NewPlace]^^.NextLikeMe := Copy(BoneYard[which]^^.NextLikeMe);		Copy := newPlace;			{Return the index of the new one}	end;	function CopyExceptNext (which: integer): integer;		var			newPlace: integer;	begin	{Duplicate Subtree starting at the atom which, but don't copy NextLikeMe.  Leave old value there}	{Copy the things I own, but not the things after me}		newPlace := Allocate;		{Grab a new atom}		BoneYard[NewPlace]^^ := BoneYard[which]^^;		if BoneYard[which]^^.FirstBelowMe <> 0 then			BoneYard[NewPlace]^^.FirstBelowMe := Copy(BoneYard[which]^^.FirstBelowMe);		{Normal COPY from here on}		CopyExceptNext := newPlace;			{Return the index of the new one}	end;	function FindNth (which, pick: integer; var count: integer): integer;	{travel over the Animal, counting Atoms and return the Nth}	begin		count := count + 1;		if BoneYard[which]^^.kind = SegmentTrunk then			SegmentCounter := Segmentcounter + 1;		if segmentCounter = 2 then			SecondSegmentAtomNo := count;		if count >= pick then			FindNth := which		{We are done!}		else			with BoneYard[which]^^ do				begin					if FirstBelowMe <> 0 then						FindNth := FindNth(FirstBelowMe, pick, count);					if not (count >= pick) then						if (NextLikeMe <> 0) then							FindNth := FindNth(NextLikeMe, pick, count);					if not (count >= pick) then						FindNth := 0;		{not there yet}				end;	end;	procedure CountSeg (which: integer);		var			this: Atom;	begin		this := BoneYard[which]^^;		with this do			begin				if kind = SegmentTrunk then					begin						SegmentCounter := SegmentCounter + 1;						BoneYard[which]^^.angle := SegmentCounter;					end;				if FirstBelowMe <> 0 then					CountSeg(FirstBelowMe);				if (NextLikeMe <> 0) and (kind <> AnimalTrunk) then					CountSeg(NextLikeMe);			end	end;	function CountAtoms (which: integer): integer;	{travel over the Animal, counting Atoms}		var			count: integer;	begin		count := 1;	{count me}		with BoneYard[which]^^ do			begin				if FirstBelowMe <> 0 then					count := count + CountAtoms(FirstBelowMe);				if (NextLikeMe <> 0) and (kind <> AnimalTrunk) then					count := count + CountAtoms(NextLikeMe);			end;		CountAtoms := count;	{Me and all below me}	end;	function GetFactor: real;		{How much to grow or shrink a Length or Height or Angle}		var			choose: integer;	begin		case MutationPressure of			positive: 				choose := 2 + randint(2);			zero: 				choose := randint(4);			negative: 				choose := randint(2);		end; {cases}		case choose of			1: 			{Richard, you can play with these factors}				GetFactor := 0.50;			2: 				GetFactor := 0.9;			3: 				GetFactor := 1.1;			4: 				GetFactor := 1.5;		end; {cases}	end;	function DoDelete (which: integer): boolean;	{Delete a section of the animal somewhere near the atom which.}	{Caller must correct the AtomCount of the whole animal.  Return false if failed}		var			parent, chain: integer;	{Must have a hold on the atom above what we delete.  If chosen atom is:  }	{AnimalTrunk   delete first Sec}	{	AnimalJoint   delete first Sec}	{	AnimalClaw	delete first Sec}	{		SectionTrunk	delete next Sec}	{			SectionJoint		delete first Seg}	{			SectionClaw		delete first Seg}	{				SegmentTrunk		delete next Seg}	{					SegmentJoint		delete first Joint}	{					SegmentClaw		delete first Joint}	{						Joint				delete next Joint}	{						Joint				delete next Joint}	{						Joint				delete Claw}	{							Claw				fail}	{Also fail if trying to delete last example of a Kind}	begin		parent := which;		DoDelete := false;	{unless we actually succeed in killing one}		if (BoneYard[Parent]^^.Kind = AnimalTrunk) then			begin				parent := BoneYard[Parent]^^.FirstBelowMe;		{AinmalJoint}			end;		if (BoneYard[Parent]^^.Kind = AnimalJoint) or (BoneYard[Parent]^^.Kind = SectionJoint) or (BoneYard[Parent]^^.Kind = SegmentJoint) then			begin				parent := BoneYard[Parent]^^.FirstBelowMe;		{AinmalClaw is parent}			end;		if parent <> 0 then			with BoneYard[Parent]^^ do				if (Kind = SectionTrunk) or (Kind = SegmentTrunk) or (Kind = Joint) then					begin		{Delete NextLikeMe of parent}						if (NextLikeMe <> 0) then							begin								chain := BoneYard[NextLikeMe]^^.NextLikeMe;		{May be 0}								BoneYard[NextLikeMe]^^.NextLikeMe := 0;		{So Kill won't get the rest of chain}								Kill(NextLikeMe);		{won't be killing last one, since parent qualifies as one}								NextLikeMe := chain;								DoDelete := true;							end;					end				else		{Try to delete FirstBelow}					if (FirstBelowMe <> 0) then			{we know FirstBelow exists}						begin							chain := BoneYard[FirstBelowMe]^^.NextLikeMe;		{Atom after one we will delete}							BoneYard[FirstBelowMe]^^.NextLikeMe := 0;							if (chain <> 0) then			{FirstBelow is not only one }								begin									Kill(FirstBelowMe);									FirstBelowMe := chain;									DoDelete := true;								end;						end;	end; {DoDelete}	procedure Tandem (target: integer);		var			extraclaw: integer;			targetAtom: Atom;		{If Dup and target is second or third part of an Animal, Section, or Segment,}		{Then jump down to the next part of the animal}	begin		targetAtom := BoneYard[target]^^;		if (targetAtom.Kind = AnimalJoint) or (targetAtom.Kind = SectionJoint) or (targetAtom.Kind = SegmentJoint) then			begin				target := BoneYard[target]^^.NextLikeMe;   {AinmalClaw}				targetAtom := BoneYard[target]^^;      {fetch new atom}			end;		if (targetAtom.Kind = AnimalClaw) or (targetAtom.Kind = SectionClaw) or (targetAtom.Kind = SegmentClaw) then			target := BoneYard[target]^^.FirstBelowMe;{SectionTrunk .. where we want to be }		with BoneYard[target]^^ do			begin				NextLikeMe := CopyExceptNext(target);  {Insert copy of me after me}					{CopyExceptNext makes sure NextLikeMe of copy now points to old NextLikeMe of target}					{So brothers are kept, and new subtree is inserted}				if (Kind = Joint) and (FirstBelowMe <> 0) then		{last joint has claw.  When duplicate, get rid of extra claw}					begin						extraClaw := FirstBelowMe;						FirstBelowMe := 0;						Kill(extraClaw);					end;			end;		BoneYard[BreedersChoice[MidBox]]^^.Angle := CountAtoms(BreedersChoice[MidBox]); 		{A little wasteful to count entire animal again}	end; {Tandem}	function Mutate (which: integer): boolean;	{Mutate first picks an atom randomly from the Animal.}	{	From num of atoms, picks one and step down to it}	{		Flip a coin for what to do: change Height, Width, Angle, Dup part, Delete part, Flip angle}	{			Test if legal to do it and do it (else return false)}	{				Delete does not delete the first-and-only of its Kind}	{Forbid: Angle mod if none, delete last Section, or Seg }	{		Delete Animal, Dup Animal,   Delete Claw, Dup Claw}	{Range limits on some modifications??  Only angles can be negative.}		var			size, pick, count, target, change, extraclaw, thisSegment, lastSegment, AtomNumber: integer;			this, targetAtom: Atom;			OK, MutOK, CouldBe: boolean;			factor: real;	begin		this := BoneYard[which]^^;		if this.Kind <> AnimalTrunk then			TellError('Not an animal');		SecondSegmentAtomNo := 0;		AtomNumber := CountAtoms(which);		LastSegment := SegmentCounter;		size := trunc(this.Angle);		{As a convention, we keep the number of Atoms in this animal in AnimalTrunk's Angle field}		pick := Randint(size);		{a number from 1 to size.  Index of the atom we will modify}		count := 0;		target := FindNth(which, pick, count);  	{find the Nth atom}		if target = 0 then			begin				TellError('Atom count is wrong.  Fatal.  Quitting');		{Aren't pick atoms in this Animal}				exitToShell			end;		targetAtom := BoneYard[target]^^;	{Decide what to do}		change := randint(7);		{seven basic operations}			{ 1 twiddle Height, 2 twiddle Width, 3 twiddle Angle, 4 Duplicate entire subtree, 5 Delete subtree}			{ 6 reverse an angle , 7 reverse sign of Gradient}		if (change = 7) and (targetAtom.kind = AnimalTrunk) then			BoneYard[target]^^.NextLikeMe := -BoneYard[target]^^.NextLikeMe;		if (change = 4) then		{If Dup and target is second or third part of an Animal, Section, or Segment,}		{Then jump down to the next part of the animal}			begin				if (targetAtom.Kind = AnimalJoint) or (targetAtom.Kind = SectionJoint) or (targetAtom.Kind = SegmentJoint) then					begin						target := BoneYard[target]^^.NextLikeMe;   {AinmalClaw}						targetAtom := BoneYard[target]^^;      {fetch new atom}					end;				if (targetAtom.Kind = AnimalClaw) or (targetAtom.Kind = SectionClaw) or (targetAtom.Kind = SegmentClaw) then					target := BoneYard[target]^^.FirstBelowMe;{SectionTrunk .. where we want to be }			end;		MutOK := false;		with BoneYard[target]^^ do			case kind of				AnimalTrunk: 					if AnimalTrunkMut then						MutOK := true;				AnimalJoint: 					if AnimalLegsMut then						MutOK := true;				AnimalClaw: 					if AnimalClawsMut then						MutOK := true;				SectionTrunk: 					if SectionTrunkMut then						MutOK := true;				SectionJoint: 					if SectionLegsMut then						MutOK := true;				SectionClaw: 					if SectionClawsMut then						MutOK := true;				SegmentTrunk: 					if SegmentTrunkMut then						MutOK := true;				SegmentJoint: 					if SegmentLegsMut then						MutOK := true;				SegmentClaw: 					if SegmentClawsMut then						MutOK := true;				Joint: 					if LegsMut then						MutOK := true;				Claw: 					if ClawsMut then						MutOK := true;				otherwise					MutOK := false;			end; {cases }		case FocusOfAttention of			FirstSegmentOnly: 				if SecondSegmentAtomNo > 0 then					begin						if count < SecondSegmentAtomNo then							begin								with BoneYard[target]^^ do									CouldBe := (kind = SegmentTrunk) or (kind = SegmentJoint) or (kind = SegmentClaw) or (kind = joint) or (kind = claw);								if not CouldBe then									MutOK := false;							end					end				else					MutOK := false;			LastSegmentOnly: 				if SegmentCounter <> lastSegment then					MutOk := false;			AnySegment: 				;{No need for action.  MutOK retains its present value}		end; {cases}		if MutOK then			with BoneYard[target]^^ do				begin					OK := true;					if ((change = 4) or (change = 5)) and ((Kind = Claw)) then{(Kind = AnimalTrunk) or}						OK := false; {Forbid delete or dup of claw}					if ((change = 3) or (change = 6)) and ((Kind = AnimalTrunk) or (Kind = SegmentTrunk)) then						OK := false;		{These atoms have no Angle part. SectionTrunk does, because 'angle' is overlap, by convention}					if OK then						begin							if (change = 4) then								begin									if DuplicationMut then										begin											if kind = AnimalTrunk then												NextLikeMe := NextLikeMe + 1											else{Special case, means GradientFactor}												NextLikeMe := CopyExceptNext(target);  {Insert copy of me after me}					{CopyExceptNext makes sure NextLikeMe of copy now points to old NextLikeMe of target}					{So brothers are kept, and new subtree is inserted}											if (Kind = Joint) and (FirstBelowMe <> 0) then		{last joint has claw.  When duplicate, get rid of extra claw}												begin													extraClaw := FirstBelowMe;													FirstBelowMe := 0;													Kill(extraClaw);												end;											BoneYard[which]^^.Angle := CountAtoms(which); 		{A little wasteful to count entire animal again}										end									else										OK := false;								end; {change=4}							if (change < 4) then								begin									factor := GetFactor;		{See table above}									case change of										1: 											begin												if HeightMut then													Height := Height * factor												else													OK := false;											end;										2: 											begin												if WidthMut then													Width := Width * factor												else													OK := false;											end;										3: 											begin												if AngleMut then													begin														Angle := Angle * factor;														if (kind = SectionTrunk) then															begin																Angle := abs(angle); {forbid backward overlaps}																if Angle > 1 then																	Angle := 1; {Otherwise disembodied segments}															end;													end												else													OK := false;											end;									end; {cases}								end;							if (change = 5) then								begin									if DeletionMut then										begin											if kind = AnimalTrunk then												NextLikeMe := NextLikeMe - 1; {special case. by convention means GradientFactor}{Delete.  Complex because we need to talk to the atom above where we delete}											OK := DoDelete(target);  {there is a problem here}											if OK then												BoneYard[which]^^.Angle := CountAtoms(which);		{A little wasteful to count entire animal again}										end									else										OK := false;								end;							if (change = 6) and (kind <> SectionTrunk) then								begin									if AngleMut then										Angle := -1.0 * Angle {reverse an angle}									else										OK := false;								end						end;				end;		Mutate := OK and MutOK;	end;	function Reproduce (which: integer): integer;	{Reproduce copies an animal and calls Mutate}	{Please kill the old animal before calling this.  We may need to use his atoms.}		var			counter, new: integer;			done: boolean;	begin		counter := 0;		new := Copy(which);		repeat			counter := counter + 1;{if counter = 100 then}{SetCursor(GetCursor(watchCursor)^^);}			done := Mutate(new);		{If it fails, just try again until we succeed at changing something}		until done or (counter > 1000);		if counter > 1000 then			begin				TellError('Timed out, perhaps attempting impossible duplication or deletion');				Reproduce := which;			end		else			Reproduce := new;		{Return it}{SetCursor(GetCursor(-16000)^^);} {Arrow cursor}	end;	procedure DrawLine (x, y, endx, endy, thick: integer);		procedure Dline (x, y, endx, endy, thick: integer);		begin{thick := round(thick div thickscale);}{if thick < 1 then thick := 1;}			if endy < NorthPole then				NorthPole := endy;			if endy > SouthPole then				SouthPole := endy;			if endx < WestPole then				WestPole := endx;			if endx > EastPole then				EastPole := endx;			PenSize(thick, thick);			MoveTo(x - thick div 2, y - thick div 2);			LineTo(endX - thick div 2, endY - thick div 2);			PenSize(1, 1);		end;	begin		if sideways then			Dline(y, x, endy, endx, thick)		else			Dline(x, y, endx, endy, thick);	end; {Drawline}	procedure DrawOval (x, y, width, height: integer);		procedure DOval (x, y, width, height: integer);			var				r: rect;		begin			with r do				begin					left := x;					top := y;					right := left + width;					bottom := top + height;					if top < NorthPole then						NorthPole := top;					if bottom > SouthPole then						SouthPole := bottom;					if left < WestPole then						WestPole := left;					if right > EastPole then						EastPole := right;				end;			if WantColor then				begin					backcolor(GreenColor);					eraseOval(r)				end			else				fillOval(r, ltgray);			pensize(2, 2);			frameOval(r);			pensize(1, 1);			backColor(whiteColor);		end;	begin		if sideways then			DOval(y, x, height, width)		else			DOval(x, y, width, height);	end; {DrawOval}	procedure DrawSeg (x, y: integer; width, height: real);	{We must adjust the position before drawing the oval}		var			halfW: integer;	begin		width := width;		height := height;		halfW := round(width / 2);		DrawOval(x - halfW, y, round(width), round(height));		forecolor(BlackColor);	{convert from center of oval to left corner}	end;{DrawSeg}	procedure DrawClaw (which: integer; params: CumParams; x, y, xCenter: integer);	{Draw a claw, note that we don't use which at all.  Param info is already folded in}		var			oldX, oldY, leftOldX, leftX, thick: integer;			ang: real;	begin		foreColor(RedColor);		oldX := x;		oldY := y;		ang := params[9] / 2.0;		{half claw opening, in radians}		x := round(x + params[8] * sin(ang));		{line end point   width*sine(angle)}		y := round(y + params[8] * cos(ang));		{line end point}		thick := 1 + trunc(params[7]);		{1 is minimum thickness}		DrawLine(oldX, oldY, x, y, thick);		{right side, top of claw}		leftX := xCenter - (x - xCenter);		{do the left side, top of claw}		leftOldX := xCenter - (oldX - xCenter);		DrawLine(leftOldX, oldY, leftX, y, thick);	{Bottom of the claw}		y := round(y - 2.0 * params[8] * cos(ang));		DrawLine(oldX, oldY, x, y, thick);				{right side}		DrawLine(leftOldX, oldY, leftX, y, thick);	{left side}		ForeColor(BlackColor);	end;	procedure Draw (which: integer; params: CumParams; x, y, xCenter: integer; var ySeg: integer);	{Starting at the atom 'which', multiply its numbers into the array of params.}	{At the bottom, draw the part starting at x,y}	{params accumulates the final Joint width, Claw angle, etc.}	{params: 1 Seg height, 2 Seg width, 3 (not used), 4 Joint thickness, 5 Joint length, 6 Joint angle,}	{ 	7 Claw thickness, 8 Claw length, 9 Claw angle between pincers}	{x,y are current local point, xCenter is the centerline of the animal (left and right Joints need this)}		var			myPars: CumParams;			j, oldX, oldY, leftOldX, leftX, offset, thick: integer;			ang, jointscale, theFactor: real;			rankstring: str255;	begin		jointscale := 0.5;		myPars := params;	{local copy so next segment builds on section above, not this segment}		with BoneYard[which]^^ do			begin				if kind = AnimalTrunk then					begin						GradientFactor := NextLikeMe;						if gradientFactor > 1000 then							sysbeep(1);					end;				offset := ParamOffset[Kind];		{where in params to begin, see InitBoneYard}				params[offset] := params[offset] * Height;		{fold in this atom's params}				params[offset + 1] := params[offset + 1] * Width;				params[offset + 2] := params[offset + 2] * Angle;	{Must be a real number, even if not used in this Atom}				if kind = SectionTrunk then					overlap := angle;{by convention}				if Kind = SegmentTrunk then					begin						if GradientFactor > 1000 then							sysbeep(1);						params[2] := params[2] + GradientFactor * angle;						Params[1] := Params[1] + GradientFactor * angle;						DrawSeg(x, ySeg, params[2], params[1]);{Draw the oval in the right place. 2 = Width , 1 = Height }						oldY := ySeg;  {Save for next segment}						x := x + round(params[2] / 2.0);{joint starts at the side of the segment}						y := ySeg + round(params[1] / 2.0);{joint starts half way down the segment }					end;				if Kind = Joint then					begin			{both next joint (NextLikeMe) and claw (FirstBelowMe) want x,y at end of this joint}						oldX := x;						oldY := y;						ang := params[6];						x := round(x + jointscale * params[5] * cos(ang));		{line end point   width*sine(angle)}						y := round(y + jointscale * params[5] * sin(ang));		{line end point}						thick := 1 + trunc(params[4]);		{1 is minimum thickness}						DrawLine(oldX, oldY, x, y, thick);		{right side leg}						leftX := xCenter - (x - xCenter);		{do the left side leg}						leftOldX := xCenter - (oldX - xCenter);						DrawLine(leftOldX, oldY, leftX, y, thick);						foreColor(blackColor);					end;				if kind = Claw then					DrawClaw(which, params, x, y, xCenter)		{all work is done in here}				else {TED:  why else?  Presumably because claw is the end of the line?}					begin						if FirstBelowMe <> 0 then							Draw(FirstBelowMe, params, x, y, xCenter, ySeg);		{build on my cumulative numbers}						if Kind = SegmentTrunk then							begin								x := xCenter;								ySeg := round(oldY + overlap * params[1]);{Seg}		{Jump down by height of this segment to the next segment}							end;						if NextLikeMe <> 0 then							begin								if (Kind = AnimalJoint) or (Kind = SectionJoint) or (Kind = SegmentJoint) then									Draw(NextLikeMe, params, x, y, xCenter, ySeg)		{build on me}								else if kind <> AnimalTrunk then									Draw(NextLikeMe, myPars, x, y, xCenter, ySeg);		{build on my parent's numbers}							end;				{Note that each Joint builds on the length of the SegJoint, not the joint just before it.}				{This is consistant with the way Sections and Segments work.}					end;			end;	end; {Draw}	procedure DrawAnimal (BoxNo, x, y: integer);	{An example of how to call Draw for an animal}		var			params: CumParams;			ii, j, ySeg: integer;	begin		for ii := 1 to 9 do			params[ii] := 1.0;		{clear it all out}		ySeg := y;		Draw(BreedersChoice[BoxNo], params, x, y, x, ySeg);		{x = xCenter when we start}	end;	procedure DrawInBox (BoxNo: integer);		var			where: rect;			centre, start, boxwidth, boxheight: integer;	begin		where := Box[BoxNo];		boxwidth := where.right - where.left;		boxheight := where.bottom - where.top;		if sideways then			begin				centre := where.top + boxheight div 2;				start := where.left + boxwidth div 2;				WestPole := Prect.right;				EastPole := Prect.left;				if centring or (BoxNo = MidBox) then					begin						hidePen;						DrawAnimal(BoxNo, centre, start); {return with NorthPole and SouthPole updated}						ShowPen;						Midriff := WestPole + (EastPole - WestPole) div 2;						verticalOffset := Start - Midriff;					end;			end		else			begin				start := where.top + boxheight div 2;				centre := where.left + boxwidth div 2;				NorthPole := Prect.bottom;				SouthPole := Prect.top;				if centring or (BoxNo = MidBox) then					begin						hidePen; {Preliminary dummy draw to measure North & South extent of animal}						DrawAnimal(BoxNo, centre, start); {return with NorthPole and SouthPole updated}						ShowPen;						Midriff := NorthPole + (SouthPole - NorthPole) div 2;						verticalOffset := Start - Midriff;					end;			end;		if AnimalPicture[BoxNo] <> nil then			KillPicture(AnimalPicture[BoxNo]); {redraw Picture in correct position}		AnimalPicture[BoxNo] := OpenPicture(Box[BoxNo]);		showpen;		ClipRect(Box[BoxNo]);		DrawAnimal(BoxNo, centre, start + VerticalOffset);{Midriff := NorthPole - VerticalOffset + (SouthPole - NorthPole) div 2;}{VerticalOffset := Start - Midriff;}		hidepen;		ClipRect(Prect);		ClosePicture;	end; {DrawInBox}	procedure Clear (box: rect);		var			r: rect;	begin		with box do			begin				r.top := top + 1;				r.bottom := bottom - 1;				r.left := left + 1;				r.right := right - 1;			end;		eraserect(r);	end;{clear }	procedure evolve (MLoc: point);		var			j, Margcentre: INTEGER;			BoxesChanged: BOOLEAN;			SlideRect: rect;		procedure GrowChild (j: INTEGER);			var				k: LONGINT;		begin			Cliprect(Prect);			PenMode(PatXor);			MoveTo(Centre[Midbox].h, Centre[Midbox].v);			LineTo(Centre[j].h, Centre[j].v);			k := TickCount;			repeat			until TickCount >= k + 2;			MoveTo(Centre[Midbox].h, Centre[Midbox].v);			LineTo(Centre[j].h, Centre[j].v);			PenMode(PatCopy);			if (BoneYard[BreedersChoice[j]]^^.kind <> AnimalTrunk) then				TellError('Breeders Choise is not an animal');			if j <> MidBox then				kill(BreedersChoice[j]);			BreedersChoice[j] := reproduce(BreedersChoice[MidBox]);			SegmentCounter := 0;			CountSeg(BreedersChoice[j]);{ClipRect(Box[j]);}{if not AbortFlag then}			DrawInBox(j);		end;	begin		j := 0;		special := 0;		repeat			j := j + 1;			if (PtInRect(Mloc, box[j])) then				special := j;		until (j = NBoxes);		if special > 0 then			begin				ObscureCursor;				for j := 1 to NBoxes do					if j <> special then						if not resizing then							EraseRect(box[j]);				PenPat(white);				Framerect(box[special]);				PenPat(black);				Slide(box[special], box[MidBox]);				if special <> MidBox then					begin						kill(BreedersChoice[MidBox]);						BreedersChoice[MidBox] := Allocate;					end;				BreedersChoice[MidBox] := Copy(BreedersChoice[special]);				if not resizing then					SetUpBoxes;				ClipRect(Box[MidBox]);				DrawInBox(MidBox);				for j := 1 to MidBox - 1 do					Growchild(j);				for j := MidBox + 1 to NBoxes do					Growchild(j);				ClipRect(Prect);				special := MidBox;			end;	end; {evolve}	procedure UpDateAnimals;		var			j, offset: integer;			frameBox: rect;	begin		if resizing then			begin				setupboxes;				evolve(centre[MidBox]);				resizing := false;			end		else			begin				if startingUp then					SetUpBoxes				else					Drawboxes;				startingUp := false;				for j := 1 to NRows * NCols do					DrawPicture(AnimalPicture[j], box[j]);			end;	end; {UpDateAnimal}	function NewAtom: integer;	{Create a new atom with generic values in it}	{NewAtom has 1.0 in factors and 0 in pointers as a nice default}		var			new: integer;	begin		new := Allocate;		with BoneYard[new]^^ do			begin				Height := 1.0;				Width := 1.0;				Angle := 1.0;				NextLikeMe := 0;				FirstBelowMe := 0;			end;		NewAtom := new;	end;{I still vote for AnimalJoint . Width = 20 and AnimalJoint . Angle = 0.25 in the default animal .}	function MinimalAnimal: integer;		var			aa, bb: integer;	begin		aa := NewAtom;		BoneYard[aa]^^.Kind := Claw;		bb := NewAtom;		BoneYard[bb]^^.Kind := Joint;		BoneYard[bb]^^.width := 5;		BoneYard[bb]^^.angle := 2;		BoneYard[bb]^^.FirstBelowMe := aa;		aa := NewAtom;		BoneYard[aa]^^.Kind := SegmentClaw;		BoneYard[aa]^^.FirstBelowMe := bb;		bb := NewAtom;		BoneYard[bb]^^.Kind := SegmentJoint;		BoneYard[bb]^^.NextLikeMe := aa;		BoneYard[bb]^^.angle := 2;		aa := NewAtom;		BoneYard[aa]^^.Kind := SegmentTrunk;		BoneYard[aa]^^.FirstBelowMe := bb;		bb := NewAtom;		BoneYard[bb]^^.Kind := SectionClaw;		BoneYard[bb]^^.FirstBelowMe := aa;		aa := NewAtom;		BoneYard[aa]^^.Kind := SectionJoint;		BoneYard[aa]^^.NextLikeMe := bb;		bb := NewAtom;		BoneYard[bb]^^.Kind := SectionTrunk;		BoneYard[bb]^^.Angle := 0.5; {Segment overlap, by convention}		BoneYard[bb]^^.FirstBelowMe := aa;		aa := NewAtom;		BoneYard[aa]^^.Kind := AnimalClaw;		BoneYard[aa]^^.FirstBelowMe := bb;		bb := NewAtom;		BoneYard[bb]^^.Kind := AnimalJoint;		BoneYard[bb]^^.NextLikeMe := aa;		BoneYard[bb]^^.Width := 5;		{make it visible}		BoneYard[bb]^^.angle := 5;		aa := NewAtom;		BoneYard[aa]^^.Kind := AnimalTrunk;		BoneYard[aa]^^.FirstBelowMe := bb;		BoneYard[aa]^^.NextLikeMe := -2; {Gradient, by convention}		BoneYard[aa]^^.Angle := CountAtoms(aa);		BoneYard[aa]^^.Height := 20;		BoneYard[aa]^^.Width := 20;		MinimalAnimal := aa;	end;	procedure FirstGeneration;		var			ii: integer;	begin		for ii := 1 to MidBox - 1 do			begin				BreedersChoice[ii] := Reproduce(BreedersChoice[MidBox]);			end;		for ii := MidBox + 1 to NRows * NCols do			begin				BreedersChoice[ii] := Reproduce(BreedersChoice[MidBox]);			end;{PenNormal;}		Evolve(Centre[MidBox]);	end; {FirstGeneration}	procedure Breed;		var			ii: integer;			NeedAnimal: Boolean;	begin		NeedAnimal := false;		ii := BreedersChoice[MidBox];		if (ii < 1) or (ii > YardSize) then			NeedAnimal := true		else if Boneyard[BreedersChoice[MidBox]]^^.kind = free then			NeedAnimal := true;		if needAnimal then			begin				BreedersChoice[MidBox] := Allocate;				BreedersChoice[MidBox] := MinimalAnimal;				FirstGeneration;				BreedersChoice[MidBox] := MinimalAnimal;			end; {else the Open Breed_Window in HandleMenus is sufficient to replace the old Arthromorphs}	end;{Breed}	procedure NewMinimal;	begin		BreedersChoice[MidBox] := 0; {Force Breed to recreate new MinimalAnimal}		Breed	end;	procedure flipWantColor;	begin		wantColor := not wantColor;		DrawinBox(MidBox);	end; {flipWantColor}	function Extract (which: integer): integer;	{Copy this animal from the BoneYard to the MiniYard.}	{Return index of copy in MiniYard}{Afterwards: Since Animal is compact in the front part of MiniYard, just copy atoms}{	from 1 to MiniFree-1 into the file}		var			newPlace, ii: integer;	begin		if BoneYard[which]^^.Kind = AnimalTrunk then			begin	{Once at the start of the copy.  Erase the MiniYard}				MiniFree := 1;				for ii := 1 to miniSize do					begin						MiniYard[ii]^^.Kind := Free;					end;			end;	{Duplicate this entire animal in the other yard.   }	{Return the index of the start of the new animal.}		newPlace := miniFree;		{Grab a new atom}		miniFree := miniFree + 1;		{our Allocate since all are free}		MiniYard[newPlace]^^ := BoneYard[which]^^;		if BoneYard[which]^^.FirstBelowMe <> 0 then			MiniYard[newPlace]^^.FirstBelowMe := Extract(BoneYard[which]^^.FirstBelowMe);		if (BoneYard[which]^^.NextLikeMe <> 0) and (BoneYard[which]^^.kind <> AnimalTrunk) then			MiniYard[newPlace]^^.NextLikeMe := Extract(BoneYard[which]^^.NextLikeMe);		Extract := newPlace;			{Return the index of the new one}	end;{Example of use:-}{Extract(BreedersChoice[ii]);	}	{Copy this animal out to the MiniYard}	{Now write MiniYard from 1 to MiniFree-1 out into a file}	function Deposit (which: integer): integer;	{Caller must copy Animal from a file directly into the MiniYard, then call Deposit(1)}	{Here we copy the animal from the MiniYard into the BoneYard.}	{Return the index of the start of the new animal in the BoneYard.}		var			newPlace: integer;	begin		newPlace := Allocate;		{Grab a new atom in the BoneYard}		BoneYard[NewPlace]^^ := MiniYard[which]^^;		if MiniYard[which]^^.FirstBelowMe <> 0 then			BoneYard[NewPlace]^^.FirstBelowMe := Deposit(MiniYard[which]^^.FirstBelowMe);		if (MiniYard[which]^^.NextLikeMe <> 0) and (BoneYard[NewPlace]^^.kind <> AnimalTrunk) then			BoneYard[NewPlace]^^.NextLikeMe := Deposit(MiniYard[which]^^.NextLikeMe);		Deposit := newPlace;			{Return the index of the new one}	end;{Example of use:-}	{Read file into the MiniYard, then call this to move it to the BoneYard}{BreedersChoice[ii] := Deposit(1);}		{Install the animal in MiniYard in the BoneYard and return its start}	procedure SaveArthromorph;		var			where: point;			theReply: SFReply;			theRefNum: integer;			Error: OSErr;			i: integer;	begin		with where do			begin				h := 100;				v := 100;			end;		i := extract(BreedersChoice[MidBox]);		SFPutFile(where, 'Save this Arthromorph as:', '', nil, theReply);		if theReply.good then			begin {not cancel}				Error := SetVol(nil, theReply.vRefNum);				if Error = NoErr then					ReWrite(f, theReply.fName);				for i := 1 to MiniFree - 1 do					write(f, MiniYard[i]^^);				Close(f);			end; {not Cancel}	end; {SaveArthromorph}	function MyFilter (param: ParmBlkPtr): BOOLEAN;		var			Wanted: BOOLEAN;	begin		Wanted := (param^.ioFlFndrInfo.fdCreator = 'JOHN') and (param^.ioFlFndrInfo.fdType = 'DATA');		MyFilter := not wanted;	end;	procedure LoadArthromorph;		var			where: point;			theReply: SFReply;			theTypeList: SFTypeList;			theRefNum: integer;			Error: OSErr;			i: integer;			a: atom;			Exists: Boolean;	begin		with where do			begin				h := 100;				v := 100;			end;		theTypeList[0] := 'DATA';		SFGetFile(where, 'Load which Arthromorph?', @MyFilter, -1, theTypeList, nil, theReply);		if theReply.good then {else Cancel }			begin				i := BreedersChoice[MidBox];				Exists := (i > 0) and (i < YardSize);				if Exists then					Kill(i);				Error := SetVol(nil, theReply.vRefNum);				if Error = NoErr then					ReSet(f, theReply.fname);				i := 0;				while (i <= MiniSize) and (not eof(f)) do					begin						i := i + 1;						read(f, MiniYard[i]^^);					end;				Close(f);				BreedersChoice[MidBox] := Deposit(1);				FirstGeneration;				ValidRect(Prect);			end; {not Cancel}	end; {LoadArthromorph}	procedure StartDocument;		var			j, i, NB, vRefNum: INTEGER;			theFile: AppFile;			ErrorCode: OSErr;	begin		j := 0;		GetAppFiles(1, theFile);		with theFile do			if fType = 'APPL' then				SysBeep(1)			else				begin					ErrorCode := SetVol(nil, vRefNum);					if ErrorCode <> noErr then						SysBeep(1)					else						begin							Reset(f, fName);							i := 0;							while (i <= MiniSize) and (not eof(f)) do								begin									i := i + 1;									read(f, MiniYard[i]^^);								end;							Close(f);							BreedersChoice[MidBox] := Deposit(1);							FirstGeneration;							ValidRect(Prect);						end				end;	end; {StartDocument}	procedure QuitGracefully;		var			j: integer;	begin		for j := 1 to YardSize do			DisposHandle(Handle(BoneYard[j]));		for j := 1 to MiniSize do			DisposHandle(Handle(MiniYard[j]));		for j := 1 to NRows * NCols do			KillPicture(AnimalPicture[j]);	end; {QuitGracefully}end.